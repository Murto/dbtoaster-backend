#include <sys/time.h>
#include "macro.hpp"
#include "types.hpp"
#include "functions.hpp"
#include "hash.hpp"
#include "hashmap.hpp"
#include "serialization.hpp"

#define ELEM_SEPARATOR "\n\t\t\t"

namespace dbtoaster {
  
  /* Definitions of auxiliary maps for storing materialized views. */
  struct DATE_DIM_entry {
    long DATE_DIM_D_DATE_SK; STRING_TYPE DATE_DIM_D_DATE_ID; date DATE_DIM_D_DATE; long DATE_DIM_D_MONTH_SEQ; long DATE_DIM_D_WEEK_SEQ; long DATE_DIM_D_QUARTER_SEQ; long DATE_DIM_D_YEAR; long DATE_DIM_D_DOW; long DATE_DIM_D_MOY; long DATE_DIM_D_DOM; long DATE_DIM_D_QOY; long DATE_DIM_D_FY_YEAR; long DATE_DIM_D_FY_QUARTER_SEQ; long DATE_DIM_D_FY_WEEK_SEQ; STRING_TYPE DATE_DIM_D_DAY_NAME; STRING_TYPE DATE_DIM_D_QUARTER_NAME; STRING_TYPE DATE_DIM_D_HOLIDAY; STRING_TYPE DATE_DIM_D_WEEKEND; STRING_TYPE DATE_DIM_D_FOLLOWING_HOLIDAY; long DATE_DIM_D_FIRST_DOM; long DATE_DIM_D_LAST_DOM; long DATE_DIM_D_SAME_DAY_LY; long DATE_DIM_D_SAME_DAY_LQ; STRING_TYPE DATE_DIM_D_CURRENT_DAY; STRING_TYPE DATE_DIM_D_CURRENT_WEEK; STRING_TYPE DATE_DIM_D_CURRENT_MONTH; STRING_TYPE DATE_DIM_D_CURRENT_QUARTER; STRING_TYPE DATE_DIM_D_CURRENT_YEAR; long __av; 
    explicit DATE_DIM_entry() { /*DATE_DIM_D_DATE_SK = 0L; DATE_DIM_D_DATE_ID = ""; DATE_DIM_D_DATE = 00000000; DATE_DIM_D_MONTH_SEQ = 0L; DATE_DIM_D_WEEK_SEQ = 0L; DATE_DIM_D_QUARTER_SEQ = 0L; DATE_DIM_D_YEAR = 0L; DATE_DIM_D_DOW = 0L; DATE_DIM_D_MOY = 0L; DATE_DIM_D_DOM = 0L; DATE_DIM_D_QOY = 0L; DATE_DIM_D_FY_YEAR = 0L; DATE_DIM_D_FY_QUARTER_SEQ = 0L; DATE_DIM_D_FY_WEEK_SEQ = 0L; DATE_DIM_D_DAY_NAME = ""; DATE_DIM_D_QUARTER_NAME = ""; DATE_DIM_D_HOLIDAY = ""; DATE_DIM_D_WEEKEND = ""; DATE_DIM_D_FOLLOWING_HOLIDAY = ""; DATE_DIM_D_FIRST_DOM = 0L; DATE_DIM_D_LAST_DOM = 0L; DATE_DIM_D_SAME_DAY_LY = 0L; DATE_DIM_D_SAME_DAY_LQ = 0L; DATE_DIM_D_CURRENT_DAY = ""; DATE_DIM_D_CURRENT_WEEK = ""; DATE_DIM_D_CURRENT_MONTH = ""; DATE_DIM_D_CURRENT_QUARTER = ""; DATE_DIM_D_CURRENT_YEAR = ""; __av = 0L; */ }
    explicit DATE_DIM_entry(const long c0, const STRING_TYPE& c1, const date c2, const long c3, const long c4, const long c5, const long c6, const long c7, const long c8, const long c9, const long c10, const long c11, const long c12, const long c13, const STRING_TYPE& c14, const STRING_TYPE& c15, const STRING_TYPE& c16, const STRING_TYPE& c17, const STRING_TYPE& c18, const long c19, const long c20, const long c21, const long c22, const STRING_TYPE& c23, const STRING_TYPE& c24, const STRING_TYPE& c25, const STRING_TYPE& c26, const STRING_TYPE& c27, const long c28) { DATE_DIM_D_DATE_SK = c0; DATE_DIM_D_DATE_ID = c1; DATE_DIM_D_DATE = c2; DATE_DIM_D_MONTH_SEQ = c3; DATE_DIM_D_WEEK_SEQ = c4; DATE_DIM_D_QUARTER_SEQ = c5; DATE_DIM_D_YEAR = c6; DATE_DIM_D_DOW = c7; DATE_DIM_D_MOY = c8; DATE_DIM_D_DOM = c9; DATE_DIM_D_QOY = c10; DATE_DIM_D_FY_YEAR = c11; DATE_DIM_D_FY_QUARTER_SEQ = c12; DATE_DIM_D_FY_WEEK_SEQ = c13; DATE_DIM_D_DAY_NAME = c14; DATE_DIM_D_QUARTER_NAME = c15; DATE_DIM_D_HOLIDAY = c16; DATE_DIM_D_WEEKEND = c17; DATE_DIM_D_FOLLOWING_HOLIDAY = c18; DATE_DIM_D_FIRST_DOM = c19; DATE_DIM_D_LAST_DOM = c20; DATE_DIM_D_SAME_DAY_LY = c21; DATE_DIM_D_SAME_DAY_LQ = c22; DATE_DIM_D_CURRENT_DAY = c23; DATE_DIM_D_CURRENT_WEEK = c24; DATE_DIM_D_CURRENT_MONTH = c25; DATE_DIM_D_CURRENT_QUARTER = c26; DATE_DIM_D_CURRENT_YEAR = c27; __av = c28; }
    DATE_DIM_entry(const DATE_DIM_entry& other) : DATE_DIM_D_DATE_SK( other.DATE_DIM_D_DATE_SK ), DATE_DIM_D_DATE_ID( other.DATE_DIM_D_DATE_ID ), DATE_DIM_D_DATE( other.DATE_DIM_D_DATE ), DATE_DIM_D_MONTH_SEQ( other.DATE_DIM_D_MONTH_SEQ ), DATE_DIM_D_WEEK_SEQ( other.DATE_DIM_D_WEEK_SEQ ), DATE_DIM_D_QUARTER_SEQ( other.DATE_DIM_D_QUARTER_SEQ ), DATE_DIM_D_YEAR( other.DATE_DIM_D_YEAR ), DATE_DIM_D_DOW( other.DATE_DIM_D_DOW ), DATE_DIM_D_MOY( other.DATE_DIM_D_MOY ), DATE_DIM_D_DOM( other.DATE_DIM_D_DOM ), DATE_DIM_D_QOY( other.DATE_DIM_D_QOY ), DATE_DIM_D_FY_YEAR( other.DATE_DIM_D_FY_YEAR ), DATE_DIM_D_FY_QUARTER_SEQ( other.DATE_DIM_D_FY_QUARTER_SEQ ), DATE_DIM_D_FY_WEEK_SEQ( other.DATE_DIM_D_FY_WEEK_SEQ ), DATE_DIM_D_DAY_NAME( other.DATE_DIM_D_DAY_NAME ), DATE_DIM_D_QUARTER_NAME( other.DATE_DIM_D_QUARTER_NAME ), DATE_DIM_D_HOLIDAY( other.DATE_DIM_D_HOLIDAY ), DATE_DIM_D_WEEKEND( other.DATE_DIM_D_WEEKEND ), DATE_DIM_D_FOLLOWING_HOLIDAY( other.DATE_DIM_D_FOLLOWING_HOLIDAY ), DATE_DIM_D_FIRST_DOM( other.DATE_DIM_D_FIRST_DOM ), DATE_DIM_D_LAST_DOM( other.DATE_DIM_D_LAST_DOM ), DATE_DIM_D_SAME_DAY_LY( other.DATE_DIM_D_SAME_DAY_LY ), DATE_DIM_D_SAME_DAY_LQ( other.DATE_DIM_D_SAME_DAY_LQ ), DATE_DIM_D_CURRENT_DAY( other.DATE_DIM_D_CURRENT_DAY ), DATE_DIM_D_CURRENT_WEEK( other.DATE_DIM_D_CURRENT_WEEK ), DATE_DIM_D_CURRENT_MONTH( other.DATE_DIM_D_CURRENT_MONTH ), DATE_DIM_D_CURRENT_QUARTER( other.DATE_DIM_D_CURRENT_QUARTER ), DATE_DIM_D_CURRENT_YEAR( other.DATE_DIM_D_CURRENT_YEAR ), __av( other.__av ) {}
    FORCE_INLINE DATE_DIM_entry& modify(const long c0, const STRING_TYPE& c1, const date c2, const long c3, const long c4, const long c5, const long c6, const long c7, const long c8, const long c9, const long c10, const long c11, const long c12, const long c13, const STRING_TYPE& c14, const STRING_TYPE& c15, const STRING_TYPE& c16, const STRING_TYPE& c17, const STRING_TYPE& c18, const long c19, const long c20, const long c21, const long c22, const STRING_TYPE& c23, const STRING_TYPE& c24, const STRING_TYPE& c25, const STRING_TYPE& c26, const STRING_TYPE& c27) { DATE_DIM_D_DATE_SK = c0; DATE_DIM_D_DATE_ID = c1; DATE_DIM_D_DATE = c2; DATE_DIM_D_MONTH_SEQ = c3; DATE_DIM_D_WEEK_SEQ = c4; DATE_DIM_D_QUARTER_SEQ = c5; DATE_DIM_D_YEAR = c6; DATE_DIM_D_DOW = c7; DATE_DIM_D_MOY = c8; DATE_DIM_D_DOM = c9; DATE_DIM_D_QOY = c10; DATE_DIM_D_FY_YEAR = c11; DATE_DIM_D_FY_QUARTER_SEQ = c12; DATE_DIM_D_FY_WEEK_SEQ = c13; DATE_DIM_D_DAY_NAME = c14; DATE_DIM_D_QUARTER_NAME = c15; DATE_DIM_D_HOLIDAY = c16; DATE_DIM_D_WEEKEND = c17; DATE_DIM_D_FOLLOWING_HOLIDAY = c18; DATE_DIM_D_FIRST_DOM = c19; DATE_DIM_D_LAST_DOM = c20; DATE_DIM_D_SAME_DAY_LY = c21; DATE_DIM_D_SAME_DAY_LQ = c22; DATE_DIM_D_CURRENT_DAY = c23; DATE_DIM_D_CURRENT_WEEK = c24; DATE_DIM_D_CURRENT_MONTH = c25; DATE_DIM_D_CURRENT_QUARTER = c26; DATE_DIM_D_CURRENT_YEAR = c27;  return *this; }
    template<class Archive>
    void serialize(Archive& ar, const unsigned int version) const 
    {
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, DATE_DIM_D_DATE_SK);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, DATE_DIM_D_DATE_ID);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, DATE_DIM_D_DATE);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, DATE_DIM_D_MONTH_SEQ);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, DATE_DIM_D_WEEK_SEQ);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, DATE_DIM_D_QUARTER_SEQ);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, DATE_DIM_D_YEAR);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, DATE_DIM_D_DOW);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, DATE_DIM_D_MOY);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, DATE_DIM_D_DOM);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, DATE_DIM_D_QOY);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, DATE_DIM_D_FY_YEAR);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, DATE_DIM_D_FY_QUARTER_SEQ);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, DATE_DIM_D_FY_WEEK_SEQ);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, DATE_DIM_D_DAY_NAME);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, DATE_DIM_D_QUARTER_NAME);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, DATE_DIM_D_HOLIDAY);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, DATE_DIM_D_WEEKEND);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, DATE_DIM_D_FOLLOWING_HOLIDAY);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, DATE_DIM_D_FIRST_DOM);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, DATE_DIM_D_LAST_DOM);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, DATE_DIM_D_SAME_DAY_LY);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, DATE_DIM_D_SAME_DAY_LQ);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, DATE_DIM_D_CURRENT_DAY);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, DATE_DIM_D_CURRENT_WEEK);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, DATE_DIM_D_CURRENT_MONTH);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, DATE_DIM_D_CURRENT_QUARTER);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, DATE_DIM_D_CURRENT_YEAR);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, __av);
    }
  };
  struct DATE_DIM_mapkey0123456789101112131415161718192021222324252627_idxfn {
    FORCE_INLINE static size_t hash(const DATE_DIM_entry& e) {
      size_t h = 0;
      hash_combine(h, e.DATE_DIM_D_DATE_SK);
      hash_combine(h, e.DATE_DIM_D_DATE_ID);
      hash_combine(h, e.DATE_DIM_D_DATE);
      hash_combine(h, e.DATE_DIM_D_MONTH_SEQ);
      hash_combine(h, e.DATE_DIM_D_WEEK_SEQ);
      hash_combine(h, e.DATE_DIM_D_QUARTER_SEQ);
      hash_combine(h, e.DATE_DIM_D_YEAR);
      hash_combine(h, e.DATE_DIM_D_DOW);
      hash_combine(h, e.DATE_DIM_D_MOY);
      hash_combine(h, e.DATE_DIM_D_DOM);
      hash_combine(h, e.DATE_DIM_D_QOY);
      hash_combine(h, e.DATE_DIM_D_FY_YEAR);
      hash_combine(h, e.DATE_DIM_D_FY_QUARTER_SEQ);
      hash_combine(h, e.DATE_DIM_D_FY_WEEK_SEQ);
      hash_combine(h, e.DATE_DIM_D_DAY_NAME);
      hash_combine(h, e.DATE_DIM_D_QUARTER_NAME);
      hash_combine(h, e.DATE_DIM_D_HOLIDAY);
      hash_combine(h, e.DATE_DIM_D_WEEKEND);
      hash_combine(h, e.DATE_DIM_D_FOLLOWING_HOLIDAY);
      hash_combine(h, e.DATE_DIM_D_FIRST_DOM);
      hash_combine(h, e.DATE_DIM_D_LAST_DOM);
      hash_combine(h, e.DATE_DIM_D_SAME_DAY_LY);
      hash_combine(h, e.DATE_DIM_D_SAME_DAY_LQ);
      hash_combine(h, e.DATE_DIM_D_CURRENT_DAY);
      hash_combine(h, e.DATE_DIM_D_CURRENT_WEEK);
      hash_combine(h, e.DATE_DIM_D_CURRENT_MONTH);
      hash_combine(h, e.DATE_DIM_D_CURRENT_QUARTER);
      hash_combine(h, e.DATE_DIM_D_CURRENT_YEAR);
      return h;
    }
    FORCE_INLINE static bool equals(const DATE_DIM_entry& x, const DATE_DIM_entry& y) {
      return x.DATE_DIM_D_DATE_SK == y.DATE_DIM_D_DATE_SK && x.DATE_DIM_D_DATE_ID == y.DATE_DIM_D_DATE_ID && x.DATE_DIM_D_DATE == y.DATE_DIM_D_DATE && x.DATE_DIM_D_MONTH_SEQ == y.DATE_DIM_D_MONTH_SEQ && x.DATE_DIM_D_WEEK_SEQ == y.DATE_DIM_D_WEEK_SEQ && x.DATE_DIM_D_QUARTER_SEQ == y.DATE_DIM_D_QUARTER_SEQ && x.DATE_DIM_D_YEAR == y.DATE_DIM_D_YEAR && x.DATE_DIM_D_DOW == y.DATE_DIM_D_DOW && x.DATE_DIM_D_MOY == y.DATE_DIM_D_MOY && x.DATE_DIM_D_DOM == y.DATE_DIM_D_DOM && x.DATE_DIM_D_QOY == y.DATE_DIM_D_QOY && x.DATE_DIM_D_FY_YEAR == y.DATE_DIM_D_FY_YEAR && x.DATE_DIM_D_FY_QUARTER_SEQ == y.DATE_DIM_D_FY_QUARTER_SEQ && x.DATE_DIM_D_FY_WEEK_SEQ == y.DATE_DIM_D_FY_WEEK_SEQ && x.DATE_DIM_D_DAY_NAME == y.DATE_DIM_D_DAY_NAME && x.DATE_DIM_D_QUARTER_NAME == y.DATE_DIM_D_QUARTER_NAME && x.DATE_DIM_D_HOLIDAY == y.DATE_DIM_D_HOLIDAY && x.DATE_DIM_D_WEEKEND == y.DATE_DIM_D_WEEKEND && x.DATE_DIM_D_FOLLOWING_HOLIDAY == y.DATE_DIM_D_FOLLOWING_HOLIDAY && x.DATE_DIM_D_FIRST_DOM == y.DATE_DIM_D_FIRST_DOM && x.DATE_DIM_D_LAST_DOM == y.DATE_DIM_D_LAST_DOM && x.DATE_DIM_D_SAME_DAY_LY == y.DATE_DIM_D_SAME_DAY_LY && x.DATE_DIM_D_SAME_DAY_LQ == y.DATE_DIM_D_SAME_DAY_LQ && x.DATE_DIM_D_CURRENT_DAY == y.DATE_DIM_D_CURRENT_DAY && x.DATE_DIM_D_CURRENT_WEEK == y.DATE_DIM_D_CURRENT_WEEK && x.DATE_DIM_D_CURRENT_MONTH == y.DATE_DIM_D_CURRENT_MONTH && x.DATE_DIM_D_CURRENT_QUARTER == y.DATE_DIM_D_CURRENT_QUARTER && x.DATE_DIM_D_CURRENT_YEAR == y.DATE_DIM_D_CURRENT_YEAR;
    }
  };
  
  typedef MultiHashMap<DATE_DIM_entry,long,
    HashIndex<DATE_DIM_entry,long,DATE_DIM_mapkey0123456789101112131415161718192021222324252627_idxfn,true>
  > DATE_DIM_map;
  typedef HashIndex<DATE_DIM_entry,long,DATE_DIM_mapkey0123456789101112131415161718192021222324252627_idxfn,true> HashIndex_DATE_DIM_map_0123456789101112131415161718192021222324252627;
  
  struct HOUSEHOLD_DEMOGRAPHICS_entry {
    long HOUSEHOLD_DEMOGRAPHICS_HD_DEMO_SK; long HOUSEHOLD_DEMOGRAPHICS_HD_INCOME_BAND_SK; STRING_TYPE HOUSEHOLD_DEMOGRAPHICS_HD_BUY_POTENTIAL; long HOUSEHOLD_DEMOGRAPHICS_HD_DEP_COUNT; long HOUSEHOLD_DEMOGRAPHICS_HD_VEHICLE_COUNT; long __av; 
    explicit HOUSEHOLD_DEMOGRAPHICS_entry() { /*HOUSEHOLD_DEMOGRAPHICS_HD_DEMO_SK = 0L; HOUSEHOLD_DEMOGRAPHICS_HD_INCOME_BAND_SK = 0L; HOUSEHOLD_DEMOGRAPHICS_HD_BUY_POTENTIAL = ""; HOUSEHOLD_DEMOGRAPHICS_HD_DEP_COUNT = 0L; HOUSEHOLD_DEMOGRAPHICS_HD_VEHICLE_COUNT = 0L; __av = 0L; */ }
    explicit HOUSEHOLD_DEMOGRAPHICS_entry(const long c0, const long c1, const STRING_TYPE& c2, const long c3, const long c4, const long c5) { HOUSEHOLD_DEMOGRAPHICS_HD_DEMO_SK = c0; HOUSEHOLD_DEMOGRAPHICS_HD_INCOME_BAND_SK = c1; HOUSEHOLD_DEMOGRAPHICS_HD_BUY_POTENTIAL = c2; HOUSEHOLD_DEMOGRAPHICS_HD_DEP_COUNT = c3; HOUSEHOLD_DEMOGRAPHICS_HD_VEHICLE_COUNT = c4; __av = c5; }
    HOUSEHOLD_DEMOGRAPHICS_entry(const HOUSEHOLD_DEMOGRAPHICS_entry& other) : HOUSEHOLD_DEMOGRAPHICS_HD_DEMO_SK( other.HOUSEHOLD_DEMOGRAPHICS_HD_DEMO_SK ), HOUSEHOLD_DEMOGRAPHICS_HD_INCOME_BAND_SK( other.HOUSEHOLD_DEMOGRAPHICS_HD_INCOME_BAND_SK ), HOUSEHOLD_DEMOGRAPHICS_HD_BUY_POTENTIAL( other.HOUSEHOLD_DEMOGRAPHICS_HD_BUY_POTENTIAL ), HOUSEHOLD_DEMOGRAPHICS_HD_DEP_COUNT( other.HOUSEHOLD_DEMOGRAPHICS_HD_DEP_COUNT ), HOUSEHOLD_DEMOGRAPHICS_HD_VEHICLE_COUNT( other.HOUSEHOLD_DEMOGRAPHICS_HD_VEHICLE_COUNT ), __av( other.__av ) {}
    FORCE_INLINE HOUSEHOLD_DEMOGRAPHICS_entry& modify(const long c0, const long c1, const STRING_TYPE& c2, const long c3, const long c4) { HOUSEHOLD_DEMOGRAPHICS_HD_DEMO_SK = c0; HOUSEHOLD_DEMOGRAPHICS_HD_INCOME_BAND_SK = c1; HOUSEHOLD_DEMOGRAPHICS_HD_BUY_POTENTIAL = c2; HOUSEHOLD_DEMOGRAPHICS_HD_DEP_COUNT = c3; HOUSEHOLD_DEMOGRAPHICS_HD_VEHICLE_COUNT = c4;  return *this; }
    template<class Archive>
    void serialize(Archive& ar, const unsigned int version) const 
    {
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, HOUSEHOLD_DEMOGRAPHICS_HD_DEMO_SK);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, HOUSEHOLD_DEMOGRAPHICS_HD_INCOME_BAND_SK);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, HOUSEHOLD_DEMOGRAPHICS_HD_BUY_POTENTIAL);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, HOUSEHOLD_DEMOGRAPHICS_HD_DEP_COUNT);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, HOUSEHOLD_DEMOGRAPHICS_HD_VEHICLE_COUNT);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, __av);
    }
  };
  struct HOUSEHOLD_DEMOGRAPHICS_mapkey01234_idxfn {
    FORCE_INLINE static size_t hash(const HOUSEHOLD_DEMOGRAPHICS_entry& e) {
      size_t h = 0;
      hash_combine(h, e.HOUSEHOLD_DEMOGRAPHICS_HD_DEMO_SK);
      hash_combine(h, e.HOUSEHOLD_DEMOGRAPHICS_HD_INCOME_BAND_SK);
      hash_combine(h, e.HOUSEHOLD_DEMOGRAPHICS_HD_BUY_POTENTIAL);
      hash_combine(h, e.HOUSEHOLD_DEMOGRAPHICS_HD_DEP_COUNT);
      hash_combine(h, e.HOUSEHOLD_DEMOGRAPHICS_HD_VEHICLE_COUNT);
      return h;
    }
    FORCE_INLINE static bool equals(const HOUSEHOLD_DEMOGRAPHICS_entry& x, const HOUSEHOLD_DEMOGRAPHICS_entry& y) {
      return x.HOUSEHOLD_DEMOGRAPHICS_HD_DEMO_SK == y.HOUSEHOLD_DEMOGRAPHICS_HD_DEMO_SK && x.HOUSEHOLD_DEMOGRAPHICS_HD_INCOME_BAND_SK == y.HOUSEHOLD_DEMOGRAPHICS_HD_INCOME_BAND_SK && x.HOUSEHOLD_DEMOGRAPHICS_HD_BUY_POTENTIAL == y.HOUSEHOLD_DEMOGRAPHICS_HD_BUY_POTENTIAL && x.HOUSEHOLD_DEMOGRAPHICS_HD_DEP_COUNT == y.HOUSEHOLD_DEMOGRAPHICS_HD_DEP_COUNT && x.HOUSEHOLD_DEMOGRAPHICS_HD_VEHICLE_COUNT == y.HOUSEHOLD_DEMOGRAPHICS_HD_VEHICLE_COUNT;
    }
  };
  
  typedef MultiHashMap<HOUSEHOLD_DEMOGRAPHICS_entry,long,
    HashIndex<HOUSEHOLD_DEMOGRAPHICS_entry,long,HOUSEHOLD_DEMOGRAPHICS_mapkey01234_idxfn,true>
  > HOUSEHOLD_DEMOGRAPHICS_map;
  typedef HashIndex<HOUSEHOLD_DEMOGRAPHICS_entry,long,HOUSEHOLD_DEMOGRAPHICS_mapkey01234_idxfn,true> HashIndex_HOUSEHOLD_DEMOGRAPHICS_map_01234;
  
  struct COUNT_entry {
    STRING_TYPE CUSTOMER_C_LAST_NAME; STRING_TYPE CUSTOMER_C_FIRST_NAME; STRING_TYPE CURRENT_ADDR_CA_CITY; STRING_TYPE DN_BOUGHT_CITY; long DN_SS_TICKET_NUMBER; DOUBLE_TYPE DN_AMT; DOUBLE_TYPE DN_PROFIT; long __av; 
    explicit COUNT_entry() { /*CUSTOMER_C_LAST_NAME = ""; CUSTOMER_C_FIRST_NAME = ""; CURRENT_ADDR_CA_CITY = ""; DN_BOUGHT_CITY = ""; DN_SS_TICKET_NUMBER = 0L; DN_AMT = 0.0; DN_PROFIT = 0.0; __av = 0L; */ }
    explicit COUNT_entry(const STRING_TYPE& c0, const STRING_TYPE& c1, const STRING_TYPE& c2, const STRING_TYPE& c3, const long c4, const DOUBLE_TYPE c5, const DOUBLE_TYPE c6, const long c7) { CUSTOMER_C_LAST_NAME = c0; CUSTOMER_C_FIRST_NAME = c1; CURRENT_ADDR_CA_CITY = c2; DN_BOUGHT_CITY = c3; DN_SS_TICKET_NUMBER = c4; DN_AMT = c5; DN_PROFIT = c6; __av = c7; }
    COUNT_entry(const COUNT_entry& other) : CUSTOMER_C_LAST_NAME( other.CUSTOMER_C_LAST_NAME ), CUSTOMER_C_FIRST_NAME( other.CUSTOMER_C_FIRST_NAME ), CURRENT_ADDR_CA_CITY( other.CURRENT_ADDR_CA_CITY ), DN_BOUGHT_CITY( other.DN_BOUGHT_CITY ), DN_SS_TICKET_NUMBER( other.DN_SS_TICKET_NUMBER ), DN_AMT( other.DN_AMT ), DN_PROFIT( other.DN_PROFIT ), __av( other.__av ) {}
    FORCE_INLINE COUNT_entry& modify(const STRING_TYPE& c0, const STRING_TYPE& c1, const STRING_TYPE& c2, const STRING_TYPE& c3, const long c4, const DOUBLE_TYPE c5, const DOUBLE_TYPE c6) { CUSTOMER_C_LAST_NAME = c0; CUSTOMER_C_FIRST_NAME = c1; CURRENT_ADDR_CA_CITY = c2; DN_BOUGHT_CITY = c3; DN_SS_TICKET_NUMBER = c4; DN_AMT = c5; DN_PROFIT = c6;  return *this; }
    template<class Archive>
    void serialize(Archive& ar, const unsigned int version) const 
    {
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, CUSTOMER_C_LAST_NAME);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, CUSTOMER_C_FIRST_NAME);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, CURRENT_ADDR_CA_CITY);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, DN_BOUGHT_CITY);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, DN_SS_TICKET_NUMBER);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, DN_AMT);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, DN_PROFIT);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, __av);
    }
  };
  struct COUNT_mapkey0123456_idxfn {
    FORCE_INLINE static size_t hash(const COUNT_entry& e) {
      size_t h = 0;
      hash_combine(h, e.CUSTOMER_C_LAST_NAME);
      hash_combine(h, e.CUSTOMER_C_FIRST_NAME);
      hash_combine(h, e.CURRENT_ADDR_CA_CITY);
      hash_combine(h, e.DN_BOUGHT_CITY);
      hash_combine(h, e.DN_SS_TICKET_NUMBER);
      hash_combine(h, e.DN_AMT);
      hash_combine(h, e.DN_PROFIT);
      return h;
    }
    FORCE_INLINE static bool equals(const COUNT_entry& x, const COUNT_entry& y) {
      return x.CUSTOMER_C_LAST_NAME == y.CUSTOMER_C_LAST_NAME && x.CUSTOMER_C_FIRST_NAME == y.CUSTOMER_C_FIRST_NAME && x.CURRENT_ADDR_CA_CITY == y.CURRENT_ADDR_CA_CITY && x.DN_BOUGHT_CITY == y.DN_BOUGHT_CITY && x.DN_SS_TICKET_NUMBER == y.DN_SS_TICKET_NUMBER && x.DN_AMT == y.DN_AMT && x.DN_PROFIT == y.DN_PROFIT;
    }
  };
  
  typedef MultiHashMap<COUNT_entry,long,
    HashIndex<COUNT_entry,long,COUNT_mapkey0123456_idxfn,true>
  > COUNT_map;
  typedef HashIndex<COUNT_entry,long,COUNT_mapkey0123456_idxfn,true> HashIndex_COUNT_map_0123456;
  
  struct COUNTSTORE_SALES3_E1_4_entry {
    long COUNTSTORE_SALESSTORE_SALES_SS_SOLD_DATE_SK; long __av; 
    explicit COUNTSTORE_SALES3_E1_4_entry() { /*COUNTSTORE_SALESSTORE_SALES_SS_SOLD_DATE_SK = 0L; __av = 0L; */ }
    explicit COUNTSTORE_SALES3_E1_4_entry(const long c0, const long c1) { COUNTSTORE_SALESSTORE_SALES_SS_SOLD_DATE_SK = c0; __av = c1; }
    COUNTSTORE_SALES3_E1_4_entry(const COUNTSTORE_SALES3_E1_4_entry& other) : COUNTSTORE_SALESSTORE_SALES_SS_SOLD_DATE_SK( other.COUNTSTORE_SALESSTORE_SALES_SS_SOLD_DATE_SK ), __av( other.__av ) {}
    FORCE_INLINE COUNTSTORE_SALES3_E1_4_entry& modify(const long c0) { COUNTSTORE_SALESSTORE_SALES_SS_SOLD_DATE_SK = c0;  return *this; }
    template<class Archive>
    void serialize(Archive& ar, const unsigned int version) const 
    {
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, COUNTSTORE_SALESSTORE_SALES_SS_SOLD_DATE_SK);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, __av);
    }
  };
  struct COUNTSTORE_SALES3_E1_4_mapkey0_idxfn {
    FORCE_INLINE static size_t hash(const COUNTSTORE_SALES3_E1_4_entry& e) {
      size_t h = 0;
      hash_combine(h, e.COUNTSTORE_SALESSTORE_SALES_SS_SOLD_DATE_SK);
      return h;
    }
    FORCE_INLINE static bool equals(const COUNTSTORE_SALES3_E1_4_entry& x, const COUNTSTORE_SALES3_E1_4_entry& y) {
      return x.COUNTSTORE_SALESSTORE_SALES_SS_SOLD_DATE_SK == y.COUNTSTORE_SALESSTORE_SALES_SS_SOLD_DATE_SK;
    }
  };
  
  typedef MultiHashMap<COUNTSTORE_SALES3_E1_4_entry,long,
    HashIndex<COUNTSTORE_SALES3_E1_4_entry,long,COUNTSTORE_SALES3_E1_4_mapkey0_idxfn,true>
  > COUNTSTORE_SALES3_E1_4_map;
  typedef HashIndex<COUNTSTORE_SALES3_E1_4_entry,long,COUNTSTORE_SALES3_E1_4_mapkey0_idxfn,true> HashIndex_COUNTSTORE_SALES3_E1_4_map_0;
  
  struct COUNTSTORE_SALES3_E1_5_entry {
    long COUNTSTORE_SALESSTORE_SALES_SS_STORE_SK; long __av; 
    explicit COUNTSTORE_SALES3_E1_5_entry() { /*COUNTSTORE_SALESSTORE_SALES_SS_STORE_SK = 0L; __av = 0L; */ }
    explicit COUNTSTORE_SALES3_E1_5_entry(const long c0, const long c1) { COUNTSTORE_SALESSTORE_SALES_SS_STORE_SK = c0; __av = c1; }
    COUNTSTORE_SALES3_E1_5_entry(const COUNTSTORE_SALES3_E1_5_entry& other) : COUNTSTORE_SALESSTORE_SALES_SS_STORE_SK( other.COUNTSTORE_SALESSTORE_SALES_SS_STORE_SK ), __av( other.__av ) {}
    FORCE_INLINE COUNTSTORE_SALES3_E1_5_entry& modify(const long c0) { COUNTSTORE_SALESSTORE_SALES_SS_STORE_SK = c0;  return *this; }
    template<class Archive>
    void serialize(Archive& ar, const unsigned int version) const 
    {
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, COUNTSTORE_SALESSTORE_SALES_SS_STORE_SK);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, __av);
    }
  };
  struct COUNTSTORE_SALES3_E1_5_mapkey0_idxfn {
    FORCE_INLINE static size_t hash(const COUNTSTORE_SALES3_E1_5_entry& e) {
      size_t h = 0;
      hash_combine(h, e.COUNTSTORE_SALESSTORE_SALES_SS_STORE_SK);
      return h;
    }
    FORCE_INLINE static bool equals(const COUNTSTORE_SALES3_E1_5_entry& x, const COUNTSTORE_SALES3_E1_5_entry& y) {
      return x.COUNTSTORE_SALESSTORE_SALES_SS_STORE_SK == y.COUNTSTORE_SALESSTORE_SALES_SS_STORE_SK;
    }
  };
  
  typedef MultiHashMap<COUNTSTORE_SALES3_E1_5_entry,long,
    HashIndex<COUNTSTORE_SALES3_E1_5_entry,long,COUNTSTORE_SALES3_E1_5_mapkey0_idxfn,true>
  > COUNTSTORE_SALES3_E1_5_map;
  typedef HashIndex<COUNTSTORE_SALES3_E1_5_entry,long,COUNTSTORE_SALES3_E1_5_mapkey0_idxfn,true> HashIndex_COUNTSTORE_SALES3_E1_5_map_0;
  
  struct COUNTSTORE_SALES3_E1_6_entry {
    long COUNTSTORE_SALESSTORE_SALES_SS_HDEMO_SK; long __av; 
    explicit COUNTSTORE_SALES3_E1_6_entry() { /*COUNTSTORE_SALESSTORE_SALES_SS_HDEMO_SK = 0L; __av = 0L; */ }
    explicit COUNTSTORE_SALES3_E1_6_entry(const long c0, const long c1) { COUNTSTORE_SALESSTORE_SALES_SS_HDEMO_SK = c0; __av = c1; }
    COUNTSTORE_SALES3_E1_6_entry(const COUNTSTORE_SALES3_E1_6_entry& other) : COUNTSTORE_SALESSTORE_SALES_SS_HDEMO_SK( other.COUNTSTORE_SALESSTORE_SALES_SS_HDEMO_SK ), __av( other.__av ) {}
    FORCE_INLINE COUNTSTORE_SALES3_E1_6_entry& modify(const long c0) { COUNTSTORE_SALESSTORE_SALES_SS_HDEMO_SK = c0;  return *this; }
    template<class Archive>
    void serialize(Archive& ar, const unsigned int version) const 
    {
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, COUNTSTORE_SALESSTORE_SALES_SS_HDEMO_SK);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, __av);
    }
  };
  struct COUNTSTORE_SALES3_E1_6_mapkey0_idxfn {
    FORCE_INLINE static size_t hash(const COUNTSTORE_SALES3_E1_6_entry& e) {
      size_t h = 0;
      hash_combine(h, e.COUNTSTORE_SALESSTORE_SALES_SS_HDEMO_SK);
      return h;
    }
    FORCE_INLINE static bool equals(const COUNTSTORE_SALES3_E1_6_entry& x, const COUNTSTORE_SALES3_E1_6_entry& y) {
      return x.COUNTSTORE_SALESSTORE_SALES_SS_HDEMO_SK == y.COUNTSTORE_SALESSTORE_SALES_SS_HDEMO_SK;
    }
  };
  
  typedef MultiHashMap<COUNTSTORE_SALES3_E1_6_entry,long,
    HashIndex<COUNTSTORE_SALES3_E1_6_entry,long,COUNTSTORE_SALES3_E1_6_mapkey0_idxfn,true>
  > COUNTSTORE_SALES3_E1_6_map;
  typedef HashIndex<COUNTSTORE_SALES3_E1_6_entry,long,COUNTSTORE_SALES3_E1_6_mapkey0_idxfn,true> HashIndex_COUNTSTORE_SALES3_E1_6_map_0;
  
  struct COUNTCUSTOMER_ADDRESS2_entry {
    long CUSTOMER_C_CUSTOMER_SK; long COUNTCUSTOMER_ADDRESSCUSTOMER_ADDRESS_CA_ADDRESS_SK; STRING_TYPE CUSTOMER_C_FIRST_NAME; STRING_TYPE CUSTOMER_C_LAST_NAME; long __av; 
    explicit COUNTCUSTOMER_ADDRESS2_entry() { /*CUSTOMER_C_CUSTOMER_SK = 0L; COUNTCUSTOMER_ADDRESSCUSTOMER_ADDRESS_CA_ADDRESS_SK = 0L; CUSTOMER_C_FIRST_NAME = ""; CUSTOMER_C_LAST_NAME = ""; __av = 0L; */ }
    explicit COUNTCUSTOMER_ADDRESS2_entry(const long c0, const long c1, const STRING_TYPE& c2, const STRING_TYPE& c3, const long c4) { CUSTOMER_C_CUSTOMER_SK = c0; COUNTCUSTOMER_ADDRESSCUSTOMER_ADDRESS_CA_ADDRESS_SK = c1; CUSTOMER_C_FIRST_NAME = c2; CUSTOMER_C_LAST_NAME = c3; __av = c4; }
    COUNTCUSTOMER_ADDRESS2_entry(const COUNTCUSTOMER_ADDRESS2_entry& other) : CUSTOMER_C_CUSTOMER_SK( other.CUSTOMER_C_CUSTOMER_SK ), COUNTCUSTOMER_ADDRESSCUSTOMER_ADDRESS_CA_ADDRESS_SK( other.COUNTCUSTOMER_ADDRESSCUSTOMER_ADDRESS_CA_ADDRESS_SK ), CUSTOMER_C_FIRST_NAME( other.CUSTOMER_C_FIRST_NAME ), CUSTOMER_C_LAST_NAME( other.CUSTOMER_C_LAST_NAME ), __av( other.__av ) {}
    FORCE_INLINE COUNTCUSTOMER_ADDRESS2_entry& modify(const long c0, const long c1, const STRING_TYPE& c2, const STRING_TYPE& c3) { CUSTOMER_C_CUSTOMER_SK = c0; COUNTCUSTOMER_ADDRESSCUSTOMER_ADDRESS_CA_ADDRESS_SK = c1; CUSTOMER_C_FIRST_NAME = c2; CUSTOMER_C_LAST_NAME = c3;  return *this; }
    FORCE_INLINE COUNTCUSTOMER_ADDRESS2_entry& modify1(const long c1) { COUNTCUSTOMER_ADDRESSCUSTOMER_ADDRESS_CA_ADDRESS_SK = c1;  return *this; }
    template<class Archive>
    void serialize(Archive& ar, const unsigned int version) const 
    {
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, CUSTOMER_C_CUSTOMER_SK);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, COUNTCUSTOMER_ADDRESSCUSTOMER_ADDRESS_CA_ADDRESS_SK);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, CUSTOMER_C_FIRST_NAME);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, CUSTOMER_C_LAST_NAME);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, __av);
    }
  };
  struct COUNTCUSTOMER_ADDRESS2_mapkey0123_idxfn {
    FORCE_INLINE static size_t hash(const COUNTCUSTOMER_ADDRESS2_entry& e) {
      size_t h = 0;
      hash_combine(h, e.CUSTOMER_C_CUSTOMER_SK);
      hash_combine(h, e.COUNTCUSTOMER_ADDRESSCUSTOMER_ADDRESS_CA_ADDRESS_SK);
      hash_combine(h, e.CUSTOMER_C_FIRST_NAME);
      hash_combine(h, e.CUSTOMER_C_LAST_NAME);
      return h;
    }
    FORCE_INLINE static bool equals(const COUNTCUSTOMER_ADDRESS2_entry& x, const COUNTCUSTOMER_ADDRESS2_entry& y) {
      return x.CUSTOMER_C_CUSTOMER_SK == y.CUSTOMER_C_CUSTOMER_SK && x.COUNTCUSTOMER_ADDRESSCUSTOMER_ADDRESS_CA_ADDRESS_SK == y.COUNTCUSTOMER_ADDRESSCUSTOMER_ADDRESS_CA_ADDRESS_SK && x.CUSTOMER_C_FIRST_NAME == y.CUSTOMER_C_FIRST_NAME && x.CUSTOMER_C_LAST_NAME == y.CUSTOMER_C_LAST_NAME;
    }
  };
  
  struct COUNTCUSTOMER_ADDRESS2_mapkey1_idxfn {
    FORCE_INLINE static size_t hash(const COUNTCUSTOMER_ADDRESS2_entry& e) {
      size_t h = 0;
      hash_combine(h, e.COUNTCUSTOMER_ADDRESSCUSTOMER_ADDRESS_CA_ADDRESS_SK);
      return h;
    }
    FORCE_INLINE static bool equals(const COUNTCUSTOMER_ADDRESS2_entry& x, const COUNTCUSTOMER_ADDRESS2_entry& y) {
      return x.COUNTCUSTOMER_ADDRESSCUSTOMER_ADDRESS_CA_ADDRESS_SK == y.COUNTCUSTOMER_ADDRESSCUSTOMER_ADDRESS_CA_ADDRESS_SK;
    }
  };
  
  typedef MultiHashMap<COUNTCUSTOMER_ADDRESS2_entry,long,
    HashIndex<COUNTCUSTOMER_ADDRESS2_entry,long,COUNTCUSTOMER_ADDRESS2_mapkey0123_idxfn,true>,
    HashIndex<COUNTCUSTOMER_ADDRESS2_entry,long,COUNTCUSTOMER_ADDRESS2_mapkey1_idxfn,false>
  > COUNTCUSTOMER_ADDRESS2_map;
  typedef HashIndex<COUNTCUSTOMER_ADDRESS2_entry,long,COUNTCUSTOMER_ADDRESS2_mapkey0123_idxfn,true> HashIndex_COUNTCUSTOMER_ADDRESS2_map_0123;
  typedef HashIndex<COUNTCUSTOMER_ADDRESS2_entry,long,COUNTCUSTOMER_ADDRESS2_mapkey1_idxfn,false> HashIndex_COUNTCUSTOMER_ADDRESS2_map_1;
  
  struct COUNTCUSTOMER_ADDRESS3_entry {
    STRING_TYPE CURRENT_ADDR_CA_CITY; long CUSTOMER_C_CUSTOMER_SK; STRING_TYPE CUSTOMER_C_FIRST_NAME; STRING_TYPE CUSTOMER_C_LAST_NAME; long __av; 
    explicit COUNTCUSTOMER_ADDRESS3_entry() { /*CURRENT_ADDR_CA_CITY = ""; CUSTOMER_C_CUSTOMER_SK = 0L; CUSTOMER_C_FIRST_NAME = ""; CUSTOMER_C_LAST_NAME = ""; __av = 0L; */ }
    explicit COUNTCUSTOMER_ADDRESS3_entry(const STRING_TYPE& c0, const long c1, const STRING_TYPE& c2, const STRING_TYPE& c3, const long c4) { CURRENT_ADDR_CA_CITY = c0; CUSTOMER_C_CUSTOMER_SK = c1; CUSTOMER_C_FIRST_NAME = c2; CUSTOMER_C_LAST_NAME = c3; __av = c4; }
    COUNTCUSTOMER_ADDRESS3_entry(const COUNTCUSTOMER_ADDRESS3_entry& other) : CURRENT_ADDR_CA_CITY( other.CURRENT_ADDR_CA_CITY ), CUSTOMER_C_CUSTOMER_SK( other.CUSTOMER_C_CUSTOMER_SK ), CUSTOMER_C_FIRST_NAME( other.CUSTOMER_C_FIRST_NAME ), CUSTOMER_C_LAST_NAME( other.CUSTOMER_C_LAST_NAME ), __av( other.__av ) {}
    FORCE_INLINE COUNTCUSTOMER_ADDRESS3_entry& modify(const STRING_TYPE& c0, const long c1, const STRING_TYPE& c2, const STRING_TYPE& c3) { CURRENT_ADDR_CA_CITY = c0; CUSTOMER_C_CUSTOMER_SK = c1; CUSTOMER_C_FIRST_NAME = c2; CUSTOMER_C_LAST_NAME = c3;  return *this; }
    FORCE_INLINE COUNTCUSTOMER_ADDRESS3_entry& modify1(const long c1) { CUSTOMER_C_CUSTOMER_SK = c1;  return *this; }
    template<class Archive>
    void serialize(Archive& ar, const unsigned int version) const 
    {
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, CURRENT_ADDR_CA_CITY);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, CUSTOMER_C_CUSTOMER_SK);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, CUSTOMER_C_FIRST_NAME);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, CUSTOMER_C_LAST_NAME);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, __av);
    }
  };
  struct COUNTCUSTOMER_ADDRESS3_mapkey0123_idxfn {
    FORCE_INLINE static size_t hash(const COUNTCUSTOMER_ADDRESS3_entry& e) {
      size_t h = 0;
      hash_combine(h, e.CURRENT_ADDR_CA_CITY);
      hash_combine(h, e.CUSTOMER_C_CUSTOMER_SK);
      hash_combine(h, e.CUSTOMER_C_FIRST_NAME);
      hash_combine(h, e.CUSTOMER_C_LAST_NAME);
      return h;
    }
    FORCE_INLINE static bool equals(const COUNTCUSTOMER_ADDRESS3_entry& x, const COUNTCUSTOMER_ADDRESS3_entry& y) {
      return x.CURRENT_ADDR_CA_CITY == y.CURRENT_ADDR_CA_CITY && x.CUSTOMER_C_CUSTOMER_SK == y.CUSTOMER_C_CUSTOMER_SK && x.CUSTOMER_C_FIRST_NAME == y.CUSTOMER_C_FIRST_NAME && x.CUSTOMER_C_LAST_NAME == y.CUSTOMER_C_LAST_NAME;
    }
  };
  
  struct COUNTCUSTOMER_ADDRESS3_mapkey1_idxfn {
    FORCE_INLINE static size_t hash(const COUNTCUSTOMER_ADDRESS3_entry& e) {
      size_t h = 0;
      hash_combine(h, e.CUSTOMER_C_CUSTOMER_SK);
      return h;
    }
    FORCE_INLINE static bool equals(const COUNTCUSTOMER_ADDRESS3_entry& x, const COUNTCUSTOMER_ADDRESS3_entry& y) {
      return x.CUSTOMER_C_CUSTOMER_SK == y.CUSTOMER_C_CUSTOMER_SK;
    }
  };
  
  typedef MultiHashMap<COUNTCUSTOMER_ADDRESS3_entry,long,
    HashIndex<COUNTCUSTOMER_ADDRESS3_entry,long,COUNTCUSTOMER_ADDRESS3_mapkey0123_idxfn,true>,
    HashIndex<COUNTCUSTOMER_ADDRESS3_entry,long,COUNTCUSTOMER_ADDRESS3_mapkey1_idxfn,false>
  > COUNTCUSTOMER_ADDRESS3_map;
  typedef HashIndex<COUNTCUSTOMER_ADDRESS3_entry,long,COUNTCUSTOMER_ADDRESS3_mapkey0123_idxfn,true> HashIndex_COUNTCUSTOMER_ADDRESS3_map_0123;
  typedef HashIndex<COUNTCUSTOMER_ADDRESS3_entry,long,COUNTCUSTOMER_ADDRESS3_mapkey1_idxfn,false> HashIndex_COUNTCUSTOMER_ADDRESS3_map_1;
  
  struct COUNTCUSTOMER_ADDRESS3_E2_2_entry {
    long CUSTOMER_C_CUSTOMER_SK; long COUNTCUSTOMER_ADDRESSCUSTOMER_ADDRESS_CA_ADDRESS_SK; long DN_SS_TICKET_NUMBER; long __av; 
    explicit COUNTCUSTOMER_ADDRESS3_E2_2_entry() { /*CUSTOMER_C_CUSTOMER_SK = 0L; COUNTCUSTOMER_ADDRESSCUSTOMER_ADDRESS_CA_ADDRESS_SK = 0L; DN_SS_TICKET_NUMBER = 0L; __av = 0L; */ }
    explicit COUNTCUSTOMER_ADDRESS3_E2_2_entry(const long c0, const long c1, const long c2, const long c3) { CUSTOMER_C_CUSTOMER_SK = c0; COUNTCUSTOMER_ADDRESSCUSTOMER_ADDRESS_CA_ADDRESS_SK = c1; DN_SS_TICKET_NUMBER = c2; __av = c3; }
    COUNTCUSTOMER_ADDRESS3_E2_2_entry(const COUNTCUSTOMER_ADDRESS3_E2_2_entry& other) : CUSTOMER_C_CUSTOMER_SK( other.CUSTOMER_C_CUSTOMER_SK ), COUNTCUSTOMER_ADDRESSCUSTOMER_ADDRESS_CA_ADDRESS_SK( other.COUNTCUSTOMER_ADDRESSCUSTOMER_ADDRESS_CA_ADDRESS_SK ), DN_SS_TICKET_NUMBER( other.DN_SS_TICKET_NUMBER ), __av( other.__av ) {}
    FORCE_INLINE COUNTCUSTOMER_ADDRESS3_E2_2_entry& modify(const long c0, const long c1, const long c2) { CUSTOMER_C_CUSTOMER_SK = c0; COUNTCUSTOMER_ADDRESSCUSTOMER_ADDRESS_CA_ADDRESS_SK = c1; DN_SS_TICKET_NUMBER = c2;  return *this; }
    FORCE_INLINE COUNTCUSTOMER_ADDRESS3_E2_2_entry& modify1(const long c1) { COUNTCUSTOMER_ADDRESSCUSTOMER_ADDRESS_CA_ADDRESS_SK = c1;  return *this; }
    FORCE_INLINE COUNTCUSTOMER_ADDRESS3_E2_2_entry& modify01(const long c0, const long c1) { CUSTOMER_C_CUSTOMER_SK = c0; COUNTCUSTOMER_ADDRESSCUSTOMER_ADDRESS_CA_ADDRESS_SK = c1;  return *this; }
    template<class Archive>
    void serialize(Archive& ar, const unsigned int version) const 
    {
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, CUSTOMER_C_CUSTOMER_SK);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, COUNTCUSTOMER_ADDRESSCUSTOMER_ADDRESS_CA_ADDRESS_SK);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, DN_SS_TICKET_NUMBER);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, __av);
    }
  };
  struct COUNTCUSTOMER_ADDRESS3_E2_2_mapkey012_idxfn {
    FORCE_INLINE static size_t hash(const COUNTCUSTOMER_ADDRESS3_E2_2_entry& e) {
      size_t h = 0;
      hash_combine(h, e.CUSTOMER_C_CUSTOMER_SK);
      hash_combine(h, e.COUNTCUSTOMER_ADDRESSCUSTOMER_ADDRESS_CA_ADDRESS_SK);
      hash_combine(h, e.DN_SS_TICKET_NUMBER);
      return h;
    }
    FORCE_INLINE static bool equals(const COUNTCUSTOMER_ADDRESS3_E2_2_entry& x, const COUNTCUSTOMER_ADDRESS3_E2_2_entry& y) {
      return x.CUSTOMER_C_CUSTOMER_SK == y.CUSTOMER_C_CUSTOMER_SK && x.COUNTCUSTOMER_ADDRESSCUSTOMER_ADDRESS_CA_ADDRESS_SK == y.COUNTCUSTOMER_ADDRESSCUSTOMER_ADDRESS_CA_ADDRESS_SK && x.DN_SS_TICKET_NUMBER == y.DN_SS_TICKET_NUMBER;
    }
  };
  
  struct COUNTCUSTOMER_ADDRESS3_E2_2_mapkey1_idxfn {
    FORCE_INLINE static size_t hash(const COUNTCUSTOMER_ADDRESS3_E2_2_entry& e) {
      size_t h = 0;
      hash_combine(h, e.COUNTCUSTOMER_ADDRESSCUSTOMER_ADDRESS_CA_ADDRESS_SK);
      return h;
    }
    FORCE_INLINE static bool equals(const COUNTCUSTOMER_ADDRESS3_E2_2_entry& x, const COUNTCUSTOMER_ADDRESS3_E2_2_entry& y) {
      return x.COUNTCUSTOMER_ADDRESSCUSTOMER_ADDRESS_CA_ADDRESS_SK == y.COUNTCUSTOMER_ADDRESSCUSTOMER_ADDRESS_CA_ADDRESS_SK;
    }
  };
  
  struct COUNTCUSTOMER_ADDRESS3_E2_2_mapkey01_idxfn {
    FORCE_INLINE static size_t hash(const COUNTCUSTOMER_ADDRESS3_E2_2_entry& e) {
      size_t h = 0;
      hash_combine(h, e.CUSTOMER_C_CUSTOMER_SK);
      hash_combine(h, e.COUNTCUSTOMER_ADDRESSCUSTOMER_ADDRESS_CA_ADDRESS_SK);
      return h;
    }
    FORCE_INLINE static bool equals(const COUNTCUSTOMER_ADDRESS3_E2_2_entry& x, const COUNTCUSTOMER_ADDRESS3_E2_2_entry& y) {
      return x.CUSTOMER_C_CUSTOMER_SK == y.CUSTOMER_C_CUSTOMER_SK && x.COUNTCUSTOMER_ADDRESSCUSTOMER_ADDRESS_CA_ADDRESS_SK == y.COUNTCUSTOMER_ADDRESSCUSTOMER_ADDRESS_CA_ADDRESS_SK;
    }
  };
  
  typedef MultiHashMap<COUNTCUSTOMER_ADDRESS3_E2_2_entry,long,
    HashIndex<COUNTCUSTOMER_ADDRESS3_E2_2_entry,long,COUNTCUSTOMER_ADDRESS3_E2_2_mapkey012_idxfn,true>,
    HashIndex<COUNTCUSTOMER_ADDRESS3_E2_2_entry,long,COUNTCUSTOMER_ADDRESS3_E2_2_mapkey1_idxfn,false>,
    HashIndex<COUNTCUSTOMER_ADDRESS3_E2_2_entry,long,COUNTCUSTOMER_ADDRESS3_E2_2_mapkey01_idxfn,false>
  > COUNTCUSTOMER_ADDRESS3_E2_2_map;
  typedef HashIndex<COUNTCUSTOMER_ADDRESS3_E2_2_entry,long,COUNTCUSTOMER_ADDRESS3_E2_2_mapkey012_idxfn,true> HashIndex_COUNTCUSTOMER_ADDRESS3_E2_2_map_012;
  typedef HashIndex<COUNTCUSTOMER_ADDRESS3_E2_2_entry,long,COUNTCUSTOMER_ADDRESS3_E2_2_mapkey1_idxfn,false> HashIndex_COUNTCUSTOMER_ADDRESS3_E2_2_map_1;
  typedef HashIndex<COUNTCUSTOMER_ADDRESS3_E2_2_entry,long,COUNTCUSTOMER_ADDRESS3_E2_2_mapkey01_idxfn,false> HashIndex_COUNTCUSTOMER_ADDRESS3_E2_2_map_01;
  
  struct COUNTCUSTOMER_ADDRESS3_E2_2STORE2_entry {
    long CUSTOMER_C_CUSTOMER_SK; long COUNTCUSTOMER_ADDRESSCUSTOMER_ADDRESS_CA_ADDRESS_SK; long COUNTCUSTOMER_ADDRESS3_E2_2STORESTORE_S_STORE_SK; long DN_SS_TICKET_NUMBER; long __av; 
    explicit COUNTCUSTOMER_ADDRESS3_E2_2STORE2_entry() { /*CUSTOMER_C_CUSTOMER_SK = 0L; COUNTCUSTOMER_ADDRESSCUSTOMER_ADDRESS_CA_ADDRESS_SK = 0L; COUNTCUSTOMER_ADDRESS3_E2_2STORESTORE_S_STORE_SK = 0L; DN_SS_TICKET_NUMBER = 0L; __av = 0L; */ }
    explicit COUNTCUSTOMER_ADDRESS3_E2_2STORE2_entry(const long c0, const long c1, const long c2, const long c3, const long c4) { CUSTOMER_C_CUSTOMER_SK = c0; COUNTCUSTOMER_ADDRESSCUSTOMER_ADDRESS_CA_ADDRESS_SK = c1; COUNTCUSTOMER_ADDRESS3_E2_2STORESTORE_S_STORE_SK = c2; DN_SS_TICKET_NUMBER = c3; __av = c4; }
    COUNTCUSTOMER_ADDRESS3_E2_2STORE2_entry(const COUNTCUSTOMER_ADDRESS3_E2_2STORE2_entry& other) : CUSTOMER_C_CUSTOMER_SK( other.CUSTOMER_C_CUSTOMER_SK ), COUNTCUSTOMER_ADDRESSCUSTOMER_ADDRESS_CA_ADDRESS_SK( other.COUNTCUSTOMER_ADDRESSCUSTOMER_ADDRESS_CA_ADDRESS_SK ), COUNTCUSTOMER_ADDRESS3_E2_2STORESTORE_S_STORE_SK( other.COUNTCUSTOMER_ADDRESS3_E2_2STORESTORE_S_STORE_SK ), DN_SS_TICKET_NUMBER( other.DN_SS_TICKET_NUMBER ), __av( other.__av ) {}
    FORCE_INLINE COUNTCUSTOMER_ADDRESS3_E2_2STORE2_entry& modify(const long c0, const long c1, const long c2, const long c3) { CUSTOMER_C_CUSTOMER_SK = c0; COUNTCUSTOMER_ADDRESSCUSTOMER_ADDRESS_CA_ADDRESS_SK = c1; COUNTCUSTOMER_ADDRESS3_E2_2STORESTORE_S_STORE_SK = c2; DN_SS_TICKET_NUMBER = c3;  return *this; }
    FORCE_INLINE COUNTCUSTOMER_ADDRESS3_E2_2STORE2_entry& modify1(const long c1) { COUNTCUSTOMER_ADDRESSCUSTOMER_ADDRESS_CA_ADDRESS_SK = c1;  return *this; }
    FORCE_INLINE COUNTCUSTOMER_ADDRESS3_E2_2STORE2_entry& modify2(const long c2) { COUNTCUSTOMER_ADDRESS3_E2_2STORESTORE_S_STORE_SK = c2;  return *this; }
    template<class Archive>
    void serialize(Archive& ar, const unsigned int version) const 
    {
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, CUSTOMER_C_CUSTOMER_SK);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, COUNTCUSTOMER_ADDRESSCUSTOMER_ADDRESS_CA_ADDRESS_SK);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, COUNTCUSTOMER_ADDRESS3_E2_2STORESTORE_S_STORE_SK);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, DN_SS_TICKET_NUMBER);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, __av);
    }
  };
  struct COUNTCUSTOMER_ADDRESS3_E2_2STORE2_mapkey0123_idxfn {
    FORCE_INLINE static size_t hash(const COUNTCUSTOMER_ADDRESS3_E2_2STORE2_entry& e) {
      size_t h = 0;
      hash_combine(h, e.CUSTOMER_C_CUSTOMER_SK);
      hash_combine(h, e.COUNTCUSTOMER_ADDRESSCUSTOMER_ADDRESS_CA_ADDRESS_SK);
      hash_combine(h, e.COUNTCUSTOMER_ADDRESS3_E2_2STORESTORE_S_STORE_SK);
      hash_combine(h, e.DN_SS_TICKET_NUMBER);
      return h;
    }
    FORCE_INLINE static bool equals(const COUNTCUSTOMER_ADDRESS3_E2_2STORE2_entry& x, const COUNTCUSTOMER_ADDRESS3_E2_2STORE2_entry& y) {
      return x.CUSTOMER_C_CUSTOMER_SK == y.CUSTOMER_C_CUSTOMER_SK && x.COUNTCUSTOMER_ADDRESSCUSTOMER_ADDRESS_CA_ADDRESS_SK == y.COUNTCUSTOMER_ADDRESSCUSTOMER_ADDRESS_CA_ADDRESS_SK && x.COUNTCUSTOMER_ADDRESS3_E2_2STORESTORE_S_STORE_SK == y.COUNTCUSTOMER_ADDRESS3_E2_2STORESTORE_S_STORE_SK && x.DN_SS_TICKET_NUMBER == y.DN_SS_TICKET_NUMBER;
    }
  };
  
  struct COUNTCUSTOMER_ADDRESS3_E2_2STORE2_mapkey1_idxfn {
    FORCE_INLINE static size_t hash(const COUNTCUSTOMER_ADDRESS3_E2_2STORE2_entry& e) {
      size_t h = 0;
      hash_combine(h, e.COUNTCUSTOMER_ADDRESSCUSTOMER_ADDRESS_CA_ADDRESS_SK);
      return h;
    }
    FORCE_INLINE static bool equals(const COUNTCUSTOMER_ADDRESS3_E2_2STORE2_entry& x, const COUNTCUSTOMER_ADDRESS3_E2_2STORE2_entry& y) {
      return x.COUNTCUSTOMER_ADDRESSCUSTOMER_ADDRESS_CA_ADDRESS_SK == y.COUNTCUSTOMER_ADDRESSCUSTOMER_ADDRESS_CA_ADDRESS_SK;
    }
  };
  
  struct COUNTCUSTOMER_ADDRESS3_E2_2STORE2_mapkey2_idxfn {
    FORCE_INLINE static size_t hash(const COUNTCUSTOMER_ADDRESS3_E2_2STORE2_entry& e) {
      size_t h = 0;
      hash_combine(h, e.COUNTCUSTOMER_ADDRESS3_E2_2STORESTORE_S_STORE_SK);
      return h;
    }
    FORCE_INLINE static bool equals(const COUNTCUSTOMER_ADDRESS3_E2_2STORE2_entry& x, const COUNTCUSTOMER_ADDRESS3_E2_2STORE2_entry& y) {
      return x.COUNTCUSTOMER_ADDRESS3_E2_2STORESTORE_S_STORE_SK == y.COUNTCUSTOMER_ADDRESS3_E2_2STORESTORE_S_STORE_SK;
    }
  };
  
  typedef MultiHashMap<COUNTCUSTOMER_ADDRESS3_E2_2STORE2_entry,long,
    HashIndex<COUNTCUSTOMER_ADDRESS3_E2_2STORE2_entry,long,COUNTCUSTOMER_ADDRESS3_E2_2STORE2_mapkey0123_idxfn,true>,
    HashIndex<COUNTCUSTOMER_ADDRESS3_E2_2STORE2_entry,long,COUNTCUSTOMER_ADDRESS3_E2_2STORE2_mapkey1_idxfn,false>,
    HashIndex<COUNTCUSTOMER_ADDRESS3_E2_2STORE2_entry,long,COUNTCUSTOMER_ADDRESS3_E2_2STORE2_mapkey2_idxfn,false>
  > COUNTCUSTOMER_ADDRESS3_E2_2STORE2_map;
  typedef HashIndex<COUNTCUSTOMER_ADDRESS3_E2_2STORE2_entry,long,COUNTCUSTOMER_ADDRESS3_E2_2STORE2_mapkey0123_idxfn,true> HashIndex_COUNTCUSTOMER_ADDRESS3_E2_2STORE2_map_0123;
  typedef HashIndex<COUNTCUSTOMER_ADDRESS3_E2_2STORE2_entry,long,COUNTCUSTOMER_ADDRESS3_E2_2STORE2_mapkey1_idxfn,false> HashIndex_COUNTCUSTOMER_ADDRESS3_E2_2STORE2_map_1;
  typedef HashIndex<COUNTCUSTOMER_ADDRESS3_E2_2STORE2_entry,long,COUNTCUSTOMER_ADDRESS3_E2_2STORE2_mapkey2_idxfn,false> HashIndex_COUNTCUSTOMER_ADDRESS3_E2_2STORE2_map_2;
  
  struct COUNTCUSTOMER1_entry {
    long COUNTCUSTOMERCUSTOMER_C_CURRENT_ADDR_SK; STRING_TYPE CURRENT_ADDR_CA_CITY; long __av; 
    explicit COUNTCUSTOMER1_entry() { /*COUNTCUSTOMERCUSTOMER_C_CURRENT_ADDR_SK = 0L; CURRENT_ADDR_CA_CITY = ""; __av = 0L; */ }
    explicit COUNTCUSTOMER1_entry(const long c0, const STRING_TYPE& c1, const long c2) { COUNTCUSTOMERCUSTOMER_C_CURRENT_ADDR_SK = c0; CURRENT_ADDR_CA_CITY = c1; __av = c2; }
    COUNTCUSTOMER1_entry(const COUNTCUSTOMER1_entry& other) : COUNTCUSTOMERCUSTOMER_C_CURRENT_ADDR_SK( other.COUNTCUSTOMERCUSTOMER_C_CURRENT_ADDR_SK ), CURRENT_ADDR_CA_CITY( other.CURRENT_ADDR_CA_CITY ), __av( other.__av ) {}
    FORCE_INLINE COUNTCUSTOMER1_entry& modify(const long c0, const STRING_TYPE& c1) { COUNTCUSTOMERCUSTOMER_C_CURRENT_ADDR_SK = c0; CURRENT_ADDR_CA_CITY = c1;  return *this; }
    FORCE_INLINE COUNTCUSTOMER1_entry& modify0(const long c0) { COUNTCUSTOMERCUSTOMER_C_CURRENT_ADDR_SK = c0;  return *this; }
    template<class Archive>
    void serialize(Archive& ar, const unsigned int version) const 
    {
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, COUNTCUSTOMERCUSTOMER_C_CURRENT_ADDR_SK);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, CURRENT_ADDR_CA_CITY);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, __av);
    }
  };
  struct COUNTCUSTOMER1_mapkey01_idxfn {
    FORCE_INLINE static size_t hash(const COUNTCUSTOMER1_entry& e) {
      size_t h = 0;
      hash_combine(h, e.COUNTCUSTOMERCUSTOMER_C_CURRENT_ADDR_SK);
      hash_combine(h, e.CURRENT_ADDR_CA_CITY);
      return h;
    }
    FORCE_INLINE static bool equals(const COUNTCUSTOMER1_entry& x, const COUNTCUSTOMER1_entry& y) {
      return x.COUNTCUSTOMERCUSTOMER_C_CURRENT_ADDR_SK == y.COUNTCUSTOMERCUSTOMER_C_CURRENT_ADDR_SK && x.CURRENT_ADDR_CA_CITY == y.CURRENT_ADDR_CA_CITY;
    }
  };
  
  struct COUNTCUSTOMER1_mapkey0_idxfn {
    FORCE_INLINE static size_t hash(const COUNTCUSTOMER1_entry& e) {
      size_t h = 0;
      hash_combine(h, e.COUNTCUSTOMERCUSTOMER_C_CURRENT_ADDR_SK);
      return h;
    }
    FORCE_INLINE static bool equals(const COUNTCUSTOMER1_entry& x, const COUNTCUSTOMER1_entry& y) {
      return x.COUNTCUSTOMERCUSTOMER_C_CURRENT_ADDR_SK == y.COUNTCUSTOMERCUSTOMER_C_CURRENT_ADDR_SK;
    }
  };
  
  typedef MultiHashMap<COUNTCUSTOMER1_entry,long,
    HashIndex<COUNTCUSTOMER1_entry,long,COUNTCUSTOMER1_mapkey01_idxfn,true>,
    HashIndex<COUNTCUSTOMER1_entry,long,COUNTCUSTOMER1_mapkey0_idxfn,false>
  > COUNTCUSTOMER1_map;
  typedef HashIndex<COUNTCUSTOMER1_entry,long,COUNTCUSTOMER1_mapkey01_idxfn,true> HashIndex_COUNTCUSTOMER1_map_01;
  typedef HashIndex<COUNTCUSTOMER1_entry,long,COUNTCUSTOMER1_mapkey0_idxfn,false> HashIndex_COUNTCUSTOMER1_map_0;
  
  struct COUNTCUSTOMER1_E1_1_entry {
    long COUNTCUSTOMERCUSTOMER_C_CUSTOMER_SK; long STORE_SALES_SS_ADDR_SK; long DN_SS_TICKET_NUMBER; STRING_TYPE DN_BOUGHT_CITY; long __av; 
    explicit COUNTCUSTOMER1_E1_1_entry() { /*COUNTCUSTOMERCUSTOMER_C_CUSTOMER_SK = 0L; STORE_SALES_SS_ADDR_SK = 0L; DN_SS_TICKET_NUMBER = 0L; DN_BOUGHT_CITY = ""; __av = 0L; */ }
    explicit COUNTCUSTOMER1_E1_1_entry(const long c0, const long c1, const long c2, const STRING_TYPE& c3, const long c4) { COUNTCUSTOMERCUSTOMER_C_CUSTOMER_SK = c0; STORE_SALES_SS_ADDR_SK = c1; DN_SS_TICKET_NUMBER = c2; DN_BOUGHT_CITY = c3; __av = c4; }
    COUNTCUSTOMER1_E1_1_entry(const COUNTCUSTOMER1_E1_1_entry& other) : COUNTCUSTOMERCUSTOMER_C_CUSTOMER_SK( other.COUNTCUSTOMERCUSTOMER_C_CUSTOMER_SK ), STORE_SALES_SS_ADDR_SK( other.STORE_SALES_SS_ADDR_SK ), DN_SS_TICKET_NUMBER( other.DN_SS_TICKET_NUMBER ), DN_BOUGHT_CITY( other.DN_BOUGHT_CITY ), __av( other.__av ) {}
    FORCE_INLINE COUNTCUSTOMER1_E1_1_entry& modify(const long c0, const long c1, const long c2, const STRING_TYPE& c3) { COUNTCUSTOMERCUSTOMER_C_CUSTOMER_SK = c0; STORE_SALES_SS_ADDR_SK = c1; DN_SS_TICKET_NUMBER = c2; DN_BOUGHT_CITY = c3;  return *this; }
    FORCE_INLINE COUNTCUSTOMER1_E1_1_entry& modify0(const long c0) { COUNTCUSTOMERCUSTOMER_C_CUSTOMER_SK = c0;  return *this; }
    template<class Archive>
    void serialize(Archive& ar, const unsigned int version) const 
    {
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, COUNTCUSTOMERCUSTOMER_C_CUSTOMER_SK);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, STORE_SALES_SS_ADDR_SK);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, DN_SS_TICKET_NUMBER);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, DN_BOUGHT_CITY);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, __av);
    }
  };
  struct COUNTCUSTOMER1_E1_1_mapkey0123_idxfn {
    FORCE_INLINE static size_t hash(const COUNTCUSTOMER1_E1_1_entry& e) {
      size_t h = 0;
      hash_combine(h, e.COUNTCUSTOMERCUSTOMER_C_CUSTOMER_SK);
      hash_combine(h, e.STORE_SALES_SS_ADDR_SK);
      hash_combine(h, e.DN_SS_TICKET_NUMBER);
      hash_combine(h, e.DN_BOUGHT_CITY);
      return h;
    }
    FORCE_INLINE static bool equals(const COUNTCUSTOMER1_E1_1_entry& x, const COUNTCUSTOMER1_E1_1_entry& y) {
      return x.COUNTCUSTOMERCUSTOMER_C_CUSTOMER_SK == y.COUNTCUSTOMERCUSTOMER_C_CUSTOMER_SK && x.STORE_SALES_SS_ADDR_SK == y.STORE_SALES_SS_ADDR_SK && x.DN_SS_TICKET_NUMBER == y.DN_SS_TICKET_NUMBER && x.DN_BOUGHT_CITY == y.DN_BOUGHT_CITY;
    }
  };
  
  struct COUNTCUSTOMER1_E1_1_mapkey0_idxfn {
    FORCE_INLINE static size_t hash(const COUNTCUSTOMER1_E1_1_entry& e) {
      size_t h = 0;
      hash_combine(h, e.COUNTCUSTOMERCUSTOMER_C_CUSTOMER_SK);
      return h;
    }
    FORCE_INLINE static bool equals(const COUNTCUSTOMER1_E1_1_entry& x, const COUNTCUSTOMER1_E1_1_entry& y) {
      return x.COUNTCUSTOMERCUSTOMER_C_CUSTOMER_SK == y.COUNTCUSTOMERCUSTOMER_C_CUSTOMER_SK;
    }
  };
  
  typedef MultiHashMap<COUNTCUSTOMER1_E1_1_entry,long,
    HashIndex<COUNTCUSTOMER1_E1_1_entry,long,COUNTCUSTOMER1_E1_1_mapkey0123_idxfn,true>,
    HashIndex<COUNTCUSTOMER1_E1_1_entry,long,COUNTCUSTOMER1_E1_1_mapkey0_idxfn,false>
  > COUNTCUSTOMER1_E1_1_map;
  typedef HashIndex<COUNTCUSTOMER1_E1_1_entry,long,COUNTCUSTOMER1_E1_1_mapkey0123_idxfn,true> HashIndex_COUNTCUSTOMER1_E1_1_map_0123;
  typedef HashIndex<COUNTCUSTOMER1_E1_1_entry,long,COUNTCUSTOMER1_E1_1_mapkey0_idxfn,false> HashIndex_COUNTCUSTOMER1_E1_1_map_0;
  
  struct COUNTCUSTOMER1_E1_1STORE2_entry {
    long COUNTCUSTOMERCUSTOMER_C_CUSTOMER_SK; long STORE_SALES_SS_ADDR_SK; long COUNTCUSTOMER1_E1_1STORESTORE_S_STORE_SK; long DN_SS_TICKET_NUMBER; STRING_TYPE DN_BOUGHT_CITY; long __av; 
    explicit COUNTCUSTOMER1_E1_1STORE2_entry() { /*COUNTCUSTOMERCUSTOMER_C_CUSTOMER_SK = 0L; STORE_SALES_SS_ADDR_SK = 0L; COUNTCUSTOMER1_E1_1STORESTORE_S_STORE_SK = 0L; DN_SS_TICKET_NUMBER = 0L; DN_BOUGHT_CITY = ""; __av = 0L; */ }
    explicit COUNTCUSTOMER1_E1_1STORE2_entry(const long c0, const long c1, const long c2, const long c3, const STRING_TYPE& c4, const long c5) { COUNTCUSTOMERCUSTOMER_C_CUSTOMER_SK = c0; STORE_SALES_SS_ADDR_SK = c1; COUNTCUSTOMER1_E1_1STORESTORE_S_STORE_SK = c2; DN_SS_TICKET_NUMBER = c3; DN_BOUGHT_CITY = c4; __av = c5; }
    COUNTCUSTOMER1_E1_1STORE2_entry(const COUNTCUSTOMER1_E1_1STORE2_entry& other) : COUNTCUSTOMERCUSTOMER_C_CUSTOMER_SK( other.COUNTCUSTOMERCUSTOMER_C_CUSTOMER_SK ), STORE_SALES_SS_ADDR_SK( other.STORE_SALES_SS_ADDR_SK ), COUNTCUSTOMER1_E1_1STORESTORE_S_STORE_SK( other.COUNTCUSTOMER1_E1_1STORESTORE_S_STORE_SK ), DN_SS_TICKET_NUMBER( other.DN_SS_TICKET_NUMBER ), DN_BOUGHT_CITY( other.DN_BOUGHT_CITY ), __av( other.__av ) {}
    FORCE_INLINE COUNTCUSTOMER1_E1_1STORE2_entry& modify(const long c0, const long c1, const long c2, const long c3, const STRING_TYPE& c4) { COUNTCUSTOMERCUSTOMER_C_CUSTOMER_SK = c0; STORE_SALES_SS_ADDR_SK = c1; COUNTCUSTOMER1_E1_1STORESTORE_S_STORE_SK = c2; DN_SS_TICKET_NUMBER = c3; DN_BOUGHT_CITY = c4;  return *this; }
    FORCE_INLINE COUNTCUSTOMER1_E1_1STORE2_entry& modify2(const long c2) { COUNTCUSTOMER1_E1_1STORESTORE_S_STORE_SK = c2;  return *this; }
    template<class Archive>
    void serialize(Archive& ar, const unsigned int version) const 
    {
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, COUNTCUSTOMERCUSTOMER_C_CUSTOMER_SK);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, STORE_SALES_SS_ADDR_SK);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, COUNTCUSTOMER1_E1_1STORESTORE_S_STORE_SK);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, DN_SS_TICKET_NUMBER);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, DN_BOUGHT_CITY);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, __av);
    }
  };
  struct COUNTCUSTOMER1_E1_1STORE2_mapkey01234_idxfn {
    FORCE_INLINE static size_t hash(const COUNTCUSTOMER1_E1_1STORE2_entry& e) {
      size_t h = 0;
      hash_combine(h, e.COUNTCUSTOMERCUSTOMER_C_CUSTOMER_SK);
      hash_combine(h, e.STORE_SALES_SS_ADDR_SK);
      hash_combine(h, e.COUNTCUSTOMER1_E1_1STORESTORE_S_STORE_SK);
      hash_combine(h, e.DN_SS_TICKET_NUMBER);
      hash_combine(h, e.DN_BOUGHT_CITY);
      return h;
    }
    FORCE_INLINE static bool equals(const COUNTCUSTOMER1_E1_1STORE2_entry& x, const COUNTCUSTOMER1_E1_1STORE2_entry& y) {
      return x.COUNTCUSTOMERCUSTOMER_C_CUSTOMER_SK == y.COUNTCUSTOMERCUSTOMER_C_CUSTOMER_SK && x.STORE_SALES_SS_ADDR_SK == y.STORE_SALES_SS_ADDR_SK && x.COUNTCUSTOMER1_E1_1STORESTORE_S_STORE_SK == y.COUNTCUSTOMER1_E1_1STORESTORE_S_STORE_SK && x.DN_SS_TICKET_NUMBER == y.DN_SS_TICKET_NUMBER && x.DN_BOUGHT_CITY == y.DN_BOUGHT_CITY;
    }
  };
  
  struct COUNTCUSTOMER1_E1_1STORE2_mapkey2_idxfn {
    FORCE_INLINE static size_t hash(const COUNTCUSTOMER1_E1_1STORE2_entry& e) {
      size_t h = 0;
      hash_combine(h, e.COUNTCUSTOMER1_E1_1STORESTORE_S_STORE_SK);
      return h;
    }
    FORCE_INLINE static bool equals(const COUNTCUSTOMER1_E1_1STORE2_entry& x, const COUNTCUSTOMER1_E1_1STORE2_entry& y) {
      return x.COUNTCUSTOMER1_E1_1STORESTORE_S_STORE_SK == y.COUNTCUSTOMER1_E1_1STORESTORE_S_STORE_SK;
    }
  };
  
  typedef MultiHashMap<COUNTCUSTOMER1_E1_1STORE2_entry,long,
    HashIndex<COUNTCUSTOMER1_E1_1STORE2_entry,long,COUNTCUSTOMER1_E1_1STORE2_mapkey01234_idxfn,true>,
    HashIndex<COUNTCUSTOMER1_E1_1STORE2_entry,long,COUNTCUSTOMER1_E1_1STORE2_mapkey2_idxfn,false>
  > COUNTCUSTOMER1_E1_1STORE2_map;
  typedef HashIndex<COUNTCUSTOMER1_E1_1STORE2_entry,long,COUNTCUSTOMER1_E1_1STORE2_mapkey01234_idxfn,true> HashIndex_COUNTCUSTOMER1_E1_1STORE2_map_01234;
  typedef HashIndex<COUNTCUSTOMER1_E1_1STORE2_entry,long,COUNTCUSTOMER1_E1_1STORE2_mapkey2_idxfn,false> HashIndex_COUNTCUSTOMER1_E1_1STORE2_map_2;
  
  struct COUNTCUSTOMER1_L2_1_entry {
    long STORE_SALES_SS_ADDR_SK; STRING_TYPE DN_BOUGHT_CITY; long __av; 
    explicit COUNTCUSTOMER1_L2_1_entry() { /*STORE_SALES_SS_ADDR_SK = 0L; DN_BOUGHT_CITY = ""; __av = 0L; */ }
    explicit COUNTCUSTOMER1_L2_1_entry(const long c0, const STRING_TYPE& c1, const long c2) { STORE_SALES_SS_ADDR_SK = c0; DN_BOUGHT_CITY = c1; __av = c2; }
    COUNTCUSTOMER1_L2_1_entry(const COUNTCUSTOMER1_L2_1_entry& other) : STORE_SALES_SS_ADDR_SK( other.STORE_SALES_SS_ADDR_SK ), DN_BOUGHT_CITY( other.DN_BOUGHT_CITY ), __av( other.__av ) {}
    FORCE_INLINE COUNTCUSTOMER1_L2_1_entry& modify(const long c0, const STRING_TYPE& c1) { STORE_SALES_SS_ADDR_SK = c0; DN_BOUGHT_CITY = c1;  return *this; }
    FORCE_INLINE COUNTCUSTOMER1_L2_1_entry& modify0(const long c0) { STORE_SALES_SS_ADDR_SK = c0;  return *this; }
    template<class Archive>
    void serialize(Archive& ar, const unsigned int version) const 
    {
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, STORE_SALES_SS_ADDR_SK);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, DN_BOUGHT_CITY);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, __av);
    }
  };
  struct COUNTCUSTOMER1_L2_1_mapkey01_idxfn {
    FORCE_INLINE static size_t hash(const COUNTCUSTOMER1_L2_1_entry& e) {
      size_t h = 0;
      hash_combine(h, e.STORE_SALES_SS_ADDR_SK);
      hash_combine(h, e.DN_BOUGHT_CITY);
      return h;
    }
    FORCE_INLINE static bool equals(const COUNTCUSTOMER1_L2_1_entry& x, const COUNTCUSTOMER1_L2_1_entry& y) {
      return x.STORE_SALES_SS_ADDR_SK == y.STORE_SALES_SS_ADDR_SK && x.DN_BOUGHT_CITY == y.DN_BOUGHT_CITY;
    }
  };
  
  struct COUNTCUSTOMER1_L2_1_mapkey0_idxfn {
    FORCE_INLINE static size_t hash(const COUNTCUSTOMER1_L2_1_entry& e) {
      size_t h = 0;
      hash_combine(h, e.STORE_SALES_SS_ADDR_SK);
      return h;
    }
    FORCE_INLINE static bool equals(const COUNTCUSTOMER1_L2_1_entry& x, const COUNTCUSTOMER1_L2_1_entry& y) {
      return x.STORE_SALES_SS_ADDR_SK == y.STORE_SALES_SS_ADDR_SK;
    }
  };
  
  typedef MultiHashMap<COUNTCUSTOMER1_L2_1_entry,long,
    HashIndex<COUNTCUSTOMER1_L2_1_entry,long,COUNTCUSTOMER1_L2_1_mapkey01_idxfn,true>,
    HashIndex<COUNTCUSTOMER1_L2_1_entry,long,COUNTCUSTOMER1_L2_1_mapkey0_idxfn,false>
  > COUNTCUSTOMER1_L2_1_map;
  typedef HashIndex<COUNTCUSTOMER1_L2_1_entry,long,COUNTCUSTOMER1_L2_1_mapkey01_idxfn,true> HashIndex_COUNTCUSTOMER1_L2_1_map_01;
  typedef HashIndex<COUNTCUSTOMER1_L2_1_entry,long,COUNTCUSTOMER1_L2_1_mapkey0_idxfn,false> HashIndex_COUNTCUSTOMER1_L2_1_map_0;
  
  struct COUNTCUSTOMER1_L2_2_entry {
    long COUNTCUSTOMERCUSTOMER_C_CUSTOMER_SK; long STORE_SALES_SS_ADDR_SK; long DN_SS_TICKET_NUMBER; DOUBLE_TYPE __av; 
    explicit COUNTCUSTOMER1_L2_2_entry() { /*COUNTCUSTOMERCUSTOMER_C_CUSTOMER_SK = 0L; STORE_SALES_SS_ADDR_SK = 0L; DN_SS_TICKET_NUMBER = 0L; __av = 0.0; */ }
    explicit COUNTCUSTOMER1_L2_2_entry(const long c0, const long c1, const long c2, const DOUBLE_TYPE c3) { COUNTCUSTOMERCUSTOMER_C_CUSTOMER_SK = c0; STORE_SALES_SS_ADDR_SK = c1; DN_SS_TICKET_NUMBER = c2; __av = c3; }
    COUNTCUSTOMER1_L2_2_entry(const COUNTCUSTOMER1_L2_2_entry& other) : COUNTCUSTOMERCUSTOMER_C_CUSTOMER_SK( other.COUNTCUSTOMERCUSTOMER_C_CUSTOMER_SK ), STORE_SALES_SS_ADDR_SK( other.STORE_SALES_SS_ADDR_SK ), DN_SS_TICKET_NUMBER( other.DN_SS_TICKET_NUMBER ), __av( other.__av ) {}
    FORCE_INLINE COUNTCUSTOMER1_L2_2_entry& modify(const long c0, const long c1, const long c2) { COUNTCUSTOMERCUSTOMER_C_CUSTOMER_SK = c0; STORE_SALES_SS_ADDR_SK = c1; DN_SS_TICKET_NUMBER = c2;  return *this; }
    template<class Archive>
    void serialize(Archive& ar, const unsigned int version) const 
    {
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, COUNTCUSTOMERCUSTOMER_C_CUSTOMER_SK);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, STORE_SALES_SS_ADDR_SK);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, DN_SS_TICKET_NUMBER);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, __av);
    }
  };
  struct COUNTCUSTOMER1_L2_2_mapkey012_idxfn {
    FORCE_INLINE static size_t hash(const COUNTCUSTOMER1_L2_2_entry& e) {
      size_t h = 0;
      hash_combine(h, e.COUNTCUSTOMERCUSTOMER_C_CUSTOMER_SK);
      hash_combine(h, e.STORE_SALES_SS_ADDR_SK);
      hash_combine(h, e.DN_SS_TICKET_NUMBER);
      return h;
    }
    FORCE_INLINE static bool equals(const COUNTCUSTOMER1_L2_2_entry& x, const COUNTCUSTOMER1_L2_2_entry& y) {
      return x.COUNTCUSTOMERCUSTOMER_C_CUSTOMER_SK == y.COUNTCUSTOMERCUSTOMER_C_CUSTOMER_SK && x.STORE_SALES_SS_ADDR_SK == y.STORE_SALES_SS_ADDR_SK && x.DN_SS_TICKET_NUMBER == y.DN_SS_TICKET_NUMBER;
    }
  };
  
  typedef MultiHashMap<COUNTCUSTOMER1_L2_2_entry,DOUBLE_TYPE,
    HashIndex<COUNTCUSTOMER1_L2_2_entry,DOUBLE_TYPE,COUNTCUSTOMER1_L2_2_mapkey012_idxfn,true>
  > COUNTCUSTOMER1_L2_2_map;
  typedef HashIndex<COUNTCUSTOMER1_L2_2_entry,DOUBLE_TYPE,COUNTCUSTOMER1_L2_2_mapkey012_idxfn,true> HashIndex_COUNTCUSTOMER1_L2_2_map_012;
  
  struct COUNTCUSTOMER1_L2_2STORE2_entry {
    long COUNTCUSTOMERCUSTOMER_C_CUSTOMER_SK; long STORE_SALES_SS_ADDR_SK; long COUNTCUSTOMER1_L2_2STORESTORE_S_STORE_SK; long DN_SS_TICKET_NUMBER; DOUBLE_TYPE __av; 
    explicit COUNTCUSTOMER1_L2_2STORE2_entry() { /*COUNTCUSTOMERCUSTOMER_C_CUSTOMER_SK = 0L; STORE_SALES_SS_ADDR_SK = 0L; COUNTCUSTOMER1_L2_2STORESTORE_S_STORE_SK = 0L; DN_SS_TICKET_NUMBER = 0L; __av = 0.0; */ }
    explicit COUNTCUSTOMER1_L2_2STORE2_entry(const long c0, const long c1, const long c2, const long c3, const DOUBLE_TYPE c4) { COUNTCUSTOMERCUSTOMER_C_CUSTOMER_SK = c0; STORE_SALES_SS_ADDR_SK = c1; COUNTCUSTOMER1_L2_2STORESTORE_S_STORE_SK = c2; DN_SS_TICKET_NUMBER = c3; __av = c4; }
    COUNTCUSTOMER1_L2_2STORE2_entry(const COUNTCUSTOMER1_L2_2STORE2_entry& other) : COUNTCUSTOMERCUSTOMER_C_CUSTOMER_SK( other.COUNTCUSTOMERCUSTOMER_C_CUSTOMER_SK ), STORE_SALES_SS_ADDR_SK( other.STORE_SALES_SS_ADDR_SK ), COUNTCUSTOMER1_L2_2STORESTORE_S_STORE_SK( other.COUNTCUSTOMER1_L2_2STORESTORE_S_STORE_SK ), DN_SS_TICKET_NUMBER( other.DN_SS_TICKET_NUMBER ), __av( other.__av ) {}
    FORCE_INLINE COUNTCUSTOMER1_L2_2STORE2_entry& modify(const long c0, const long c1, const long c2, const long c3) { COUNTCUSTOMERCUSTOMER_C_CUSTOMER_SK = c0; STORE_SALES_SS_ADDR_SK = c1; COUNTCUSTOMER1_L2_2STORESTORE_S_STORE_SK = c2; DN_SS_TICKET_NUMBER = c3;  return *this; }
    FORCE_INLINE COUNTCUSTOMER1_L2_2STORE2_entry& modify2(const long c2) { COUNTCUSTOMER1_L2_2STORESTORE_S_STORE_SK = c2;  return *this; }
    template<class Archive>
    void serialize(Archive& ar, const unsigned int version) const 
    {
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, COUNTCUSTOMERCUSTOMER_C_CUSTOMER_SK);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, STORE_SALES_SS_ADDR_SK);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, COUNTCUSTOMER1_L2_2STORESTORE_S_STORE_SK);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, DN_SS_TICKET_NUMBER);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, __av);
    }
  };
  struct COUNTCUSTOMER1_L2_2STORE2_mapkey0123_idxfn {
    FORCE_INLINE static size_t hash(const COUNTCUSTOMER1_L2_2STORE2_entry& e) {
      size_t h = 0;
      hash_combine(h, e.COUNTCUSTOMERCUSTOMER_C_CUSTOMER_SK);
      hash_combine(h, e.STORE_SALES_SS_ADDR_SK);
      hash_combine(h, e.COUNTCUSTOMER1_L2_2STORESTORE_S_STORE_SK);
      hash_combine(h, e.DN_SS_TICKET_NUMBER);
      return h;
    }
    FORCE_INLINE static bool equals(const COUNTCUSTOMER1_L2_2STORE2_entry& x, const COUNTCUSTOMER1_L2_2STORE2_entry& y) {
      return x.COUNTCUSTOMERCUSTOMER_C_CUSTOMER_SK == y.COUNTCUSTOMERCUSTOMER_C_CUSTOMER_SK && x.STORE_SALES_SS_ADDR_SK == y.STORE_SALES_SS_ADDR_SK && x.COUNTCUSTOMER1_L2_2STORESTORE_S_STORE_SK == y.COUNTCUSTOMER1_L2_2STORESTORE_S_STORE_SK && x.DN_SS_TICKET_NUMBER == y.DN_SS_TICKET_NUMBER;
    }
  };
  
  struct COUNTCUSTOMER1_L2_2STORE2_mapkey2_idxfn {
    FORCE_INLINE static size_t hash(const COUNTCUSTOMER1_L2_2STORE2_entry& e) {
      size_t h = 0;
      hash_combine(h, e.COUNTCUSTOMER1_L2_2STORESTORE_S_STORE_SK);
      return h;
    }
    FORCE_INLINE static bool equals(const COUNTCUSTOMER1_L2_2STORE2_entry& x, const COUNTCUSTOMER1_L2_2STORE2_entry& y) {
      return x.COUNTCUSTOMER1_L2_2STORESTORE_S_STORE_SK == y.COUNTCUSTOMER1_L2_2STORESTORE_S_STORE_SK;
    }
  };
  
  typedef MultiHashMap<COUNTCUSTOMER1_L2_2STORE2_entry,DOUBLE_TYPE,
    HashIndex<COUNTCUSTOMER1_L2_2STORE2_entry,DOUBLE_TYPE,COUNTCUSTOMER1_L2_2STORE2_mapkey0123_idxfn,true>,
    HashIndex<COUNTCUSTOMER1_L2_2STORE2_entry,DOUBLE_TYPE,COUNTCUSTOMER1_L2_2STORE2_mapkey2_idxfn,false>
  > COUNTCUSTOMER1_L2_2STORE2_map;
  typedef HashIndex<COUNTCUSTOMER1_L2_2STORE2_entry,DOUBLE_TYPE,COUNTCUSTOMER1_L2_2STORE2_mapkey0123_idxfn,true> HashIndex_COUNTCUSTOMER1_L2_2STORE2_map_0123;
  typedef HashIndex<COUNTCUSTOMER1_L2_2STORE2_entry,DOUBLE_TYPE,COUNTCUSTOMER1_L2_2STORE2_mapkey2_idxfn,false> HashIndex_COUNTCUSTOMER1_L2_2STORE2_map_2;
  
  struct COUNTCUSTOMER1_L3_2_entry {
    long COUNTCUSTOMERCUSTOMER_C_CUSTOMER_SK; long STORE_SALES_SS_ADDR_SK; long DN_SS_TICKET_NUMBER; DOUBLE_TYPE __av; 
    explicit COUNTCUSTOMER1_L3_2_entry() { /*COUNTCUSTOMERCUSTOMER_C_CUSTOMER_SK = 0L; STORE_SALES_SS_ADDR_SK = 0L; DN_SS_TICKET_NUMBER = 0L; __av = 0.0; */ }
    explicit COUNTCUSTOMER1_L3_2_entry(const long c0, const long c1, const long c2, const DOUBLE_TYPE c3) { COUNTCUSTOMERCUSTOMER_C_CUSTOMER_SK = c0; STORE_SALES_SS_ADDR_SK = c1; DN_SS_TICKET_NUMBER = c2; __av = c3; }
    COUNTCUSTOMER1_L3_2_entry(const COUNTCUSTOMER1_L3_2_entry& other) : COUNTCUSTOMERCUSTOMER_C_CUSTOMER_SK( other.COUNTCUSTOMERCUSTOMER_C_CUSTOMER_SK ), STORE_SALES_SS_ADDR_SK( other.STORE_SALES_SS_ADDR_SK ), DN_SS_TICKET_NUMBER( other.DN_SS_TICKET_NUMBER ), __av( other.__av ) {}
    FORCE_INLINE COUNTCUSTOMER1_L3_2_entry& modify(const long c0, const long c1, const long c2) { COUNTCUSTOMERCUSTOMER_C_CUSTOMER_SK = c0; STORE_SALES_SS_ADDR_SK = c1; DN_SS_TICKET_NUMBER = c2;  return *this; }
    template<class Archive>
    void serialize(Archive& ar, const unsigned int version) const 
    {
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, COUNTCUSTOMERCUSTOMER_C_CUSTOMER_SK);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, STORE_SALES_SS_ADDR_SK);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, DN_SS_TICKET_NUMBER);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, __av);
    }
  };
  struct COUNTCUSTOMER1_L3_2_mapkey012_idxfn {
    FORCE_INLINE static size_t hash(const COUNTCUSTOMER1_L3_2_entry& e) {
      size_t h = 0;
      hash_combine(h, e.COUNTCUSTOMERCUSTOMER_C_CUSTOMER_SK);
      hash_combine(h, e.STORE_SALES_SS_ADDR_SK);
      hash_combine(h, e.DN_SS_TICKET_NUMBER);
      return h;
    }
    FORCE_INLINE static bool equals(const COUNTCUSTOMER1_L3_2_entry& x, const COUNTCUSTOMER1_L3_2_entry& y) {
      return x.COUNTCUSTOMERCUSTOMER_C_CUSTOMER_SK == y.COUNTCUSTOMERCUSTOMER_C_CUSTOMER_SK && x.STORE_SALES_SS_ADDR_SK == y.STORE_SALES_SS_ADDR_SK && x.DN_SS_TICKET_NUMBER == y.DN_SS_TICKET_NUMBER;
    }
  };
  
  typedef MultiHashMap<COUNTCUSTOMER1_L3_2_entry,DOUBLE_TYPE,
    HashIndex<COUNTCUSTOMER1_L3_2_entry,DOUBLE_TYPE,COUNTCUSTOMER1_L3_2_mapkey012_idxfn,true>
  > COUNTCUSTOMER1_L3_2_map;
  typedef HashIndex<COUNTCUSTOMER1_L3_2_entry,DOUBLE_TYPE,COUNTCUSTOMER1_L3_2_mapkey012_idxfn,true> HashIndex_COUNTCUSTOMER1_L3_2_map_012;
  
  struct COUNTCUSTOMER1_L3_2STORE2_entry {
    long COUNTCUSTOMERCUSTOMER_C_CUSTOMER_SK; long STORE_SALES_SS_ADDR_SK; long COUNTCUSTOMER1_L3_2STORESTORE_S_STORE_SK; long DN_SS_TICKET_NUMBER; DOUBLE_TYPE __av; 
    explicit COUNTCUSTOMER1_L3_2STORE2_entry() { /*COUNTCUSTOMERCUSTOMER_C_CUSTOMER_SK = 0L; STORE_SALES_SS_ADDR_SK = 0L; COUNTCUSTOMER1_L3_2STORESTORE_S_STORE_SK = 0L; DN_SS_TICKET_NUMBER = 0L; __av = 0.0; */ }
    explicit COUNTCUSTOMER1_L3_2STORE2_entry(const long c0, const long c1, const long c2, const long c3, const DOUBLE_TYPE c4) { COUNTCUSTOMERCUSTOMER_C_CUSTOMER_SK = c0; STORE_SALES_SS_ADDR_SK = c1; COUNTCUSTOMER1_L3_2STORESTORE_S_STORE_SK = c2; DN_SS_TICKET_NUMBER = c3; __av = c4; }
    COUNTCUSTOMER1_L3_2STORE2_entry(const COUNTCUSTOMER1_L3_2STORE2_entry& other) : COUNTCUSTOMERCUSTOMER_C_CUSTOMER_SK( other.COUNTCUSTOMERCUSTOMER_C_CUSTOMER_SK ), STORE_SALES_SS_ADDR_SK( other.STORE_SALES_SS_ADDR_SK ), COUNTCUSTOMER1_L3_2STORESTORE_S_STORE_SK( other.COUNTCUSTOMER1_L3_2STORESTORE_S_STORE_SK ), DN_SS_TICKET_NUMBER( other.DN_SS_TICKET_NUMBER ), __av( other.__av ) {}
    FORCE_INLINE COUNTCUSTOMER1_L3_2STORE2_entry& modify(const long c0, const long c1, const long c2, const long c3) { COUNTCUSTOMERCUSTOMER_C_CUSTOMER_SK = c0; STORE_SALES_SS_ADDR_SK = c1; COUNTCUSTOMER1_L3_2STORESTORE_S_STORE_SK = c2; DN_SS_TICKET_NUMBER = c3;  return *this; }
    FORCE_INLINE COUNTCUSTOMER1_L3_2STORE2_entry& modify2(const long c2) { COUNTCUSTOMER1_L3_2STORESTORE_S_STORE_SK = c2;  return *this; }
    template<class Archive>
    void serialize(Archive& ar, const unsigned int version) const 
    {
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, COUNTCUSTOMERCUSTOMER_C_CUSTOMER_SK);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, STORE_SALES_SS_ADDR_SK);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, COUNTCUSTOMER1_L3_2STORESTORE_S_STORE_SK);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, DN_SS_TICKET_NUMBER);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, __av);
    }
  };
  struct COUNTCUSTOMER1_L3_2STORE2_mapkey0123_idxfn {
    FORCE_INLINE static size_t hash(const COUNTCUSTOMER1_L3_2STORE2_entry& e) {
      size_t h = 0;
      hash_combine(h, e.COUNTCUSTOMERCUSTOMER_C_CUSTOMER_SK);
      hash_combine(h, e.STORE_SALES_SS_ADDR_SK);
      hash_combine(h, e.COUNTCUSTOMER1_L3_2STORESTORE_S_STORE_SK);
      hash_combine(h, e.DN_SS_TICKET_NUMBER);
      return h;
    }
    FORCE_INLINE static bool equals(const COUNTCUSTOMER1_L3_2STORE2_entry& x, const COUNTCUSTOMER1_L3_2STORE2_entry& y) {
      return x.COUNTCUSTOMERCUSTOMER_C_CUSTOMER_SK == y.COUNTCUSTOMERCUSTOMER_C_CUSTOMER_SK && x.STORE_SALES_SS_ADDR_SK == y.STORE_SALES_SS_ADDR_SK && x.COUNTCUSTOMER1_L3_2STORESTORE_S_STORE_SK == y.COUNTCUSTOMER1_L3_2STORESTORE_S_STORE_SK && x.DN_SS_TICKET_NUMBER == y.DN_SS_TICKET_NUMBER;
    }
  };
  
  struct COUNTCUSTOMER1_L3_2STORE2_mapkey2_idxfn {
    FORCE_INLINE static size_t hash(const COUNTCUSTOMER1_L3_2STORE2_entry& e) {
      size_t h = 0;
      hash_combine(h, e.COUNTCUSTOMER1_L3_2STORESTORE_S_STORE_SK);
      return h;
    }
    FORCE_INLINE static bool equals(const COUNTCUSTOMER1_L3_2STORE2_entry& x, const COUNTCUSTOMER1_L3_2STORE2_entry& y) {
      return x.COUNTCUSTOMER1_L3_2STORESTORE_S_STORE_SK == y.COUNTCUSTOMER1_L3_2STORESTORE_S_STORE_SK;
    }
  };
  
  typedef MultiHashMap<COUNTCUSTOMER1_L3_2STORE2_entry,DOUBLE_TYPE,
    HashIndex<COUNTCUSTOMER1_L3_2STORE2_entry,DOUBLE_TYPE,COUNTCUSTOMER1_L3_2STORE2_mapkey0123_idxfn,true>,
    HashIndex<COUNTCUSTOMER1_L3_2STORE2_entry,DOUBLE_TYPE,COUNTCUSTOMER1_L3_2STORE2_mapkey2_idxfn,false>
  > COUNTCUSTOMER1_L3_2STORE2_map;
  typedef HashIndex<COUNTCUSTOMER1_L3_2STORE2_entry,DOUBLE_TYPE,COUNTCUSTOMER1_L3_2STORE2_mapkey0123_idxfn,true> HashIndex_COUNTCUSTOMER1_L3_2STORE2_map_0123;
  typedef HashIndex<COUNTCUSTOMER1_L3_2STORE2_entry,DOUBLE_TYPE,COUNTCUSTOMER1_L3_2STORE2_mapkey2_idxfn,false> HashIndex_COUNTCUSTOMER1_L3_2STORE2_map_2;
  
  struct tuple7_LDDSSS_L {
    long _1; DOUBLE_TYPE _2; DOUBLE_TYPE _3; STRING_TYPE _4; STRING_TYPE _5; STRING_TYPE _6; long __av;
    explicit tuple7_LDDSSS_L() { }
    explicit tuple7_LDDSSS_L(const long c1, const DOUBLE_TYPE c2, const DOUBLE_TYPE c3, const STRING_TYPE& c4, const STRING_TYPE& c5, const STRING_TYPE& c6, long c__av=0L) { _1 = c1; _2 = c2; _3 = c3; _4 = c4; _5 = c5; _6 = c6; __av = c__av;}
    int operator==(const tuple7_LDDSSS_L &rhs) const { return ((this->_1==rhs._1) && (this->_2==rhs._2) && (this->_3==rhs._3) && (this->_4==rhs._4) && (this->_5==rhs._5) && (this->_6==rhs._6)); }
    FORCE_INLINE tuple7_LDDSSS_L& modify(const long c0, const DOUBLE_TYPE c1, const DOUBLE_TYPE c2, const STRING_TYPE& c3, const STRING_TYPE& c4, const STRING_TYPE& c5, long c__av) { _1 = c0; _2 = c1; _3 = c2; _4 = c3; _5 = c4; _6 = c5; __av = c__av; return *this; }
    static bool equals(const tuple7_LDDSSS_L &x, const tuple7_LDDSSS_L &y) { return ((x._1==y._1) && (x._2==y._2) && (x._3==y._3) && (x._4==y._4) && (x._5==y._5) && (x._6==y._6)); }
    static long hash(const tuple7_LDDSSS_L &e) {
      size_t h = 0;
      hash_combine(h, e._1);
      hash_combine(h, e._2);
      hash_combine(h, e._3);
      hash_combine(h, e._4);
      hash_combine(h, e._5);
      hash_combine(h, e._6);
      return h;
    }
  };
  struct tuple7_SSLSDD_L {
    STRING_TYPE _1; STRING_TYPE _2; long _3; STRING_TYPE _4; DOUBLE_TYPE _5; DOUBLE_TYPE _6; long __av;
    explicit tuple7_SSLSDD_L() { }
    explicit tuple7_SSLSDD_L(const STRING_TYPE& c1, const STRING_TYPE& c2, const long c3, const STRING_TYPE& c4, const DOUBLE_TYPE c5, const DOUBLE_TYPE c6, long c__av=0L) { _1 = c1; _2 = c2; _3 = c3; _4 = c4; _5 = c5; _6 = c6; __av = c__av;}
    int operator==(const tuple7_SSLSDD_L &rhs) const { return ((this->_1==rhs._1) && (this->_2==rhs._2) && (this->_3==rhs._3) && (this->_4==rhs._4) && (this->_5==rhs._5) && (this->_6==rhs._6)); }
    FORCE_INLINE tuple7_SSLSDD_L& modify(const STRING_TYPE& c0, const STRING_TYPE& c1, const long c2, const STRING_TYPE& c3, const DOUBLE_TYPE c4, const DOUBLE_TYPE c5, long c__av) { _1 = c0; _2 = c1; _3 = c2; _4 = c3; _5 = c4; _6 = c5; __av = c__av; return *this; }
    static bool equals(const tuple7_SSLSDD_L &x, const tuple7_SSLSDD_L &y) { return ((x._1==y._1) && (x._2==y._2) && (x._3==y._3) && (x._4==y._4) && (x._5==y._5) && (x._6==y._6)); }
    static long hash(const tuple7_SSLSDD_L &e) {
      size_t h = 0;
      hash_combine(h, e._1);
      hash_combine(h, e._2);
      hash_combine(h, e._3);
      hash_combine(h, e._4);
      hash_combine(h, e._5);
      hash_combine(h, e._6);
      return h;
    }
  };
  struct tuple4_SDD_L {
    STRING_TYPE _1; DOUBLE_TYPE _2; DOUBLE_TYPE _3; long __av;
    explicit tuple4_SDD_L() { }
    explicit tuple4_SDD_L(const STRING_TYPE& c1, const DOUBLE_TYPE c2, const DOUBLE_TYPE c3, long c__av=0L) { _1 = c1; _2 = c2; _3 = c3; __av = c__av;}
    int operator==(const tuple4_SDD_L &rhs) const { return ((this->_1==rhs._1) && (this->_2==rhs._2) && (this->_3==rhs._3)); }
    FORCE_INLINE tuple4_SDD_L& modify(const STRING_TYPE& c0, const DOUBLE_TYPE c1, const DOUBLE_TYPE c2, long c__av) { _1 = c0; _2 = c1; _3 = c2; __av = c__av; return *this; }
    static bool equals(const tuple4_SDD_L &x, const tuple4_SDD_L &y) { return ((x._1==y._1) && (x._2==y._2) && (x._3==y._3)); }
    static long hash(const tuple4_SDD_L &e) {
      size_t h = 0;
      hash_combine(h, e._1);
      hash_combine(h, e._2);
      hash_combine(h, e._3);
      return h;
    }
  };
  struct tuple5_LSDD_L {
    long _1; STRING_TYPE _2; DOUBLE_TYPE _3; DOUBLE_TYPE _4; long __av;
    explicit tuple5_LSDD_L() { }
    explicit tuple5_LSDD_L(const long c1, const STRING_TYPE& c2, const DOUBLE_TYPE c3, const DOUBLE_TYPE c4, long c__av=0L) { _1 = c1; _2 = c2; _3 = c3; _4 = c4; __av = c__av;}
    int operator==(const tuple5_LSDD_L &rhs) const { return ((this->_1==rhs._1) && (this->_2==rhs._2) && (this->_3==rhs._3) && (this->_4==rhs._4)); }
    FORCE_INLINE tuple5_LSDD_L& modify(const long c0, const STRING_TYPE& c1, const DOUBLE_TYPE c2, const DOUBLE_TYPE c3, long c__av) { _1 = c0; _2 = c1; _3 = c2; _4 = c3; __av = c__av; return *this; }
    static bool equals(const tuple5_LSDD_L &x, const tuple5_LSDD_L &y) { return ((x._1==y._1) && (x._2==y._2) && (x._3==y._3) && (x._4==y._4)); }
    static long hash(const tuple5_LSDD_L &e) {
      size_t h = 0;
      hash_combine(h, e._1);
      hash_combine(h, e._2);
      hash_combine(h, e._3);
      hash_combine(h, e._4);
      return h;
    }
  };
  
  /* Type definition providing a way to access the results of the sql program */
  struct tlq_t{
    struct timeval t0,t; long tT,tN,tS;
    tlq_t(): tN(0), tS(0) { gettimeofday(&t0,NULL); }
  
  /* Serialization Code */
    template<class Archive>
    void serialize(Archive& ar, const unsigned int version) const {
  
      ar << "\n";
      const COUNT_map& _COUNT = get_COUNT();
      dbtoaster::serialize_nvp_tabbed(ar, STRING_TYPE(COUNT), _COUNT, "\t");
  
    }
  
    /* Functions returning / computing the results of top level queries */
    const COUNT_map& get_COUNT() const {
      return COUNT;
    
    }
  
  protected:
  
    /* Data structures used for storing / computing top level queries */
    COUNT_map COUNT;
  
  };
  
  /* Type definition providing a way to incrementally maintain the results of the sql program */
  struct data_t : tlq_t{
    data_t(): tlq_t(), _c1(16U), agg2(16U), _c2(16U), agg1(16U) {
      c1 = STRING_TYPE("Oakland");
      c4 = STRING_TYPE("Salem");
      c2 = STRING_TYPE("Riverside");
      c3 = STRING_TYPE("Union");
      c5 = STRING_TYPE("Greenwood");
    }
  
  
    /* Trigger functions for table relations */
    void on_insert_DATE_DIM(const long date_dim_d_date_sk, const STRING_TYPE date_dim_d_date_id, const date date_dim_d_date, const long date_dim_d_month_seq, const long date_dim_d_week_seq, const long date_dim_d_quarter_seq, const long date_dim_d_year, const long date_dim_d_dow, const long date_dim_d_moy, const long date_dim_d_dom, const long date_dim_d_qoy, const long date_dim_d_fy_year, const long date_dim_d_fy_quarter_seq, const long date_dim_d_fy_week_seq, const STRING_TYPE date_dim_d_day_name, const STRING_TYPE date_dim_d_quarter_name, const STRING_TYPE date_dim_d_holiday, const STRING_TYPE date_dim_d_weekend, const STRING_TYPE date_dim_d_following_holiday, const long date_dim_d_first_dom, const long date_dim_d_last_dom, const long date_dim_d_same_day_ly, const long date_dim_d_same_day_lq, const STRING_TYPE date_dim_d_current_day, const STRING_TYPE date_dim_d_current_week, const STRING_TYPE date_dim_d_current_month, const STRING_TYPE date_dim_d_current_quarter, const STRING_TYPE date_dim_d_current_year) {
      DATE_DIM_entry e(date_dim_d_date_sk, date_dim_d_date_id, date_dim_d_date, date_dim_d_month_seq, date_dim_d_week_seq, date_dim_d_quarter_seq, date_dim_d_year, date_dim_d_dow, date_dim_d_moy, date_dim_d_dom, date_dim_d_qoy, date_dim_d_fy_year, date_dim_d_fy_quarter_seq, date_dim_d_fy_week_seq, date_dim_d_day_name, date_dim_d_quarter_name, date_dim_d_holiday, date_dim_d_weekend, date_dim_d_following_holiday, date_dim_d_first_dom, date_dim_d_last_dom, date_dim_d_same_day_ly, date_dim_d_same_day_lq, date_dim_d_current_day, date_dim_d_current_week, date_dim_d_current_month, date_dim_d_current_quarter, date_dim_d_current_year, 1L);
      DATE_DIM.addOrDelOnZero(e,1L);
    }
    
    void on_insert_HOUSEHOLD_DEMOGRAPHICS(const long household_demographics_hd_demo_sk, const long household_demographics_hd_income_band_sk, const STRING_TYPE household_demographics_hd_buy_potential, const long household_demographics_hd_dep_count, const long household_demographics_hd_vehicle_count) {
      HOUSEHOLD_DEMOGRAPHICS_entry e(household_demographics_hd_demo_sk, household_demographics_hd_income_band_sk, household_demographics_hd_buy_potential, household_demographics_hd_dep_count, household_demographics_hd_vehicle_count, 1L);
      HOUSEHOLD_DEMOGRAPHICS.addOrDelOnZero(e,1L);
    }
    
    
    
    /* Trigger functions for stream relations */
    void on_insert_STORE_SALES(const long store_sales_ss_sold_date_sk, const long store_sales_ss_sold_time_sk, const long store_sales_ss_item_sk, const long store_sales_ss_customer_sk, const long store_sales_ss_cdemo_sk, const long store_sales_ss_hdemo_sk, const long store_sales_ss_addr_sk, const long store_sales_ss_store_sk, const long store_sales_ss_promo_sk, const long store_sales_ss_ticket_number, const long store_sales_ss_quantity, const DOUBLE_TYPE store_sales_ss_wholesale_cost, const DOUBLE_TYPE store_sales_ss_list_price, const DOUBLE_TYPE store_sales_ss_sales_price, const DOUBLE_TYPE store_sales_ss_ext_discount_amt, const DOUBLE_TYPE store_sales_ss_ext_sales_price, const DOUBLE_TYPE store_sales_ss_ext_wholesale_cost, const DOUBLE_TYPE store_sales_ss_ext_list_price, const DOUBLE_TYPE store_sales_ss_ext_tax, const DOUBLE_TYPE store_sales_ss_coupon_amt, const DOUBLE_TYPE store_sales_ss_net_paid, const DOUBLE_TYPE store_sales_ss_net_paid_inc_tax, const DOUBLE_TYPE store_sales_ss_net_profit) {
      {  if (tS>0) { ++tS; return; } if ((tN&127)==0) { gettimeofday(&(t),NULL); tT=((t).tv_sec-(t0).tv_sec)*1000000L+((t).tv_usec-(t0).tv_usec); if (tT>3600000000L) { tS=1; return; } } ++tN;
        _c1.clear();
        { //slice 
          const HashIndex_COUNTCUSTOMER1_L2_1_map_0* i1 = static_cast<HashIndex_COUNTCUSTOMER1_L2_1_map_0*>(COUNTCUSTOMER1_L2_1.index[1]);
          const HASH_RES_t h1 = COUNTCUSTOMER1_L2_1_mapkey0_idxfn::hash(se7.modify0(store_sales_ss_addr_sk));
          HashIndex_COUNTCUSTOMER1_L2_1_map_0::IdxNode* n1 = static_cast<HashIndex_COUNTCUSTOMER1_L2_1_map_0::IdxNode*>(i1->slice(se7, h1));
          COUNTCUSTOMER1_L2_1_entry* e1;
         
          if (n1 && (e1 = n1->obj)) {
            do {                
              STRING_TYPE dn_bought_city = e1->DN_BOUGHT_CITY;
              long v2 = e1->__av;
              DOUBLE_TYPE l1 = (COUNTCUSTOMER1_L2_1.getValueOrDefault(se3.modify(store_sales_ss_addr_sk,dn_bought_city)) * COUNTCUSTOMER1_L3_2.getValueOrDefault(se4.modify(store_sales_ss_customer_sk,store_sales_ss_addr_sk,store_sales_ss_ticket_number)));
              DOUBLE_TYPE l2 = (COUNTCUSTOMER1_L2_1.getValueOrDefault(se5.modify(store_sales_ss_addr_sk,dn_bought_city)) * COUNTCUSTOMER1_L2_2.getValueOrDefault(se6.modify(store_sales_ss_customer_sk,store_sales_ss_addr_sk,store_sales_ss_ticket_number)));
              _c1.addOrDelOnZero(st1.modify(dn_bought_city,l1,l2,(((COUNTCUSTOMER_ADDRESS3_E2_2.getValueOrDefault(se2.modify(store_sales_ss_customer_sk,store_sales_ss_addr_sk,store_sales_ss_ticket_number)) * v2) != 0 ? 1L : 0L) * -1L)), (((COUNTCUSTOMER_ADDRESS3_E2_2.getValueOrDefault(se2.modify(store_sales_ss_customer_sk,store_sales_ss_addr_sk,store_sales_ss_ticket_number)) * v2) != 0 ? 1L : 0L) * -1L));
              n1 = n1->nxt;
            } while (n1 && (e1 = n1->obj) && h1 == n1->hash &&  COUNTCUSTOMER1_L2_1_mapkey0_idxfn::equals(se7, *e1)); 
          }
        }{ //slice 
          const HashIndex_COUNTCUSTOMER1_L2_1_map_0* i2 = static_cast<HashIndex_COUNTCUSTOMER1_L2_1_map_0*>(COUNTCUSTOMER1_L2_1.index[1]);
          const HASH_RES_t h2 = COUNTCUSTOMER1_L2_1_mapkey0_idxfn::hash(se22.modify0(store_sales_ss_addr_sk));
          HashIndex_COUNTCUSTOMER1_L2_1_map_0::IdxNode* n2 = static_cast<HashIndex_COUNTCUSTOMER1_L2_1_map_0::IdxNode*>(i2->slice(se22, h2));
          COUNTCUSTOMER1_L2_1_entry* e2;
         
          if (n2 && (e2 = n2->obj)) {
            do {                
              STRING_TYPE dn_bought_city = e2->DN_BOUGHT_CITY;
              long v3 = e2->__av;
              DOUBLE_TYPE l3 = (COUNTCUSTOMER1_L2_1.getValueOrDefault(se12.modify(store_sales_ss_addr_sk,dn_bought_city)) * (COUNTCUSTOMER1_L2_2.getValueOrDefault(se13.modify(store_sales_ss_customer_sk,store_sales_ss_addr_sk,store_sales_ss_ticket_number)) + (COUNTSTORE_SALES3_E1_4.getValueOrDefault(se14.modify(store_sales_ss_sold_date_sk)) * (COUNTSTORE_SALES3_E1_5.getValueOrDefault(se15.modify(store_sales_ss_store_sk)) * (COUNTSTORE_SALES3_E1_6.getValueOrDefault(se16.modify(store_sales_ss_hdemo_sk)) * store_sales_ss_net_profit)))));
              DOUBLE_TYPE l4 = (COUNTCUSTOMER1_L2_1.getValueOrDefault(se17.modify(store_sales_ss_addr_sk,dn_bought_city)) * (COUNTCUSTOMER1_L3_2.getValueOrDefault(se18.modify(store_sales_ss_customer_sk,store_sales_ss_addr_sk,store_sales_ss_ticket_number)) + (COUNTSTORE_SALES3_E1_4.getValueOrDefault(se19.modify(store_sales_ss_sold_date_sk)) * (COUNTSTORE_SALES3_E1_5.getValueOrDefault(se20.modify(store_sales_ss_store_sk)) * (COUNTSTORE_SALES3_E1_6.getValueOrDefault(se21.modify(store_sales_ss_hdemo_sk)) * store_sales_ss_coupon_amt)))));
              _c1.addOrDelOnZero(st2.modify(dn_bought_city,l4,l3,(((COUNTCUSTOMER_ADDRESS3_E2_2.getValueOrDefault(se8.modify(store_sales_ss_customer_sk,store_sales_ss_addr_sk,store_sales_ss_ticket_number)) + (COUNTSTORE_SALES3_E1_4.getValueOrDefault(se9.modify(store_sales_ss_sold_date_sk)) * (COUNTSTORE_SALES3_E1_5.getValueOrDefault(se10.modify(store_sales_ss_store_sk)) * COUNTSTORE_SALES3_E1_6.getValueOrDefault(se11.modify(store_sales_ss_hdemo_sk))))) * v3) != 0 ? 1L : 0L)), (((COUNTCUSTOMER_ADDRESS3_E2_2.getValueOrDefault(se8.modify(store_sales_ss_customer_sk,store_sales_ss_addr_sk,store_sales_ss_ticket_number)) + (COUNTSTORE_SALES3_E1_4.getValueOrDefault(se9.modify(store_sales_ss_sold_date_sk)) * (COUNTSTORE_SALES3_E1_5.getValueOrDefault(se10.modify(store_sales_ss_store_sk)) * COUNTSTORE_SALES3_E1_6.getValueOrDefault(se11.modify(store_sales_ss_hdemo_sk))))) * v3) != 0 ? 1L : 0L));
              n2 = n2->nxt;
            } while (n2 && (e2 = n2->obj) && h2 == n2->hash &&  COUNTCUSTOMER1_L2_1_mapkey0_idxfn::equals(se22, *e2)); 
          }
        }{  // temp foreach
          const HashIndex<tuple4_SDD_L, long>* i3 = static_cast<HashIndex<tuple4_SDD_L, long>*>(_c1.index[0]);
          HashIndex<tuple4_SDD_L, long>::IdxNode* n3; 
          tuple4_SDD_L* e3;
        
          for (size_t i = 0; i < i3->size_; i++)
          {
            n3 = i3->buckets_ + i;
            while (n3 && (e3 = n3->obj))
            {
              STRING_TYPE dn_bought_city = e3->_1;
              DOUBLE_TYPE dn_amt = e3->_2;
              DOUBLE_TYPE dn_profit = e3->_3;  
              long v4 = e3->__av; 
            { //slice 
              const HashIndex_COUNTCUSTOMER_ADDRESS3_map_1* i4 = static_cast<HashIndex_COUNTCUSTOMER_ADDRESS3_map_1*>(COUNTCUSTOMER_ADDRESS3.index[1]);
              const HASH_RES_t h3 = COUNTCUSTOMER_ADDRESS3_mapkey1_idxfn::hash(se23.modify1(store_sales_ss_customer_sk));
              HashIndex_COUNTCUSTOMER_ADDRESS3_map_1::IdxNode* n4 = static_cast<HashIndex_COUNTCUSTOMER_ADDRESS3_map_1::IdxNode*>(i4->slice(se23, h3));
              COUNTCUSTOMER_ADDRESS3_entry* e4;
             
              if (n4 && (e4 = n4->obj)) {
                do {                
                  STRING_TYPE current_addr_ca_city = e4->CURRENT_ADDR_CA_CITY;
                  STRING_TYPE customer_c_first_name = e4->CUSTOMER_C_FIRST_NAME;
                  STRING_TYPE customer_c_last_name = e4->CUSTOMER_C_LAST_NAME;
                  long v5 = e4->__av;
                  (/*if */(current_addr_ca_city != dn_bought_city) ? COUNT.addOrDelOnZero(se1.modify(customer_c_last_name,customer_c_first_name,current_addr_ca_city,dn_bought_city,store_sales_ss_ticket_number,dn_amt,dn_profit),(v4 * v5)) : (void)0);
                  n4 = n4->nxt;
                } while (n4 && (e4 = n4->obj) && h3 == n4->hash &&  COUNTCUSTOMER_ADDRESS3_mapkey1_idxfn::equals(se23, *e4)); 
              }
            }      
              n3 = n3->nxt;
            }
          }
        }COUNTCUSTOMER_ADDRESS3_E2_2.addOrDelOnZero(se24.modify(store_sales_ss_customer_sk,store_sales_ss_addr_sk,store_sales_ss_ticket_number),(COUNTSTORE_SALES3_E1_4.getValueOrDefault(se25.modify(store_sales_ss_sold_date_sk)) * (COUNTSTORE_SALES3_E1_5.getValueOrDefault(se26.modify(store_sales_ss_store_sk)) * COUNTSTORE_SALES3_E1_6.getValueOrDefault(se27.modify(store_sales_ss_hdemo_sk)))));
        COUNTCUSTOMER_ADDRESS3_E2_2STORE2.addOrDelOnZero(se28.modify(store_sales_ss_customer_sk,store_sales_ss_addr_sk,store_sales_ss_store_sk,store_sales_ss_ticket_number),(COUNTSTORE_SALES3_E1_4.getValueOrDefault(se29.modify(store_sales_ss_sold_date_sk)) * COUNTSTORE_SALES3_E1_6.getValueOrDefault(se30.modify(store_sales_ss_hdemo_sk))));
        { //slice 
          const HashIndex_COUNTCUSTOMER1_L2_1_map_0* i5 = static_cast<HashIndex_COUNTCUSTOMER1_L2_1_map_0*>(COUNTCUSTOMER1_L2_1.index[1]);
          const HASH_RES_t h4 = COUNTCUSTOMER1_L2_1_mapkey0_idxfn::hash(se35.modify0(store_sales_ss_addr_sk));
          HashIndex_COUNTCUSTOMER1_L2_1_map_0::IdxNode* n5 = static_cast<HashIndex_COUNTCUSTOMER1_L2_1_map_0::IdxNode*>(i5->slice(se35, h4));
          COUNTCUSTOMER1_L2_1_entry* e5;
         
          if (n5 && (e5 = n5->obj)) {
            do {                
              STRING_TYPE dn_bought_city = e5->DN_BOUGHT_CITY;
              long v6 = e5->__av;
              COUNTCUSTOMER1_E1_1.addOrDelOnZero(se31.modify(store_sales_ss_customer_sk,store_sales_ss_addr_sk,store_sales_ss_ticket_number,dn_bought_city),(COUNTSTORE_SALES3_E1_4.getValueOrDefault(se32.modify(store_sales_ss_sold_date_sk)) * (COUNTSTORE_SALES3_E1_5.getValueOrDefault(se33.modify(store_sales_ss_store_sk)) * (COUNTSTORE_SALES3_E1_6.getValueOrDefault(se34.modify(store_sales_ss_hdemo_sk)) * v6))));
              n5 = n5->nxt;
            } while (n5 && (e5 = n5->obj) && h4 == n5->hash &&  COUNTCUSTOMER1_L2_1_mapkey0_idxfn::equals(se35, *e5)); 
          }
        }{ //slice 
          const HashIndex_COUNTCUSTOMER1_L2_1_map_0* i6 = static_cast<HashIndex_COUNTCUSTOMER1_L2_1_map_0*>(COUNTCUSTOMER1_L2_1.index[1]);
          const HASH_RES_t h5 = COUNTCUSTOMER1_L2_1_mapkey0_idxfn::hash(se39.modify0(store_sales_ss_addr_sk));
          HashIndex_COUNTCUSTOMER1_L2_1_map_0::IdxNode* n6 = static_cast<HashIndex_COUNTCUSTOMER1_L2_1_map_0::IdxNode*>(i6->slice(se39, h5));
          COUNTCUSTOMER1_L2_1_entry* e6;
         
          if (n6 && (e6 = n6->obj)) {
            do {                
              STRING_TYPE dn_bought_city = e6->DN_BOUGHT_CITY;
              long v7 = e6->__av;
              COUNTCUSTOMER1_E1_1STORE2.addOrDelOnZero(se36.modify(store_sales_ss_customer_sk,store_sales_ss_addr_sk,store_sales_ss_store_sk,store_sales_ss_ticket_number,dn_bought_city),(COUNTSTORE_SALES3_E1_4.getValueOrDefault(se37.modify(store_sales_ss_sold_date_sk)) * (COUNTSTORE_SALES3_E1_6.getValueOrDefault(se38.modify(store_sales_ss_hdemo_sk)) * v7)));
              n6 = n6->nxt;
            } while (n6 && (e6 = n6->obj) && h5 == n6->hash &&  COUNTCUSTOMER1_L2_1_mapkey0_idxfn::equals(se39, *e6)); 
          }
        }COUNTCUSTOMER1_L2_2.addOrDelOnZero(se40.modify(store_sales_ss_customer_sk,store_sales_ss_addr_sk,store_sales_ss_ticket_number),(COUNTSTORE_SALES3_E1_4.getValueOrDefault(se41.modify(store_sales_ss_sold_date_sk)) * (COUNTSTORE_SALES3_E1_5.getValueOrDefault(se42.modify(store_sales_ss_store_sk)) * (COUNTSTORE_SALES3_E1_6.getValueOrDefault(se43.modify(store_sales_ss_hdemo_sk)) * store_sales_ss_net_profit))));
        COUNTCUSTOMER1_L2_2STORE2.addOrDelOnZero(se44.modify(store_sales_ss_customer_sk,store_sales_ss_addr_sk,store_sales_ss_store_sk,store_sales_ss_ticket_number),(COUNTSTORE_SALES3_E1_4.getValueOrDefault(se45.modify(store_sales_ss_sold_date_sk)) * (COUNTSTORE_SALES3_E1_6.getValueOrDefault(se46.modify(store_sales_ss_hdemo_sk)) * store_sales_ss_net_profit)));
        COUNTCUSTOMER1_L3_2.addOrDelOnZero(se47.modify(store_sales_ss_customer_sk,store_sales_ss_addr_sk,store_sales_ss_ticket_number),(COUNTSTORE_SALES3_E1_4.getValueOrDefault(se48.modify(store_sales_ss_sold_date_sk)) * (COUNTSTORE_SALES3_E1_5.getValueOrDefault(se49.modify(store_sales_ss_store_sk)) * (COUNTSTORE_SALES3_E1_6.getValueOrDefault(se50.modify(store_sales_ss_hdemo_sk)) * store_sales_ss_coupon_amt))));
        COUNTCUSTOMER1_L3_2STORE2.addOrDelOnZero(se51.modify(store_sales_ss_customer_sk,store_sales_ss_addr_sk,store_sales_ss_store_sk,store_sales_ss_ticket_number),(COUNTSTORE_SALES3_E1_4.getValueOrDefault(se52.modify(store_sales_ss_sold_date_sk)) * (COUNTSTORE_SALES3_E1_6.getValueOrDefault(se53.modify(store_sales_ss_hdemo_sk)) * store_sales_ss_coupon_amt)));
      }
    }
    void on_insert_CUSTOMER(const long customer_c_customer_sk, const STRING_TYPE& customer_c_customer_id, const long customer_c_current_cdemo_sk, const long customer_c_current_hdemo_sk, const long customer_c_current_addr_sk, const long customer_c_first_shipto_date_sk, const long customer_c_first_sales_date_sk, const STRING_TYPE& customer_c_salutation, const STRING_TYPE& customer_c_first_name, const STRING_TYPE& customer_c_last_name, const STRING_TYPE& customer_c_preferred_cust_flag, const long customer_c_birth_day, const long customer_c_birth_month, const long customer_c_birth_year, const STRING_TYPE& customer_c_birth_country, const STRING_TYPE& customer_c_login, const STRING_TYPE& customer_c_email_address, const STRING_TYPE& customer_c_last_review_date) {
      {  if (tS>0) { ++tS; return; } if ((tN&127)==0) { gettimeofday(&(t),NULL); tT=((t).tv_sec-(t0).tv_sec)*1000000L+((t).tv_usec-(t0).tv_usec); if (tT>3600000000L) { tS=1; return; } } ++tN;
        { //slice 
          const HashIndex_COUNTCUSTOMER1_map_0* i7 = static_cast<HashIndex_COUNTCUSTOMER1_map_0*>(COUNTCUSTOMER1.index[1]);
          const HASH_RES_t h7 = COUNTCUSTOMER1_mapkey0_idxfn::hash(se60.modify0(customer_c_current_addr_sk));
          HashIndex_COUNTCUSTOMER1_map_0::IdxNode* n7 = static_cast<HashIndex_COUNTCUSTOMER1_map_0::IdxNode*>(i7->slice(se60, h7));
          COUNTCUSTOMER1_entry* e7;
         
          if (n7 && (e7 = n7->obj)) {
            do {                
              STRING_TYPE current_addr_ca_city = e7->CURRENT_ADDR_CA_CITY;
              long v8 = e7->__av;
              agg1.clear();
              
              { //slice 
                const HashIndex_COUNTCUSTOMER1_E1_1_map_0* i8 = static_cast<HashIndex_COUNTCUSTOMER1_E1_1_map_0*>(COUNTCUSTOMER1_E1_1.index[1]);
                const HASH_RES_t h6 = COUNTCUSTOMER1_E1_1_mapkey0_idxfn::hash(se59.modify0(customer_c_customer_sk));
                HashIndex_COUNTCUSTOMER1_E1_1_map_0::IdxNode* n8 = static_cast<HashIndex_COUNTCUSTOMER1_E1_1_map_0::IdxNode*>(i8->slice(se59, h6));
                COUNTCUSTOMER1_E1_1_entry* e8;
               
                if (n8 && (e8 = n8->obj)) {
                  do {                
                    long store_sales_ss_addr_sk = e8->STORE_SALES_SS_ADDR_SK;
                    long dn_ss_ticket_number = e8->DN_SS_TICKET_NUMBER;
                    STRING_TYPE dn_bought_city = e8->DN_BOUGHT_CITY;
                    long v9 = e8->__av;
                    DOUBLE_TYPE l5 = (COUNTCUSTOMER1_L2_1.getValueOrDefault(se55.modify(store_sales_ss_addr_sk,dn_bought_city)) * COUNTCUSTOMER1_L3_2.getValueOrDefault(se56.modify(customer_c_customer_sk,store_sales_ss_addr_sk,dn_ss_ticket_number)));
                    DOUBLE_TYPE l6 = (COUNTCUSTOMER1_L2_1.getValueOrDefault(se57.modify(store_sales_ss_addr_sk,dn_bought_city)) * COUNTCUSTOMER1_L2_2.getValueOrDefault(se58.modify(customer_c_customer_sk,store_sales_ss_addr_sk,dn_ss_ticket_number)));
                    (/*if */(current_addr_ca_city != dn_bought_city) ? agg1.addOrDelOnZero(st3.modify(dn_ss_ticket_number,dn_bought_city,l6,l5,(v9 != 0 ? 1L : 0L)), (v9 != 0 ? 1L : 0L)) : (void)0);
                    n8 = n8->nxt;
                  } while (n8 && (e8 = n8->obj) && h6 == n8->hash &&  COUNTCUSTOMER1_E1_1_mapkey0_idxfn::equals(se59, *e8)); 
                }
              }{  // temp foreach
                const HashIndex<tuple5_LSDD_L, long>* i9 = static_cast<HashIndex<tuple5_LSDD_L, long>*>(agg1.index[0]);
                HashIndex<tuple5_LSDD_L, long>::IdxNode* n9; 
                tuple5_LSDD_L* e9;
              
                for (size_t i = 0; i < i9->size_; i++)
                {
                  n9 = i9->buckets_ + i;
                  while (n9 && (e9 = n9->obj))
                  {
                    long dn_ss_ticket_number = e9->_1;
                    STRING_TYPE dn_bought_city = e9->_2;
                    DOUBLE_TYPE dn_profit = e9->_3;
                    DOUBLE_TYPE dn_amt = e9->_4;  
                    long v10 = e9->__av; 
                  COUNT.addOrDelOnZero(se54.modify(customer_c_last_name,customer_c_first_name,current_addr_ca_city,dn_bought_city,dn_ss_ticket_number,dn_amt,dn_profit),(v8 * v10));      
                    n9 = n9->nxt;
                  }
                }
              }
              n7 = n7->nxt;
            } while (n7 && (e7 = n7->obj) && h7 == n7->hash &&  COUNTCUSTOMER1_mapkey0_idxfn::equals(se60, *e7)); 
          }
        }COUNTCUSTOMER_ADDRESS2.addOrDelOnZero(se61.modify(customer_c_customer_sk,customer_c_current_addr_sk,customer_c_first_name,customer_c_last_name),1L);
        { //slice 
          const HashIndex_COUNTCUSTOMER1_map_0* i10 = static_cast<HashIndex_COUNTCUSTOMER1_map_0*>(COUNTCUSTOMER1.index[1]);
          const HASH_RES_t h8 = COUNTCUSTOMER1_mapkey0_idxfn::hash(se63.modify0(customer_c_current_addr_sk));
          HashIndex_COUNTCUSTOMER1_map_0::IdxNode* n10 = static_cast<HashIndex_COUNTCUSTOMER1_map_0::IdxNode*>(i10->slice(se63, h8));
          COUNTCUSTOMER1_entry* e10;
         
          if (n10 && (e10 = n10->obj)) {
            do {                
              STRING_TYPE current_addr_ca_city = e10->CURRENT_ADDR_CA_CITY;
              long v11 = e10->__av;
              COUNTCUSTOMER_ADDRESS3.addOrDelOnZero(se62.modify(current_addr_ca_city,customer_c_customer_sk,customer_c_first_name,customer_c_last_name),v11);
              n10 = n10->nxt;
            } while (n10 && (e10 = n10->obj) && h8 == n10->hash &&  COUNTCUSTOMER1_mapkey0_idxfn::equals(se63, *e10)); 
          }
        }
      }
    }
    void on_insert_CUSTOMER_ADDRESS(const long customer_address_ca_address_sk, const STRING_TYPE& customer_address_ca_address_id, const STRING_TYPE& customer_address_ca_street_number, const STRING_TYPE& customer_address_ca_street_name, const STRING_TYPE& customer_address_ca_street_type, const STRING_TYPE& customer_address_ca_suite_number, const STRING_TYPE& customer_address_ca_city, const STRING_TYPE& customer_address_ca_county, const STRING_TYPE& customer_address_ca_state, const STRING_TYPE& customer_address_ca_zip, const STRING_TYPE& customer_address_ca_country, const DOUBLE_TYPE customer_address_ca_gmt_offset, const STRING_TYPE& customer_address_ca_location_type) {
      {  if (tS>0) { ++tS; return; } if ((tN&127)==0) { gettimeofday(&(t),NULL); tT=((t).tv_sec-(t0).tv_sec)*1000000L+((t).tv_usec-(t0).tv_usec); if (tT>3600000000L) { tS=1; return; } } ++tN;
        agg2.clear();
        
        { //slice 
          const HashIndex_COUNTCUSTOMER_ADDRESS2_map_1* i11 = static_cast<HashIndex_COUNTCUSTOMER_ADDRESS2_map_1*>(COUNTCUSTOMER_ADDRESS2.index[1]);
          const HASH_RES_t h10 = COUNTCUSTOMER_ADDRESS2_mapkey1_idxfn::hash(se70.modify1(customer_address_ca_address_sk));
          HashIndex_COUNTCUSTOMER_ADDRESS2_map_1::IdxNode* n11 = static_cast<HashIndex_COUNTCUSTOMER_ADDRESS2_map_1::IdxNode*>(i11->slice(se70, h10));
          COUNTCUSTOMER_ADDRESS2_entry* e11;
         
          if (n11 && (e11 = n11->obj)) {
            do {                
              long customer_c_customer_sk = e11->CUSTOMER_C_CUSTOMER_SK;
              STRING_TYPE customer_c_first_name = e11->CUSTOMER_C_FIRST_NAME;
              STRING_TYPE customer_c_last_name = e11->CUSTOMER_C_LAST_NAME;
              long v12 = e11->__av;
              { //slice 
                const HashIndex_COUNTCUSTOMER1_E1_1_map_0* i12 = static_cast<HashIndex_COUNTCUSTOMER1_E1_1_map_0*>(COUNTCUSTOMER1_E1_1.index[1]);
                const HASH_RES_t h9 = COUNTCUSTOMER1_E1_1_mapkey0_idxfn::hash(se69.modify0(customer_c_customer_sk));
                HashIndex_COUNTCUSTOMER1_E1_1_map_0::IdxNode* n12 = static_cast<HashIndex_COUNTCUSTOMER1_E1_1_map_0::IdxNode*>(i12->slice(se69, h9));
                COUNTCUSTOMER1_E1_1_entry* e12;
               
                if (n12 && (e12 = n12->obj)) {
                  do {                
                    long store_sales_ss_addr_sk = e12->STORE_SALES_SS_ADDR_SK;
                    long dn_ss_ticket_number = e12->DN_SS_TICKET_NUMBER;
                    STRING_TYPE dn_bought_city = e12->DN_BOUGHT_CITY;
                    long v13 = e12->__av;
                    DOUBLE_TYPE l7 = (COUNTCUSTOMER1_L3_2.getValueOrDefault(se65.modify(customer_c_customer_sk,store_sales_ss_addr_sk,dn_ss_ticket_number)) * COUNTCUSTOMER1_L2_1.getValueOrDefault(se66.modify(store_sales_ss_addr_sk,dn_bought_city)));
                    DOUBLE_TYPE l8 = (COUNTCUSTOMER1_L2_2.getValueOrDefault(se67.modify(customer_c_customer_sk,store_sales_ss_addr_sk,dn_ss_ticket_number)) * COUNTCUSTOMER1_L2_1.getValueOrDefault(se68.modify(store_sales_ss_addr_sk,dn_bought_city)));
                    (/*if */(customer_address_ca_city != dn_bought_city) ? agg2.addOrDelOnZero(st4.modify(customer_c_first_name,customer_c_last_name,dn_ss_ticket_number,dn_bought_city,l8,l7,(v12 * (v13 != 0 ? 1L : 0L))), (v12 * (v13 != 0 ? 1L : 0L))) : (void)0);
                    n12 = n12->nxt;
                  } while (n12 && (e12 = n12->obj) && h9 == n12->hash &&  COUNTCUSTOMER1_E1_1_mapkey0_idxfn::equals(se69, *e12)); 
                }
              }
              n11 = n11->nxt;
            } while (n11 && (e11 = n11->obj) && h10 == n11->hash &&  COUNTCUSTOMER_ADDRESS2_mapkey1_idxfn::equals(se70, *e11)); 
          }
        }{  // temp foreach
          const HashIndex<tuple7_SSLSDD_L, long>* i13 = static_cast<HashIndex<tuple7_SSLSDD_L, long>*>(agg2.index[0]);
          HashIndex<tuple7_SSLSDD_L, long>::IdxNode* n13; 
          tuple7_SSLSDD_L* e13;
        
          for (size_t i = 0; i < i13->size_; i++)
          {
            n13 = i13->buckets_ + i;
            while (n13 && (e13 = n13->obj))
            {
              STRING_TYPE customer_c_first_name = e13->_1;
              STRING_TYPE customer_c_last_name = e13->_2;
              long dn_ss_ticket_number = e13->_3;
              STRING_TYPE dn_bought_city = e13->_4;
              DOUBLE_TYPE dn_profit = e13->_5;
              DOUBLE_TYPE dn_amt = e13->_6;  
              long v14 = e13->__av; 
            COUNT.addOrDelOnZero(se64.modify(customer_c_last_name,customer_c_first_name,customer_address_ca_city,dn_bought_city,dn_ss_ticket_number,dn_amt,dn_profit),v14);      
              n13 = n13->nxt;
            }
          }
        }_c2.clear();
        { //slice 
          const HashIndex_COUNTCUSTOMER_ADDRESS3_E2_2_map_1* i14 = static_cast<HashIndex_COUNTCUSTOMER_ADDRESS3_E2_2_map_1*>(COUNTCUSTOMER_ADDRESS3_E2_2.index[1]);
          const HASH_RES_t h12 = COUNTCUSTOMER_ADDRESS3_E2_2_mapkey1_idxfn::hash(se77.modify1(customer_address_ca_address_sk));
          HashIndex_COUNTCUSTOMER_ADDRESS3_E2_2_map_1::IdxNode* n14 = static_cast<HashIndex_COUNTCUSTOMER_ADDRESS3_E2_2_map_1::IdxNode*>(i14->slice(se77, h12));
          COUNTCUSTOMER_ADDRESS3_E2_2_entry* e14;
         
          if (n14 && (e14 = n14->obj)) {
            do {                
              long customer_c_customer_sk = e14->CUSTOMER_C_CUSTOMER_SK;
              long dn_ss_ticket_number = e14->DN_SS_TICKET_NUMBER;
              long v16 = e14->__av;
              DOUBLE_TYPE l9 = (COUNTCUSTOMER1_L3_2.getValueOrDefault(se72.modify(customer_c_customer_sk,customer_address_ca_address_sk,dn_ss_ticket_number)) * COUNTCUSTOMER1_L2_1.getValueOrDefault(se73.modify(customer_address_ca_address_sk,customer_address_ca_city)));
              DOUBLE_TYPE l10 = (COUNTCUSTOMER1_L2_2.getValueOrDefault(se74.modify(customer_c_customer_sk,customer_address_ca_address_sk,dn_ss_ticket_number)) * COUNTCUSTOMER1_L2_1.getValueOrDefault(se75.modify(customer_address_ca_address_sk,customer_address_ca_city)));
              { //slice 
                const HashIndex_COUNTCUSTOMER_ADDRESS3_map_1* i15 = static_cast<HashIndex_COUNTCUSTOMER_ADDRESS3_map_1*>(COUNTCUSTOMER_ADDRESS3.index[1]);
                const HASH_RES_t h11 = COUNTCUSTOMER_ADDRESS3_mapkey1_idxfn::hash(se76.modify1(customer_c_customer_sk));
                HashIndex_COUNTCUSTOMER_ADDRESS3_map_1::IdxNode* n15 = static_cast<HashIndex_COUNTCUSTOMER_ADDRESS3_map_1::IdxNode*>(i15->slice(se76, h11));
                COUNTCUSTOMER_ADDRESS3_entry* e15;
               
                if (n15 && (e15 = n15->obj)) {
                  do {                
                    STRING_TYPE current_addr_ca_city = e15->CURRENT_ADDR_CA_CITY;
                    STRING_TYPE customer_c_first_name = e15->CUSTOMER_C_FIRST_NAME;
                    STRING_TYPE customer_c_last_name = e15->CUSTOMER_C_LAST_NAME;
                    long v17 = e15->__av;
                    (/*if */(current_addr_ca_city != customer_address_ca_city) ? _c2.addOrDelOnZero(st5.modify(dn_ss_ticket_number,l10,l9,current_addr_ca_city,customer_c_first_name,customer_c_last_name,((((COUNTCUSTOMER1_L2_1.getValueOrDefault(se71.modify(customer_address_ca_address_sk,customer_address_ca_city)) * v16) != 0 ? 1L : 0L) * v17) * -1L)), ((((COUNTCUSTOMER1_L2_1.getValueOrDefault(se71.modify(customer_address_ca_address_sk,customer_address_ca_city)) * v16) != 0 ? 1L : 0L) * v17) * -1L)) : (void)0);
                    n15 = n15->nxt;
                  } while (n15 && (e15 = n15->obj) && h11 == n15->hash &&  COUNTCUSTOMER_ADDRESS3_mapkey1_idxfn::equals(se76, *e15)); 
                }
              }
              n14 = n14->nxt;
            } while (n14 && (e14 = n14->obj) && h12 == n14->hash &&  COUNTCUSTOMER_ADDRESS3_E2_2_mapkey1_idxfn::equals(se77, *e14)); 
          }
        }{  // foreach
          const HashIndex_COUNTCUSTOMER_ADDRESS3_map_0123* i16 = static_cast<HashIndex_COUNTCUSTOMER_ADDRESS3_map_0123*>(COUNTCUSTOMER_ADDRESS3.index[0]);
          HashIndex_COUNTCUSTOMER_ADDRESS3_map_0123::IdxNode* n16; 
          COUNTCUSTOMER_ADDRESS3_entry* e16;
        
          for (size_t i = 0; i < i16->size_; i++)
          {
            n16 = i16->buckets_ + i;
            while (n16 && (e16 = n16->obj))
            {
                STRING_TYPE current_addr_ca_city = e16->CURRENT_ADDR_CA_CITY;
                long customer_c_customer_sk = e16->CUSTOMER_C_CUSTOMER_SK;
                STRING_TYPE customer_c_first_name = e16->CUSTOMER_C_FIRST_NAME;
                STRING_TYPE customer_c_last_name = e16->CUSTOMER_C_LAST_NAME;
                long v18 = e16->__av;
                { //slice 
                  const HashIndex_COUNTCUSTOMER_ADDRESS3_E2_2_map_01* i17 = static_cast<HashIndex_COUNTCUSTOMER_ADDRESS3_E2_2_map_01*>(COUNTCUSTOMER_ADDRESS3_E2_2.index[2]);
                  const HASH_RES_t h13 = COUNTCUSTOMER_ADDRESS3_E2_2_mapkey01_idxfn::hash(se83.modify01(customer_c_customer_sk, customer_address_ca_address_sk));
                  HashIndex_COUNTCUSTOMER_ADDRESS3_E2_2_map_01::IdxNode* n17 = static_cast<HashIndex_COUNTCUSTOMER_ADDRESS3_E2_2_map_01::IdxNode*>(i17->slice(se83, h13));
                  COUNTCUSTOMER_ADDRESS3_E2_2_entry* e17;
                 
                  if (n17 && (e17 = n17->obj)) {
                    do {                
                      long dn_ss_ticket_number = e17->DN_SS_TICKET_NUMBER;
                      long v19 = e17->__av;
                      DOUBLE_TYPE l11 = (COUNTCUSTOMER1_L3_2.getValueOrDefault(se79.modify(customer_c_customer_sk,customer_address_ca_address_sk,dn_ss_ticket_number)) * (COUNTCUSTOMER1_L2_1.getValueOrDefault(se80.modify(customer_address_ca_address_sk,customer_address_ca_city)) + 1L));
                      DOUBLE_TYPE l12 = (COUNTCUSTOMER1_L2_2.getValueOrDefault(se81.modify(customer_c_customer_sk,customer_address_ca_address_sk,dn_ss_ticket_number)) * (COUNTCUSTOMER1_L2_1.getValueOrDefault(se82.modify(customer_address_ca_address_sk,customer_address_ca_city)) + 1L));
                      (/*if */(current_addr_ca_city != customer_address_ca_city) ? _c2.addOrDelOnZero(st6.modify(dn_ss_ticket_number,l12,l11,current_addr_ca_city,customer_c_first_name,customer_c_last_name,(v18 * (((COUNTCUSTOMER1_L2_1.getValueOrDefault(se78.modify(customer_address_ca_address_sk,customer_address_ca_city)) + 1L) * v19) != 0 ? 1L : 0L))), (v18 * (((COUNTCUSTOMER1_L2_1.getValueOrDefault(se78.modify(customer_address_ca_address_sk,customer_address_ca_city)) + 1L) * v19) != 0 ? 1L : 0L))) : (void)0);
                      n17 = n17->nxt;
                    } while (n17 && (e17 = n17->obj) && h13 == n17->hash &&  COUNTCUSTOMER_ADDRESS3_E2_2_mapkey01_idxfn::equals(se83, *e17)); 
                  }
                }
              n16 = n16->nxt;
            }
          }
        }{  // temp foreach
          const HashIndex<tuple7_LDDSSS_L, long>* i18 = static_cast<HashIndex<tuple7_LDDSSS_L, long>*>(_c2.index[0]);
          HashIndex<tuple7_LDDSSS_L, long>::IdxNode* n18; 
          tuple7_LDDSSS_L* e18;
        
          for (size_t i = 0; i < i18->size_; i++)
          {
            n18 = i18->buckets_ + i;
            while (n18 && (e18 = n18->obj))
            {
              long dn_ss_ticket_number = e18->_1;
              DOUBLE_TYPE dn_profit = e18->_2;
              DOUBLE_TYPE dn_amt = e18->_3;
              STRING_TYPE current_addr_ca_city = e18->_4;
              STRING_TYPE customer_c_first_name = e18->_5;
              STRING_TYPE customer_c_last_name = e18->_6;  
              long v20 = e18->__av; 
            COUNT.addOrDelOnZero(se64.modify(customer_c_last_name,customer_c_first_name,current_addr_ca_city,customer_address_ca_city,dn_ss_ticket_number,dn_amt,dn_profit),v20);      
              n18 = n18->nxt;
            }
          }
        }{ //slice 
          const HashIndex_COUNTCUSTOMER_ADDRESS2_map_1* i19 = static_cast<HashIndex_COUNTCUSTOMER_ADDRESS2_map_1*>(COUNTCUSTOMER_ADDRESS2.index[1]);
          const HASH_RES_t h14 = COUNTCUSTOMER_ADDRESS2_mapkey1_idxfn::hash(se85.modify1(customer_address_ca_address_sk));
          HashIndex_COUNTCUSTOMER_ADDRESS2_map_1::IdxNode* n19 = static_cast<HashIndex_COUNTCUSTOMER_ADDRESS2_map_1::IdxNode*>(i19->slice(se85, h14));
          COUNTCUSTOMER_ADDRESS2_entry* e19;
         
          if (n19 && (e19 = n19->obj)) {
            do {                
              long customer_c_customer_sk = e19->CUSTOMER_C_CUSTOMER_SK;
              STRING_TYPE customer_c_first_name = e19->CUSTOMER_C_FIRST_NAME;
              STRING_TYPE customer_c_last_name = e19->CUSTOMER_C_LAST_NAME;
              long v21 = e19->__av;
              COUNTCUSTOMER_ADDRESS3.addOrDelOnZero(se84.modify(customer_address_ca_city,customer_c_customer_sk,customer_c_first_name,customer_c_last_name),v21);
              n19 = n19->nxt;
            } while (n19 && (e19 = n19->obj) && h14 == n19->hash &&  COUNTCUSTOMER_ADDRESS2_mapkey1_idxfn::equals(se85, *e19)); 
          }
        }COUNTCUSTOMER1.addOrDelOnZero(se86.modify(customer_address_ca_address_sk,customer_address_ca_city),1L);
        { //slice 
          const HashIndex_COUNTCUSTOMER_ADDRESS3_E2_2_map_1* i20 = static_cast<HashIndex_COUNTCUSTOMER_ADDRESS3_E2_2_map_1*>(COUNTCUSTOMER_ADDRESS3_E2_2.index[1]);
          const HASH_RES_t h15 = COUNTCUSTOMER_ADDRESS3_E2_2_mapkey1_idxfn::hash(se88.modify1(customer_address_ca_address_sk));
          HashIndex_COUNTCUSTOMER_ADDRESS3_E2_2_map_1::IdxNode* n20 = static_cast<HashIndex_COUNTCUSTOMER_ADDRESS3_E2_2_map_1::IdxNode*>(i20->slice(se88, h15));
          COUNTCUSTOMER_ADDRESS3_E2_2_entry* e20;
         
          if (n20 && (e20 = n20->obj)) {
            do {                
              long countcustomercustomer_c_customer_sk = e20->CUSTOMER_C_CUSTOMER_SK;
              long dn_ss_ticket_number = e20->DN_SS_TICKET_NUMBER;
              long v22 = e20->__av;
              COUNTCUSTOMER1_E1_1.addOrDelOnZero(se87.modify(countcustomercustomer_c_customer_sk,customer_address_ca_address_sk,dn_ss_ticket_number,customer_address_ca_city),v22);
              n20 = n20->nxt;
            } while (n20 && (e20 = n20->obj) && h15 == n20->hash &&  COUNTCUSTOMER_ADDRESS3_E2_2_mapkey1_idxfn::equals(se88, *e20)); 
          }
        }{ //slice 
          const HashIndex_COUNTCUSTOMER_ADDRESS3_E2_2STORE2_map_1* i21 = static_cast<HashIndex_COUNTCUSTOMER_ADDRESS3_E2_2STORE2_map_1*>(COUNTCUSTOMER_ADDRESS3_E2_2STORE2.index[1]);
          const HASH_RES_t h16 = COUNTCUSTOMER_ADDRESS3_E2_2STORE2_mapkey1_idxfn::hash(se90.modify1(customer_address_ca_address_sk));
          HashIndex_COUNTCUSTOMER_ADDRESS3_E2_2STORE2_map_1::IdxNode* n21 = static_cast<HashIndex_COUNTCUSTOMER_ADDRESS3_E2_2STORE2_map_1::IdxNode*>(i21->slice(se90, h16));
          COUNTCUSTOMER_ADDRESS3_E2_2STORE2_entry* e21;
         
          if (n21 && (e21 = n21->obj)) {
            do {                
              long countcustomercustomer_c_customer_sk = e21->CUSTOMER_C_CUSTOMER_SK;
              long countcustomer1_e1_1storestore_s_store_sk = e21->COUNTCUSTOMER_ADDRESS3_E2_2STORESTORE_S_STORE_SK;
              long dn_ss_ticket_number = e21->DN_SS_TICKET_NUMBER;
              long v23 = e21->__av;
              COUNTCUSTOMER1_E1_1STORE2.addOrDelOnZero(se89.modify(countcustomercustomer_c_customer_sk,customer_address_ca_address_sk,countcustomer1_e1_1storestore_s_store_sk,dn_ss_ticket_number,customer_address_ca_city),v23);
              n21 = n21->nxt;
            } while (n21 && (e21 = n21->obj) && h16 == n21->hash &&  COUNTCUSTOMER_ADDRESS3_E2_2STORE2_mapkey1_idxfn::equals(se90, *e21)); 
          }
        }COUNTCUSTOMER1_L2_1.addOrDelOnZero(se91.modify(customer_address_ca_address_sk,customer_address_ca_city),1L);
      }
    }
    void on_insert_STORE(const long store_s_store_sk, const STRING_TYPE& store_s_store_id, const date store_s_rec_start_date, const date store_s_rec_end_date, const long store_s_closed_date_sk, const STRING_TYPE& store_s_store_name, const long store_s_number_employees, const long store_s_floor_space, const STRING_TYPE& store_s_hours, const STRING_TYPE& store_s_manager, const long store_s_market_id, const STRING_TYPE& store_s_geography_class, const STRING_TYPE& store_s_market_desc, const STRING_TYPE& store_s_market_manager, const long store_s_division_id, const STRING_TYPE& store_s_division_name, const long store_s_company_id, const STRING_TYPE& store_s_company_name, const STRING_TYPE& store_s_street_number, const STRING_TYPE& store_s_street_name, const STRING_TYPE& store_s_street_type, const STRING_TYPE& store_s_suite_number, const STRING_TYPE& store_s_city, const STRING_TYPE& store_s_county, const STRING_TYPE& store_s_state, const STRING_TYPE& store_s_zip, const STRING_TYPE& store_s_country, const DOUBLE_TYPE store_s_gmt_offset, const DOUBLE_TYPE store_s_tax_precentage) {
      {  if (tS>0) { ++tS; return; } if ((tN&127)==0) { gettimeofday(&(t),NULL); tT=((t).tv_sec-(t0).tv_sec)*1000000L+((t).tv_usec-(t0).tv_usec); if (tT>3600000000L) { tS=1; return; } } ++tN;
        (/*if */(((store_s_city == c1) || (store_s_city == c2) || (store_s_city == c3) || (store_s_city == c4) || (store_s_city == c5))) ? COUNTSTORE_SALES3_E1_5.addOrDelOnZero(se92.modify(store_s_store_sk),1L) : (void)0);
        { //slice 
          const HashIndex_COUNTCUSTOMER_ADDRESS3_E2_2STORE2_map_2* i22 = static_cast<HashIndex_COUNTCUSTOMER_ADDRESS3_E2_2STORE2_map_2*>(COUNTCUSTOMER_ADDRESS3_E2_2STORE2.index[2]);
          const HASH_RES_t h17 = COUNTCUSTOMER_ADDRESS3_E2_2STORE2_mapkey2_idxfn::hash(se94.modify2(store_s_store_sk));
          HashIndex_COUNTCUSTOMER_ADDRESS3_E2_2STORE2_map_2::IdxNode* n22 = static_cast<HashIndex_COUNTCUSTOMER_ADDRESS3_E2_2STORE2_map_2::IdxNode*>(i22->slice(se94, h17));
          COUNTCUSTOMER_ADDRESS3_E2_2STORE2_entry* e22;
         
          if (n22 && (e22 = n22->obj)) {
            do {                
              long customer_c_customer_sk = e22->CUSTOMER_C_CUSTOMER_SK;
              long countcustomer_addresscustomer_address_ca_address_sk = e22->COUNTCUSTOMER_ADDRESSCUSTOMER_ADDRESS_CA_ADDRESS_SK;
              long dn_ss_ticket_number = e22->DN_SS_TICKET_NUMBER;
              long v24 = e22->__av;
              (/*if */(((store_s_city == c1) || (store_s_city == c2) || (store_s_city == c3) || (store_s_city == c4) || (store_s_city == c5))) ? COUNTCUSTOMER_ADDRESS3_E2_2.addOrDelOnZero(se93.modify(customer_c_customer_sk,countcustomer_addresscustomer_address_ca_address_sk,dn_ss_ticket_number),v24) : (void)0);
              n22 = n22->nxt;
            } while (n22 && (e22 = n22->obj) && h17 == n22->hash &&  COUNTCUSTOMER_ADDRESS3_E2_2STORE2_mapkey2_idxfn::equals(se94, *e22)); 
          }
        }{ //slice 
          const HashIndex_COUNTCUSTOMER1_E1_1STORE2_map_2* i23 = static_cast<HashIndex_COUNTCUSTOMER1_E1_1STORE2_map_2*>(COUNTCUSTOMER1_E1_1STORE2.index[1]);
          const HASH_RES_t h18 = COUNTCUSTOMER1_E1_1STORE2_mapkey2_idxfn::hash(se96.modify2(store_s_store_sk));
          HashIndex_COUNTCUSTOMER1_E1_1STORE2_map_2::IdxNode* n23 = static_cast<HashIndex_COUNTCUSTOMER1_E1_1STORE2_map_2::IdxNode*>(i23->slice(se96, h18));
          COUNTCUSTOMER1_E1_1STORE2_entry* e23;
         
          if (n23 && (e23 = n23->obj)) {
            do {                
              long countcustomercustomer_c_customer_sk = e23->COUNTCUSTOMERCUSTOMER_C_CUSTOMER_SK;
              long store_sales_ss_addr_sk = e23->STORE_SALES_SS_ADDR_SK;
              long dn_ss_ticket_number = e23->DN_SS_TICKET_NUMBER;
              STRING_TYPE dn_bought_city = e23->DN_BOUGHT_CITY;
              long v25 = e23->__av;
              (/*if */(((store_s_city == c1) || (store_s_city == c2) || (store_s_city == c3) || (store_s_city == c4) || (store_s_city == c5))) ? COUNTCUSTOMER1_E1_1.addOrDelOnZero(se95.modify(countcustomercustomer_c_customer_sk,store_sales_ss_addr_sk,dn_ss_ticket_number,dn_bought_city),v25) : (void)0);
              n23 = n23->nxt;
            } while (n23 && (e23 = n23->obj) && h18 == n23->hash &&  COUNTCUSTOMER1_E1_1STORE2_mapkey2_idxfn::equals(se96, *e23)); 
          }
        }{ //slice 
          const HashIndex_COUNTCUSTOMER1_L2_2STORE2_map_2* i24 = static_cast<HashIndex_COUNTCUSTOMER1_L2_2STORE2_map_2*>(COUNTCUSTOMER1_L2_2STORE2.index[1]);
          const HASH_RES_t h19 = COUNTCUSTOMER1_L2_2STORE2_mapkey2_idxfn::hash(se98.modify2(store_s_store_sk));
          HashIndex_COUNTCUSTOMER1_L2_2STORE2_map_2::IdxNode* n24 = static_cast<HashIndex_COUNTCUSTOMER1_L2_2STORE2_map_2::IdxNode*>(i24->slice(se98, h19));
          COUNTCUSTOMER1_L2_2STORE2_entry* e24;
         
          if (n24 && (e24 = n24->obj)) {
            do {                
              long countcustomercustomer_c_customer_sk = e24->COUNTCUSTOMERCUSTOMER_C_CUSTOMER_SK;
              long store_sales_ss_addr_sk = e24->STORE_SALES_SS_ADDR_SK;
              long dn_ss_ticket_number = e24->DN_SS_TICKET_NUMBER;
              DOUBLE_TYPE v26 = e24->__av;
              (/*if */(((store_s_city == c1) || (store_s_city == c2) || (store_s_city == c3) || (store_s_city == c4) || (store_s_city == c5))) ? COUNTCUSTOMER1_L2_2.addOrDelOnZero(se97.modify(countcustomercustomer_c_customer_sk,store_sales_ss_addr_sk,dn_ss_ticket_number),v26) : (void)0);
              n24 = n24->nxt;
            } while (n24 && (e24 = n24->obj) && h19 == n24->hash &&  COUNTCUSTOMER1_L2_2STORE2_mapkey2_idxfn::equals(se98, *e24)); 
          }
        }{ //slice 
          const HashIndex_COUNTCUSTOMER1_L3_2STORE2_map_2* i25 = static_cast<HashIndex_COUNTCUSTOMER1_L3_2STORE2_map_2*>(COUNTCUSTOMER1_L3_2STORE2.index[1]);
          const HASH_RES_t h20 = COUNTCUSTOMER1_L3_2STORE2_mapkey2_idxfn::hash(se100.modify2(store_s_store_sk));
          HashIndex_COUNTCUSTOMER1_L3_2STORE2_map_2::IdxNode* n25 = static_cast<HashIndex_COUNTCUSTOMER1_L3_2STORE2_map_2::IdxNode*>(i25->slice(se100, h20));
          COUNTCUSTOMER1_L3_2STORE2_entry* e25;
         
          if (n25 && (e25 = n25->obj)) {
            do {                
              long countcustomercustomer_c_customer_sk = e25->COUNTCUSTOMERCUSTOMER_C_CUSTOMER_SK;
              long store_sales_ss_addr_sk = e25->STORE_SALES_SS_ADDR_SK;
              long dn_ss_ticket_number = e25->DN_SS_TICKET_NUMBER;
              DOUBLE_TYPE v27 = e25->__av;
              (/*if */(((store_s_city == c1) || (store_s_city == c2) || (store_s_city == c3) || (store_s_city == c4) || (store_s_city == c5))) ? COUNTCUSTOMER1_L3_2.addOrDelOnZero(se99.modify(countcustomercustomer_c_customer_sk,store_sales_ss_addr_sk,dn_ss_ticket_number),v27) : (void)0);
              n25 = n25->nxt;
            } while (n25 && (e25 = n25->obj) && h20 == n25->hash &&  COUNTCUSTOMER1_L3_2STORE2_mapkey2_idxfn::equals(se100, *e25)); 
          }
        }COUNT.clear();
        {  // foreach
          const HashIndex_COUNTCUSTOMER_ADDRESS3_map_0123* i26 = static_cast<HashIndex_COUNTCUSTOMER_ADDRESS3_map_0123*>(COUNTCUSTOMER_ADDRESS3.index[0]);
          HashIndex_COUNTCUSTOMER_ADDRESS3_map_0123::IdxNode* n26; 
          COUNTCUSTOMER_ADDRESS3_entry* e26;
        
          for (size_t i = 0; i < i26->size_; i++)
          {
            n26 = i26->buckets_ + i;
            while (n26 && (e26 = n26->obj))
            {
                STRING_TYPE current_addr_ca_city = e26->CURRENT_ADDR_CA_CITY;
                long customer_c_customer_sk = e26->CUSTOMER_C_CUSTOMER_SK;
                STRING_TYPE customer_c_first_name = e26->CUSTOMER_C_FIRST_NAME;
                STRING_TYPE customer_c_last_name = e26->CUSTOMER_C_LAST_NAME;
                long v28 = e26->__av;
                { //slice 
                  const HashIndex_COUNTCUSTOMER1_E1_1_map_0* i27 = static_cast<HashIndex_COUNTCUSTOMER1_E1_1_map_0*>(COUNTCUSTOMER1_E1_1.index[1]);
                  const HASH_RES_t h21 = COUNTCUSTOMER1_E1_1_mapkey0_idxfn::hash(se106.modify0(customer_c_customer_sk));
                  HashIndex_COUNTCUSTOMER1_E1_1_map_0::IdxNode* n27 = static_cast<HashIndex_COUNTCUSTOMER1_E1_1_map_0::IdxNode*>(i27->slice(se106, h21));
                  COUNTCUSTOMER1_E1_1_entry* e27;
                 
                  if (n27 && (e27 = n27->obj)) {
                    do {                
                      long store_sales_ss_addr_sk = e27->STORE_SALES_SS_ADDR_SK;
                      long dn_ss_ticket_number = e27->DN_SS_TICKET_NUMBER;
                      STRING_TYPE dn_bought_city = e27->DN_BOUGHT_CITY;
                      long v29 = e27->__av;
                      DOUBLE_TYPE l13 = (COUNTCUSTOMER1_L2_1.getValueOrDefault(se102.modify(store_sales_ss_addr_sk,dn_bought_city)) * COUNTCUSTOMER1_L3_2.getValueOrDefault(se103.modify(customer_c_customer_sk,store_sales_ss_addr_sk,dn_ss_ticket_number)));
                      DOUBLE_TYPE l14 = (COUNTCUSTOMER1_L2_1.getValueOrDefault(se104.modify(store_sales_ss_addr_sk,dn_bought_city)) * COUNTCUSTOMER1_L2_2.getValueOrDefault(se105.modify(customer_c_customer_sk,store_sales_ss_addr_sk,dn_ss_ticket_number)));
                      (/*if */(current_addr_ca_city != dn_bought_city) ? COUNT.addOrDelOnZero(se101.modify(customer_c_last_name,customer_c_first_name,current_addr_ca_city,dn_bought_city,dn_ss_ticket_number,l13,l14),(v28 * (v29 != 0 ? 1L : 0L))) : (void)0);
                      n27 = n27->nxt;
                    } while (n27 && (e27 = n27->obj) && h21 == n27->hash &&  COUNTCUSTOMER1_E1_1_mapkey0_idxfn::equals(se106, *e27)); 
                  }
                }
              n26 = n26->nxt;
            }
          }
        }
      }
    }
    void on_system_ready_event() {
      {  
        COUNTSTORE_SALES3_E1_4.clear();
        {  // foreach
          const HashIndex_DATE_DIM_map_0123456789101112131415161718192021222324252627* i28 = static_cast<HashIndex_DATE_DIM_map_0123456789101112131415161718192021222324252627*>(DATE_DIM.index[0]);
          HashIndex_DATE_DIM_map_0123456789101112131415161718192021222324252627::IdxNode* n28; 
          DATE_DIM_entry* e28;
        
          for (size_t i = 0; i < i28->size_; i++)
          {
            n28 = i28->buckets_ + i;
            while (n28 && (e28 = n28->obj))
            {
                long countstore_salesstore_sales_ss_sold_date_sk = e28->DATE_DIM_D_DATE_SK;
                STRING_TYPE date_dim_d_date_id = e28->DATE_DIM_D_DATE_ID;
                date date_dim_d_date = e28->DATE_DIM_D_DATE;
                long date_dim_d_month_seq = e28->DATE_DIM_D_MONTH_SEQ;
                long date_dim_d_week_seq = e28->DATE_DIM_D_WEEK_SEQ;
                long date_dim_d_quarter_seq = e28->DATE_DIM_D_QUARTER_SEQ;
                long date_dim_d_year = e28->DATE_DIM_D_YEAR;
                long date_dim_d_dow = e28->DATE_DIM_D_DOW;
                long date_dim_d_moy = e28->DATE_DIM_D_MOY;
                long date_dim_d_dom = e28->DATE_DIM_D_DOM;
                long date_dim_d_qoy = e28->DATE_DIM_D_QOY;
                long date_dim_d_fy_year = e28->DATE_DIM_D_FY_YEAR;
                long date_dim_d_fy_quarter_seq = e28->DATE_DIM_D_FY_QUARTER_SEQ;
                long date_dim_d_fy_week_seq = e28->DATE_DIM_D_FY_WEEK_SEQ;
                STRING_TYPE date_dim_d_day_name = e28->DATE_DIM_D_DAY_NAME;
                STRING_TYPE date_dim_d_quarter_name = e28->DATE_DIM_D_QUARTER_NAME;
                STRING_TYPE date_dim_d_holiday = e28->DATE_DIM_D_HOLIDAY;
                STRING_TYPE date_dim_d_weekend = e28->DATE_DIM_D_WEEKEND;
                STRING_TYPE date_dim_d_following_holiday = e28->DATE_DIM_D_FOLLOWING_HOLIDAY;
                long date_dim_d_first_dom = e28->DATE_DIM_D_FIRST_DOM;
                long date_dim_d_last_dom = e28->DATE_DIM_D_LAST_DOM;
                long date_dim_d_same_day_ly = e28->DATE_DIM_D_SAME_DAY_LY;
                long date_dim_d_same_day_lq = e28->DATE_DIM_D_SAME_DAY_LQ;
                STRING_TYPE date_dim_d_current_day = e28->DATE_DIM_D_CURRENT_DAY;
                STRING_TYPE date_dim_d_current_week = e28->DATE_DIM_D_CURRENT_WEEK;
                STRING_TYPE date_dim_d_current_month = e28->DATE_DIM_D_CURRENT_MONTH;
                STRING_TYPE date_dim_d_current_quarter = e28->DATE_DIM_D_CURRENT_QUARTER;
                STRING_TYPE date_dim_d_current_year = e28->DATE_DIM_D_CURRENT_YEAR;
                long v30 = e28->__av;
                (/*if */(((date_dim_d_dow == 6L) || (date_dim_d_dow == 0L)) && ((date_dim_d_year == 1999L) || (date_dim_d_year == 2000L) || (date_dim_d_year == 2001L))) ? COUNTSTORE_SALES3_E1_4.addOrDelOnZero(se107.modify(countstore_salesstore_sales_ss_sold_date_sk),v30) : (void)0);
              n28 = n28->nxt;
            }
          }
        }COUNTSTORE_SALES3_E1_6.clear();
        {  // foreach
          const HashIndex_HOUSEHOLD_DEMOGRAPHICS_map_01234* i29 = static_cast<HashIndex_HOUSEHOLD_DEMOGRAPHICS_map_01234*>(HOUSEHOLD_DEMOGRAPHICS.index[0]);
          HashIndex_HOUSEHOLD_DEMOGRAPHICS_map_01234::IdxNode* n29; 
          HOUSEHOLD_DEMOGRAPHICS_entry* e29;
        
          for (size_t i = 0; i < i29->size_; i++)
          {
            n29 = i29->buckets_ + i;
            while (n29 && (e29 = n29->obj))
            {
                long countstore_salesstore_sales_ss_hdemo_sk = e29->HOUSEHOLD_DEMOGRAPHICS_HD_DEMO_SK;
                long household_demographics_hd_income_band_sk = e29->HOUSEHOLD_DEMOGRAPHICS_HD_INCOME_BAND_SK;
                STRING_TYPE household_demographics_hd_buy_potential = e29->HOUSEHOLD_DEMOGRAPHICS_HD_BUY_POTENTIAL;
                long household_demographics_hd_dep_count = e29->HOUSEHOLD_DEMOGRAPHICS_HD_DEP_COUNT;
                long household_demographics_hd_vehicle_count = e29->HOUSEHOLD_DEMOGRAPHICS_HD_VEHICLE_COUNT;
                long v31 = e29->__av;
                long l15 = ((/*if */(household_demographics_hd_dep_count == 6L) ? 1L : 0L) + (/*if */(household_demographics_hd_vehicle_count == 3L) ? 1L : 0L));
                (/*if */(l15 > 0L) ? COUNTSTORE_SALES3_E1_6.addOrDelOnZero(se108.modify(countstore_salesstore_sales_ss_hdemo_sk),v31) : (void)0);
              n29 = n29->nxt;
            }
          }
        }
      }
    }
  
  private:
  
    /* Sample entries for avoiding recreation of temporary objects */
    COUNT_entry se1;
    COUNTCUSTOMER_ADDRESS3_E2_2_entry se2;
    COUNTCUSTOMER1_L2_1_entry se3;
    COUNTCUSTOMER1_L3_2_entry se4;
    COUNTCUSTOMER1_L2_1_entry se5;
    COUNTCUSTOMER1_L2_2_entry se6;
    tuple4_SDD_L st1;
    COUNTCUSTOMER1_L2_1_entry se7;
    COUNTCUSTOMER_ADDRESS3_E2_2_entry se8;
    COUNTSTORE_SALES3_E1_4_entry se9;
    COUNTSTORE_SALES3_E1_5_entry se10;
    COUNTSTORE_SALES3_E1_6_entry se11;
    COUNTCUSTOMER1_L2_1_entry se12;
    COUNTCUSTOMER1_L2_2_entry se13;
    COUNTSTORE_SALES3_E1_4_entry se14;
    COUNTSTORE_SALES3_E1_5_entry se15;
    COUNTSTORE_SALES3_E1_6_entry se16;
    COUNTCUSTOMER1_L2_1_entry se17;
    COUNTCUSTOMER1_L3_2_entry se18;
    COUNTSTORE_SALES3_E1_4_entry se19;
    COUNTSTORE_SALES3_E1_5_entry se20;
    COUNTSTORE_SALES3_E1_6_entry se21;
    tuple4_SDD_L st2;
    COUNTCUSTOMER1_L2_1_entry se22;
    COUNTCUSTOMER_ADDRESS3_entry se23;
    COUNTCUSTOMER_ADDRESS3_E2_2_entry se24;
    COUNTSTORE_SALES3_E1_4_entry se25;
    COUNTSTORE_SALES3_E1_5_entry se26;
    COUNTSTORE_SALES3_E1_6_entry se27;
    COUNTCUSTOMER_ADDRESS3_E2_2STORE2_entry se28;
    COUNTSTORE_SALES3_E1_4_entry se29;
    COUNTSTORE_SALES3_E1_6_entry se30;
    COUNTCUSTOMER1_E1_1_entry se31;
    COUNTSTORE_SALES3_E1_4_entry se32;
    COUNTSTORE_SALES3_E1_5_entry se33;
    COUNTSTORE_SALES3_E1_6_entry se34;
    COUNTCUSTOMER1_L2_1_entry se35;
    COUNTCUSTOMER1_E1_1STORE2_entry se36;
    COUNTSTORE_SALES3_E1_4_entry se37;
    COUNTSTORE_SALES3_E1_6_entry se38;
    COUNTCUSTOMER1_L2_1_entry se39;
    COUNTCUSTOMER1_L2_2_entry se40;
    COUNTSTORE_SALES3_E1_4_entry se41;
    COUNTSTORE_SALES3_E1_5_entry se42;
    COUNTSTORE_SALES3_E1_6_entry se43;
    COUNTCUSTOMER1_L2_2STORE2_entry se44;
    COUNTSTORE_SALES3_E1_4_entry se45;
    COUNTSTORE_SALES3_E1_6_entry se46;
    COUNTCUSTOMER1_L3_2_entry se47;
    COUNTSTORE_SALES3_E1_4_entry se48;
    COUNTSTORE_SALES3_E1_5_entry se49;
    COUNTSTORE_SALES3_E1_6_entry se50;
    COUNTCUSTOMER1_L3_2STORE2_entry se51;
    COUNTSTORE_SALES3_E1_4_entry se52;
    COUNTSTORE_SALES3_E1_6_entry se53;
    COUNT_entry se54;
    COUNTCUSTOMER1_L2_1_entry se55;
    COUNTCUSTOMER1_L3_2_entry se56;
    COUNTCUSTOMER1_L2_1_entry se57;
    COUNTCUSTOMER1_L2_2_entry se58;
    tuple5_LSDD_L st3;
    COUNTCUSTOMER1_E1_1_entry se59;
    COUNTCUSTOMER1_entry se60;
    COUNTCUSTOMER_ADDRESS2_entry se61;
    COUNTCUSTOMER_ADDRESS3_entry se62;
    COUNTCUSTOMER1_entry se63;
    COUNT_entry se64;
    COUNTCUSTOMER1_L3_2_entry se65;
    COUNTCUSTOMER1_L2_1_entry se66;
    COUNTCUSTOMER1_L2_2_entry se67;
    COUNTCUSTOMER1_L2_1_entry se68;
    tuple7_SSLSDD_L st4;
    COUNTCUSTOMER1_E1_1_entry se69;
    COUNTCUSTOMER_ADDRESS2_entry se70;
    COUNTCUSTOMER1_L2_1_entry se71;
    COUNTCUSTOMER1_L3_2_entry se72;
    COUNTCUSTOMER1_L2_1_entry se73;
    COUNTCUSTOMER1_L2_2_entry se74;
    COUNTCUSTOMER1_L2_1_entry se75;
    tuple7_LDDSSS_L st5;
    COUNTCUSTOMER_ADDRESS3_entry se76;
    COUNTCUSTOMER_ADDRESS3_E2_2_entry se77;
    COUNTCUSTOMER1_L2_1_entry se78;
    COUNTCUSTOMER1_L3_2_entry se79;
    COUNTCUSTOMER1_L2_1_entry se80;
    COUNTCUSTOMER1_L2_2_entry se81;
    COUNTCUSTOMER1_L2_1_entry se82;
    tuple7_LDDSSS_L st6;
    COUNTCUSTOMER_ADDRESS3_E2_2_entry se83;
    COUNTCUSTOMER_ADDRESS3_entry se84;
    COUNTCUSTOMER_ADDRESS2_entry se85;
    COUNTCUSTOMER1_entry se86;
    COUNTCUSTOMER1_E1_1_entry se87;
    COUNTCUSTOMER_ADDRESS3_E2_2_entry se88;
    COUNTCUSTOMER1_E1_1STORE2_entry se89;
    COUNTCUSTOMER_ADDRESS3_E2_2STORE2_entry se90;
    COUNTCUSTOMER1_L2_1_entry se91;
    COUNTSTORE_SALES3_E1_5_entry se92;
    COUNTCUSTOMER_ADDRESS3_E2_2_entry se93;
    COUNTCUSTOMER_ADDRESS3_E2_2STORE2_entry se94;
    COUNTCUSTOMER1_E1_1_entry se95;
    COUNTCUSTOMER1_E1_1STORE2_entry se96;
    COUNTCUSTOMER1_L2_2_entry se97;
    COUNTCUSTOMER1_L2_2STORE2_entry se98;
    COUNTCUSTOMER1_L3_2_entry se99;
    COUNTCUSTOMER1_L3_2STORE2_entry se100;
    COUNT_entry se101;
    COUNTCUSTOMER1_L2_1_entry se102;
    COUNTCUSTOMER1_L3_2_entry se103;
    COUNTCUSTOMER1_L2_1_entry se104;
    COUNTCUSTOMER1_L2_2_entry se105;
    COUNTCUSTOMER1_E1_1_entry se106;
    COUNTSTORE_SALES3_E1_4_entry se107;
    COUNTSTORE_SALES3_E1_6_entry se108;
  
    /* Data structures used for storing materialized views */
    DATE_DIM_map DATE_DIM;
    HOUSEHOLD_DEMOGRAPHICS_map HOUSEHOLD_DEMOGRAPHICS;
    COUNTSTORE_SALES3_E1_4_map COUNTSTORE_SALES3_E1_4;
    COUNTSTORE_SALES3_E1_5_map COUNTSTORE_SALES3_E1_5;
    COUNTSTORE_SALES3_E1_6_map COUNTSTORE_SALES3_E1_6;
    COUNTCUSTOMER_ADDRESS2_map COUNTCUSTOMER_ADDRESS2;
    COUNTCUSTOMER_ADDRESS3_map COUNTCUSTOMER_ADDRESS3;
    COUNTCUSTOMER_ADDRESS3_E2_2_map COUNTCUSTOMER_ADDRESS3_E2_2;
    COUNTCUSTOMER_ADDRESS3_E2_2STORE2_map COUNTCUSTOMER_ADDRESS3_E2_2STORE2;
    COUNTCUSTOMER1_map COUNTCUSTOMER1;
    COUNTCUSTOMER1_E1_1_map COUNTCUSTOMER1_E1_1;
    COUNTCUSTOMER1_E1_1STORE2_map COUNTCUSTOMER1_E1_1STORE2;
    COUNTCUSTOMER1_L2_1_map COUNTCUSTOMER1_L2_1;
    COUNTCUSTOMER1_L2_2_map COUNTCUSTOMER1_L2_2;
    COUNTCUSTOMER1_L2_2STORE2_map COUNTCUSTOMER1_L2_2STORE2;
    COUNTCUSTOMER1_L3_2_map COUNTCUSTOMER1_L3_2;
    COUNTCUSTOMER1_L3_2STORE2_map COUNTCUSTOMER1_L3_2STORE2;
    MultiHashMap<tuple4_SDD_L,long,HashIndex<tuple4_SDD_L,long> > _c1;
    MultiHashMap<tuple7_SSLSDD_L,long,HashIndex<tuple7_SSLSDD_L,long> > agg2;
    MultiHashMap<tuple7_LDDSSS_L,long,HashIndex<tuple7_LDDSSS_L,long> > _c2;
    MultiHashMap<tuple5_LSDD_L,long,HashIndex<tuple5_LSDD_L,long> > agg1;
    /*const static*/ STRING_TYPE c1;
    /*const static*/ STRING_TYPE c4;
    /*const static*/ STRING_TYPE c2;
    /*const static*/ STRING_TYPE c3;
    /*const static*/ STRING_TYPE c5;
  
  };

}
