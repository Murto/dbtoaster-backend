#include <sys/time.h>
#include "macro.hpp"
#include "types.hpp"
#include "functions.hpp"
#include "hash.hpp"
#include "hashmap.hpp"
#include "serialization.hpp"

#define ELEM_SEPARATOR "\n\t\t\t"

namespace dbtoaster {
  
  /* Definitions of auxiliary maps for storing materialized views. */
  struct DATE_DIM_entry {
    long DATE_DIM_D_DATE_SK; STRING_TYPE DATE_DIM_D_DATE_ID; date DATE_DIM_D_DATE; long DATE_DIM_D_MONTH_SEQ; long DATE_DIM_D_WEEK_SEQ; long DATE_DIM_D_QUARTER_SEQ; long DATE_DIM_D_YEAR; long DATE_DIM_D_DOW; long DATE_DIM_D_MOY; long DATE_DIM_D_DOM; long DATE_DIM_D_QOY; long DATE_DIM_D_FY_YEAR; long DATE_DIM_D_FY_QUARTER_SEQ; long DATE_DIM_D_FY_WEEK_SEQ; STRING_TYPE DATE_DIM_D_DAY_NAME; STRING_TYPE DATE_DIM_D_QUARTER_NAME; STRING_TYPE DATE_DIM_D_HOLIDAY; STRING_TYPE DATE_DIM_D_WEEKEND; STRING_TYPE DATE_DIM_D_FOLLOWING_HOLIDAY; long DATE_DIM_D_FIRST_DOM; long DATE_DIM_D_LAST_DOM; long DATE_DIM_D_SAME_DAY_LY; long DATE_DIM_D_SAME_DAY_LQ; STRING_TYPE DATE_DIM_D_CURRENT_DAY; STRING_TYPE DATE_DIM_D_CURRENT_WEEK; STRING_TYPE DATE_DIM_D_CURRENT_MONTH; STRING_TYPE DATE_DIM_D_CURRENT_QUARTER; STRING_TYPE DATE_DIM_D_CURRENT_YEAR; long __av; 
    explicit DATE_DIM_entry() { /*DATE_DIM_D_DATE_SK = 0L; DATE_DIM_D_DATE_ID = ""; DATE_DIM_D_DATE = 00000000; DATE_DIM_D_MONTH_SEQ = 0L; DATE_DIM_D_WEEK_SEQ = 0L; DATE_DIM_D_QUARTER_SEQ = 0L; DATE_DIM_D_YEAR = 0L; DATE_DIM_D_DOW = 0L; DATE_DIM_D_MOY = 0L; DATE_DIM_D_DOM = 0L; DATE_DIM_D_QOY = 0L; DATE_DIM_D_FY_YEAR = 0L; DATE_DIM_D_FY_QUARTER_SEQ = 0L; DATE_DIM_D_FY_WEEK_SEQ = 0L; DATE_DIM_D_DAY_NAME = ""; DATE_DIM_D_QUARTER_NAME = ""; DATE_DIM_D_HOLIDAY = ""; DATE_DIM_D_WEEKEND = ""; DATE_DIM_D_FOLLOWING_HOLIDAY = ""; DATE_DIM_D_FIRST_DOM = 0L; DATE_DIM_D_LAST_DOM = 0L; DATE_DIM_D_SAME_DAY_LY = 0L; DATE_DIM_D_SAME_DAY_LQ = 0L; DATE_DIM_D_CURRENT_DAY = ""; DATE_DIM_D_CURRENT_WEEK = ""; DATE_DIM_D_CURRENT_MONTH = ""; DATE_DIM_D_CURRENT_QUARTER = ""; DATE_DIM_D_CURRENT_YEAR = ""; __av = 0L; */ }
    explicit DATE_DIM_entry(const long c0, const STRING_TYPE& c1, const date c2, const long c3, const long c4, const long c5, const long c6, const long c7, const long c8, const long c9, const long c10, const long c11, const long c12, const long c13, const STRING_TYPE& c14, const STRING_TYPE& c15, const STRING_TYPE& c16, const STRING_TYPE& c17, const STRING_TYPE& c18, const long c19, const long c20, const long c21, const long c22, const STRING_TYPE& c23, const STRING_TYPE& c24, const STRING_TYPE& c25, const STRING_TYPE& c26, const STRING_TYPE& c27, const long c28) { DATE_DIM_D_DATE_SK = c0; DATE_DIM_D_DATE_ID = c1; DATE_DIM_D_DATE = c2; DATE_DIM_D_MONTH_SEQ = c3; DATE_DIM_D_WEEK_SEQ = c4; DATE_DIM_D_QUARTER_SEQ = c5; DATE_DIM_D_YEAR = c6; DATE_DIM_D_DOW = c7; DATE_DIM_D_MOY = c8; DATE_DIM_D_DOM = c9; DATE_DIM_D_QOY = c10; DATE_DIM_D_FY_YEAR = c11; DATE_DIM_D_FY_QUARTER_SEQ = c12; DATE_DIM_D_FY_WEEK_SEQ = c13; DATE_DIM_D_DAY_NAME = c14; DATE_DIM_D_QUARTER_NAME = c15; DATE_DIM_D_HOLIDAY = c16; DATE_DIM_D_WEEKEND = c17; DATE_DIM_D_FOLLOWING_HOLIDAY = c18; DATE_DIM_D_FIRST_DOM = c19; DATE_DIM_D_LAST_DOM = c20; DATE_DIM_D_SAME_DAY_LY = c21; DATE_DIM_D_SAME_DAY_LQ = c22; DATE_DIM_D_CURRENT_DAY = c23; DATE_DIM_D_CURRENT_WEEK = c24; DATE_DIM_D_CURRENT_MONTH = c25; DATE_DIM_D_CURRENT_QUARTER = c26; DATE_DIM_D_CURRENT_YEAR = c27; __av = c28; }
    DATE_DIM_entry(const DATE_DIM_entry& other) : DATE_DIM_D_DATE_SK( other.DATE_DIM_D_DATE_SK ), DATE_DIM_D_DATE_ID( other.DATE_DIM_D_DATE_ID ), DATE_DIM_D_DATE( other.DATE_DIM_D_DATE ), DATE_DIM_D_MONTH_SEQ( other.DATE_DIM_D_MONTH_SEQ ), DATE_DIM_D_WEEK_SEQ( other.DATE_DIM_D_WEEK_SEQ ), DATE_DIM_D_QUARTER_SEQ( other.DATE_DIM_D_QUARTER_SEQ ), DATE_DIM_D_YEAR( other.DATE_DIM_D_YEAR ), DATE_DIM_D_DOW( other.DATE_DIM_D_DOW ), DATE_DIM_D_MOY( other.DATE_DIM_D_MOY ), DATE_DIM_D_DOM( other.DATE_DIM_D_DOM ), DATE_DIM_D_QOY( other.DATE_DIM_D_QOY ), DATE_DIM_D_FY_YEAR( other.DATE_DIM_D_FY_YEAR ), DATE_DIM_D_FY_QUARTER_SEQ( other.DATE_DIM_D_FY_QUARTER_SEQ ), DATE_DIM_D_FY_WEEK_SEQ( other.DATE_DIM_D_FY_WEEK_SEQ ), DATE_DIM_D_DAY_NAME( other.DATE_DIM_D_DAY_NAME ), DATE_DIM_D_QUARTER_NAME( other.DATE_DIM_D_QUARTER_NAME ), DATE_DIM_D_HOLIDAY( other.DATE_DIM_D_HOLIDAY ), DATE_DIM_D_WEEKEND( other.DATE_DIM_D_WEEKEND ), DATE_DIM_D_FOLLOWING_HOLIDAY( other.DATE_DIM_D_FOLLOWING_HOLIDAY ), DATE_DIM_D_FIRST_DOM( other.DATE_DIM_D_FIRST_DOM ), DATE_DIM_D_LAST_DOM( other.DATE_DIM_D_LAST_DOM ), DATE_DIM_D_SAME_DAY_LY( other.DATE_DIM_D_SAME_DAY_LY ), DATE_DIM_D_SAME_DAY_LQ( other.DATE_DIM_D_SAME_DAY_LQ ), DATE_DIM_D_CURRENT_DAY( other.DATE_DIM_D_CURRENT_DAY ), DATE_DIM_D_CURRENT_WEEK( other.DATE_DIM_D_CURRENT_WEEK ), DATE_DIM_D_CURRENT_MONTH( other.DATE_DIM_D_CURRENT_MONTH ), DATE_DIM_D_CURRENT_QUARTER( other.DATE_DIM_D_CURRENT_QUARTER ), DATE_DIM_D_CURRENT_YEAR( other.DATE_DIM_D_CURRENT_YEAR ), __av( other.__av ) {}
    FORCE_INLINE DATE_DIM_entry& modify(const long c0, const STRING_TYPE& c1, const date c2, const long c3, const long c4, const long c5, const long c6, const long c7, const long c8, const long c9, const long c10, const long c11, const long c12, const long c13, const STRING_TYPE& c14, const STRING_TYPE& c15, const STRING_TYPE& c16, const STRING_TYPE& c17, const STRING_TYPE& c18, const long c19, const long c20, const long c21, const long c22, const STRING_TYPE& c23, const STRING_TYPE& c24, const STRING_TYPE& c25, const STRING_TYPE& c26, const STRING_TYPE& c27) { DATE_DIM_D_DATE_SK = c0; DATE_DIM_D_DATE_ID = c1; DATE_DIM_D_DATE = c2; DATE_DIM_D_MONTH_SEQ = c3; DATE_DIM_D_WEEK_SEQ = c4; DATE_DIM_D_QUARTER_SEQ = c5; DATE_DIM_D_YEAR = c6; DATE_DIM_D_DOW = c7; DATE_DIM_D_MOY = c8; DATE_DIM_D_DOM = c9; DATE_DIM_D_QOY = c10; DATE_DIM_D_FY_YEAR = c11; DATE_DIM_D_FY_QUARTER_SEQ = c12; DATE_DIM_D_FY_WEEK_SEQ = c13; DATE_DIM_D_DAY_NAME = c14; DATE_DIM_D_QUARTER_NAME = c15; DATE_DIM_D_HOLIDAY = c16; DATE_DIM_D_WEEKEND = c17; DATE_DIM_D_FOLLOWING_HOLIDAY = c18; DATE_DIM_D_FIRST_DOM = c19; DATE_DIM_D_LAST_DOM = c20; DATE_DIM_D_SAME_DAY_LY = c21; DATE_DIM_D_SAME_DAY_LQ = c22; DATE_DIM_D_CURRENT_DAY = c23; DATE_DIM_D_CURRENT_WEEK = c24; DATE_DIM_D_CURRENT_MONTH = c25; DATE_DIM_D_CURRENT_QUARTER = c26; DATE_DIM_D_CURRENT_YEAR = c27;  return *this; }
    FORCE_INLINE DATE_DIM_entry& modify68(const long c6, const long c8) { DATE_DIM_D_YEAR = c6; DATE_DIM_D_MOY = c8;  return *this; }
    template<class Archive>
    void serialize(Archive& ar, const unsigned int version) const 
    {
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, DATE_DIM_D_DATE_SK);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, DATE_DIM_D_DATE_ID);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, DATE_DIM_D_DATE);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, DATE_DIM_D_MONTH_SEQ);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, DATE_DIM_D_WEEK_SEQ);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, DATE_DIM_D_QUARTER_SEQ);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, DATE_DIM_D_YEAR);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, DATE_DIM_D_DOW);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, DATE_DIM_D_MOY);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, DATE_DIM_D_DOM);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, DATE_DIM_D_QOY);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, DATE_DIM_D_FY_YEAR);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, DATE_DIM_D_FY_QUARTER_SEQ);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, DATE_DIM_D_FY_WEEK_SEQ);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, DATE_DIM_D_DAY_NAME);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, DATE_DIM_D_QUARTER_NAME);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, DATE_DIM_D_HOLIDAY);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, DATE_DIM_D_WEEKEND);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, DATE_DIM_D_FOLLOWING_HOLIDAY);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, DATE_DIM_D_FIRST_DOM);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, DATE_DIM_D_LAST_DOM);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, DATE_DIM_D_SAME_DAY_LY);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, DATE_DIM_D_SAME_DAY_LQ);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, DATE_DIM_D_CURRENT_DAY);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, DATE_DIM_D_CURRENT_WEEK);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, DATE_DIM_D_CURRENT_MONTH);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, DATE_DIM_D_CURRENT_QUARTER);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, DATE_DIM_D_CURRENT_YEAR);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, __av);
    }
  };
  struct DATE_DIM_mapkey0123456789101112131415161718192021222324252627_idxfn {
    FORCE_INLINE static size_t hash(const DATE_DIM_entry& e) {
      size_t h = 0;
      hash_combine(h, e.DATE_DIM_D_DATE_SK);
      hash_combine(h, e.DATE_DIM_D_DATE_ID);
      hash_combine(h, e.DATE_DIM_D_DATE);
      hash_combine(h, e.DATE_DIM_D_MONTH_SEQ);
      hash_combine(h, e.DATE_DIM_D_WEEK_SEQ);
      hash_combine(h, e.DATE_DIM_D_QUARTER_SEQ);
      hash_combine(h, e.DATE_DIM_D_YEAR);
      hash_combine(h, e.DATE_DIM_D_DOW);
      hash_combine(h, e.DATE_DIM_D_MOY);
      hash_combine(h, e.DATE_DIM_D_DOM);
      hash_combine(h, e.DATE_DIM_D_QOY);
      hash_combine(h, e.DATE_DIM_D_FY_YEAR);
      hash_combine(h, e.DATE_DIM_D_FY_QUARTER_SEQ);
      hash_combine(h, e.DATE_DIM_D_FY_WEEK_SEQ);
      hash_combine(h, e.DATE_DIM_D_DAY_NAME);
      hash_combine(h, e.DATE_DIM_D_QUARTER_NAME);
      hash_combine(h, e.DATE_DIM_D_HOLIDAY);
      hash_combine(h, e.DATE_DIM_D_WEEKEND);
      hash_combine(h, e.DATE_DIM_D_FOLLOWING_HOLIDAY);
      hash_combine(h, e.DATE_DIM_D_FIRST_DOM);
      hash_combine(h, e.DATE_DIM_D_LAST_DOM);
      hash_combine(h, e.DATE_DIM_D_SAME_DAY_LY);
      hash_combine(h, e.DATE_DIM_D_SAME_DAY_LQ);
      hash_combine(h, e.DATE_DIM_D_CURRENT_DAY);
      hash_combine(h, e.DATE_DIM_D_CURRENT_WEEK);
      hash_combine(h, e.DATE_DIM_D_CURRENT_MONTH);
      hash_combine(h, e.DATE_DIM_D_CURRENT_QUARTER);
      hash_combine(h, e.DATE_DIM_D_CURRENT_YEAR);
      return h;
    }
    FORCE_INLINE static bool equals(const DATE_DIM_entry& x, const DATE_DIM_entry& y) {
      return x.DATE_DIM_D_DATE_SK == y.DATE_DIM_D_DATE_SK && x.DATE_DIM_D_DATE_ID == y.DATE_DIM_D_DATE_ID && x.DATE_DIM_D_DATE == y.DATE_DIM_D_DATE && x.DATE_DIM_D_MONTH_SEQ == y.DATE_DIM_D_MONTH_SEQ && x.DATE_DIM_D_WEEK_SEQ == y.DATE_DIM_D_WEEK_SEQ && x.DATE_DIM_D_QUARTER_SEQ == y.DATE_DIM_D_QUARTER_SEQ && x.DATE_DIM_D_YEAR == y.DATE_DIM_D_YEAR && x.DATE_DIM_D_DOW == y.DATE_DIM_D_DOW && x.DATE_DIM_D_MOY == y.DATE_DIM_D_MOY && x.DATE_DIM_D_DOM == y.DATE_DIM_D_DOM && x.DATE_DIM_D_QOY == y.DATE_DIM_D_QOY && x.DATE_DIM_D_FY_YEAR == y.DATE_DIM_D_FY_YEAR && x.DATE_DIM_D_FY_QUARTER_SEQ == y.DATE_DIM_D_FY_QUARTER_SEQ && x.DATE_DIM_D_FY_WEEK_SEQ == y.DATE_DIM_D_FY_WEEK_SEQ && x.DATE_DIM_D_DAY_NAME == y.DATE_DIM_D_DAY_NAME && x.DATE_DIM_D_QUARTER_NAME == y.DATE_DIM_D_QUARTER_NAME && x.DATE_DIM_D_HOLIDAY == y.DATE_DIM_D_HOLIDAY && x.DATE_DIM_D_WEEKEND == y.DATE_DIM_D_WEEKEND && x.DATE_DIM_D_FOLLOWING_HOLIDAY == y.DATE_DIM_D_FOLLOWING_HOLIDAY && x.DATE_DIM_D_FIRST_DOM == y.DATE_DIM_D_FIRST_DOM && x.DATE_DIM_D_LAST_DOM == y.DATE_DIM_D_LAST_DOM && x.DATE_DIM_D_SAME_DAY_LY == y.DATE_DIM_D_SAME_DAY_LY && x.DATE_DIM_D_SAME_DAY_LQ == y.DATE_DIM_D_SAME_DAY_LQ && x.DATE_DIM_D_CURRENT_DAY == y.DATE_DIM_D_CURRENT_DAY && x.DATE_DIM_D_CURRENT_WEEK == y.DATE_DIM_D_CURRENT_WEEK && x.DATE_DIM_D_CURRENT_MONTH == y.DATE_DIM_D_CURRENT_MONTH && x.DATE_DIM_D_CURRENT_QUARTER == y.DATE_DIM_D_CURRENT_QUARTER && x.DATE_DIM_D_CURRENT_YEAR == y.DATE_DIM_D_CURRENT_YEAR;
    }
  };
  
  struct DATE_DIM_mapkey68_idxfn {
    FORCE_INLINE static size_t hash(const DATE_DIM_entry& e) {
      size_t h = 0;
      hash_combine(h, e.DATE_DIM_D_YEAR);
      hash_combine(h, e.DATE_DIM_D_MOY);
      return h;
    }
    FORCE_INLINE static bool equals(const DATE_DIM_entry& x, const DATE_DIM_entry& y) {
      return x.DATE_DIM_D_YEAR == y.DATE_DIM_D_YEAR && x.DATE_DIM_D_MOY == y.DATE_DIM_D_MOY;
    }
  };
  
  typedef MultiHashMap<DATE_DIM_entry,long,
    HashIndex<DATE_DIM_entry,long,DATE_DIM_mapkey0123456789101112131415161718192021222324252627_idxfn,true>,
    HashIndex<DATE_DIM_entry,long,DATE_DIM_mapkey68_idxfn,false>
  > DATE_DIM_map;
  typedef HashIndex<DATE_DIM_entry,long,DATE_DIM_mapkey0123456789101112131415161718192021222324252627_idxfn,true> HashIndex_DATE_DIM_map_0123456789101112131415161718192021222324252627;
  typedef HashIndex<DATE_DIM_entry,long,DATE_DIM_mapkey68_idxfn,false> HashIndex_DATE_DIM_map_68;
  
  struct EXT_PRICE_entry {
    long BRAND_ID; STRING_TYPE BRAND; long ITEM_I_MANUFACT_ID; STRING_TYPE ITEM_I_MANUFACT; DOUBLE_TYPE __av; 
    explicit EXT_PRICE_entry() { /*BRAND_ID = 0L; BRAND = ""; ITEM_I_MANUFACT_ID = 0L; ITEM_I_MANUFACT = ""; __av = 0.0; */ }
    explicit EXT_PRICE_entry(const long c0, const STRING_TYPE& c1, const long c2, const STRING_TYPE& c3, const DOUBLE_TYPE c4) { BRAND_ID = c0; BRAND = c1; ITEM_I_MANUFACT_ID = c2; ITEM_I_MANUFACT = c3; __av = c4; }
    EXT_PRICE_entry(const EXT_PRICE_entry& other) : BRAND_ID( other.BRAND_ID ), BRAND( other.BRAND ), ITEM_I_MANUFACT_ID( other.ITEM_I_MANUFACT_ID ), ITEM_I_MANUFACT( other.ITEM_I_MANUFACT ), __av( other.__av ) {}
    FORCE_INLINE EXT_PRICE_entry& modify(const long c0, const STRING_TYPE& c1, const long c2, const STRING_TYPE& c3) { BRAND_ID = c0; BRAND = c1; ITEM_I_MANUFACT_ID = c2; ITEM_I_MANUFACT = c3;  return *this; }
    template<class Archive>
    void serialize(Archive& ar, const unsigned int version) const 
    {
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, BRAND_ID);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, BRAND);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, ITEM_I_MANUFACT_ID);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, ITEM_I_MANUFACT);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, __av);
    }
  };
  struct EXT_PRICE_mapkey0123_idxfn {
    FORCE_INLINE static size_t hash(const EXT_PRICE_entry& e) {
      size_t h = 0;
      hash_combine(h, e.BRAND_ID);
      hash_combine(h, e.BRAND);
      hash_combine(h, e.ITEM_I_MANUFACT_ID);
      hash_combine(h, e.ITEM_I_MANUFACT);
      return h;
    }
    FORCE_INLINE static bool equals(const EXT_PRICE_entry& x, const EXT_PRICE_entry& y) {
      return x.BRAND_ID == y.BRAND_ID && x.BRAND == y.BRAND && x.ITEM_I_MANUFACT_ID == y.ITEM_I_MANUFACT_ID && x.ITEM_I_MANUFACT == y.ITEM_I_MANUFACT;
    }
  };
  
  typedef MultiHashMap<EXT_PRICE_entry,DOUBLE_TYPE,
    HashIndex<EXT_PRICE_entry,DOUBLE_TYPE,EXT_PRICE_mapkey0123_idxfn,true>
  > EXT_PRICE_map;
  typedef HashIndex<EXT_PRICE_entry,DOUBLE_TYPE,EXT_PRICE_mapkey0123_idxfn,true> HashIndex_EXT_PRICE_map_0123;
  
  struct EXT_PRICESTORE1_entry {
    long EXT_PRICESTORESTORE_S_STORE_SK; long ITEM_I_MANUFACT_ID; STRING_TYPE ITEM_I_MANUFACT; STRING_TYPE CUSTOMER_ADDRESS_CA_ZIP; STRING_TYPE BRAND; long BRAND_ID; DOUBLE_TYPE __av; 
    explicit EXT_PRICESTORE1_entry() { /*EXT_PRICESTORESTORE_S_STORE_SK = 0L; ITEM_I_MANUFACT_ID = 0L; ITEM_I_MANUFACT = ""; CUSTOMER_ADDRESS_CA_ZIP = ""; BRAND = ""; BRAND_ID = 0L; __av = 0.0; */ }
    explicit EXT_PRICESTORE1_entry(const long c0, const long c1, const STRING_TYPE& c2, const STRING_TYPE& c3, const STRING_TYPE& c4, const long c5, const DOUBLE_TYPE c6) { EXT_PRICESTORESTORE_S_STORE_SK = c0; ITEM_I_MANUFACT_ID = c1; ITEM_I_MANUFACT = c2; CUSTOMER_ADDRESS_CA_ZIP = c3; BRAND = c4; BRAND_ID = c5; __av = c6; }
    EXT_PRICESTORE1_entry(const EXT_PRICESTORE1_entry& other) : EXT_PRICESTORESTORE_S_STORE_SK( other.EXT_PRICESTORESTORE_S_STORE_SK ), ITEM_I_MANUFACT_ID( other.ITEM_I_MANUFACT_ID ), ITEM_I_MANUFACT( other.ITEM_I_MANUFACT ), CUSTOMER_ADDRESS_CA_ZIP( other.CUSTOMER_ADDRESS_CA_ZIP ), BRAND( other.BRAND ), BRAND_ID( other.BRAND_ID ), __av( other.__av ) {}
    FORCE_INLINE EXT_PRICESTORE1_entry& modify(const long c0, const long c1, const STRING_TYPE& c2, const STRING_TYPE& c3, const STRING_TYPE& c4, const long c5) { EXT_PRICESTORESTORE_S_STORE_SK = c0; ITEM_I_MANUFACT_ID = c1; ITEM_I_MANUFACT = c2; CUSTOMER_ADDRESS_CA_ZIP = c3; BRAND = c4; BRAND_ID = c5;  return *this; }
    FORCE_INLINE EXT_PRICESTORE1_entry& modify0(const long c0) { EXT_PRICESTORESTORE_S_STORE_SK = c0;  return *this; }
    template<class Archive>
    void serialize(Archive& ar, const unsigned int version) const 
    {
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, EXT_PRICESTORESTORE_S_STORE_SK);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, ITEM_I_MANUFACT_ID);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, ITEM_I_MANUFACT);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, CUSTOMER_ADDRESS_CA_ZIP);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, BRAND);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, BRAND_ID);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, __av);
    }
  };
  struct EXT_PRICESTORE1_mapkey012345_idxfn {
    FORCE_INLINE static size_t hash(const EXT_PRICESTORE1_entry& e) {
      size_t h = 0;
      hash_combine(h, e.EXT_PRICESTORESTORE_S_STORE_SK);
      hash_combine(h, e.ITEM_I_MANUFACT_ID);
      hash_combine(h, e.ITEM_I_MANUFACT);
      hash_combine(h, e.CUSTOMER_ADDRESS_CA_ZIP);
      hash_combine(h, e.BRAND);
      hash_combine(h, e.BRAND_ID);
      return h;
    }
    FORCE_INLINE static bool equals(const EXT_PRICESTORE1_entry& x, const EXT_PRICESTORE1_entry& y) {
      return x.EXT_PRICESTORESTORE_S_STORE_SK == y.EXT_PRICESTORESTORE_S_STORE_SK && x.ITEM_I_MANUFACT_ID == y.ITEM_I_MANUFACT_ID && x.ITEM_I_MANUFACT == y.ITEM_I_MANUFACT && x.CUSTOMER_ADDRESS_CA_ZIP == y.CUSTOMER_ADDRESS_CA_ZIP && x.BRAND == y.BRAND && x.BRAND_ID == y.BRAND_ID;
    }
  };
  
  struct EXT_PRICESTORE1_mapkey0_idxfn {
    FORCE_INLINE static size_t hash(const EXT_PRICESTORE1_entry& e) {
      size_t h = 0;
      hash_combine(h, e.EXT_PRICESTORESTORE_S_STORE_SK);
      return h;
    }
    FORCE_INLINE static bool equals(const EXT_PRICESTORE1_entry& x, const EXT_PRICESTORE1_entry& y) {
      return x.EXT_PRICESTORESTORE_S_STORE_SK == y.EXT_PRICESTORESTORE_S_STORE_SK;
    }
  };
  
  typedef MultiHashMap<EXT_PRICESTORE1_entry,DOUBLE_TYPE,
    HashIndex<EXT_PRICESTORE1_entry,DOUBLE_TYPE,EXT_PRICESTORE1_mapkey012345_idxfn,true>,
    HashIndex<EXT_PRICESTORE1_entry,DOUBLE_TYPE,EXT_PRICESTORE1_mapkey0_idxfn,false>
  > EXT_PRICESTORE1_map;
  typedef HashIndex<EXT_PRICESTORE1_entry,DOUBLE_TYPE,EXT_PRICESTORE1_mapkey012345_idxfn,true> HashIndex_EXT_PRICESTORE1_map_012345;
  typedef HashIndex<EXT_PRICESTORE1_entry,DOUBLE_TYPE,EXT_PRICESTORE1_mapkey0_idxfn,false> HashIndex_EXT_PRICESTORE1_map_0;
  
  struct EXT_PRICESTORE1CUSTOMER_ADDRESS1_entry {
    long EXT_PRICESTORE1CUSTOMER_ADDRESSCUSTOMER_ADDRESS_CA_ADDRESS_SK; long EXT_PRICESTORESTORE_S_STORE_SK; long ITEM_I_MANUFACT_ID; STRING_TYPE ITEM_I_MANUFACT; STRING_TYPE BRAND; long BRAND_ID; DOUBLE_TYPE __av; 
    explicit EXT_PRICESTORE1CUSTOMER_ADDRESS1_entry() { /*EXT_PRICESTORE1CUSTOMER_ADDRESSCUSTOMER_ADDRESS_CA_ADDRESS_SK = 0L; EXT_PRICESTORESTORE_S_STORE_SK = 0L; ITEM_I_MANUFACT_ID = 0L; ITEM_I_MANUFACT = ""; BRAND = ""; BRAND_ID = 0L; __av = 0.0; */ }
    explicit EXT_PRICESTORE1CUSTOMER_ADDRESS1_entry(const long c0, const long c1, const long c2, const STRING_TYPE& c3, const STRING_TYPE& c4, const long c5, const DOUBLE_TYPE c6) { EXT_PRICESTORE1CUSTOMER_ADDRESSCUSTOMER_ADDRESS_CA_ADDRESS_SK = c0; EXT_PRICESTORESTORE_S_STORE_SK = c1; ITEM_I_MANUFACT_ID = c2; ITEM_I_MANUFACT = c3; BRAND = c4; BRAND_ID = c5; __av = c6; }
    EXT_PRICESTORE1CUSTOMER_ADDRESS1_entry(const EXT_PRICESTORE1CUSTOMER_ADDRESS1_entry& other) : EXT_PRICESTORE1CUSTOMER_ADDRESSCUSTOMER_ADDRESS_CA_ADDRESS_SK( other.EXT_PRICESTORE1CUSTOMER_ADDRESSCUSTOMER_ADDRESS_CA_ADDRESS_SK ), EXT_PRICESTORESTORE_S_STORE_SK( other.EXT_PRICESTORESTORE_S_STORE_SK ), ITEM_I_MANUFACT_ID( other.ITEM_I_MANUFACT_ID ), ITEM_I_MANUFACT( other.ITEM_I_MANUFACT ), BRAND( other.BRAND ), BRAND_ID( other.BRAND_ID ), __av( other.__av ) {}
    FORCE_INLINE EXT_PRICESTORE1CUSTOMER_ADDRESS1_entry& modify(const long c0, const long c1, const long c2, const STRING_TYPE& c3, const STRING_TYPE& c4, const long c5) { EXT_PRICESTORE1CUSTOMER_ADDRESSCUSTOMER_ADDRESS_CA_ADDRESS_SK = c0; EXT_PRICESTORESTORE_S_STORE_SK = c1; ITEM_I_MANUFACT_ID = c2; ITEM_I_MANUFACT = c3; BRAND = c4; BRAND_ID = c5;  return *this; }
    FORCE_INLINE EXT_PRICESTORE1CUSTOMER_ADDRESS1_entry& modify0(const long c0) { EXT_PRICESTORE1CUSTOMER_ADDRESSCUSTOMER_ADDRESS_CA_ADDRESS_SK = c0;  return *this; }
    FORCE_INLINE EXT_PRICESTORE1CUSTOMER_ADDRESS1_entry& modify1(const long c1) { EXT_PRICESTORESTORE_S_STORE_SK = c1;  return *this; }
    template<class Archive>
    void serialize(Archive& ar, const unsigned int version) const 
    {
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, EXT_PRICESTORE1CUSTOMER_ADDRESSCUSTOMER_ADDRESS_CA_ADDRESS_SK);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, EXT_PRICESTORESTORE_S_STORE_SK);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, ITEM_I_MANUFACT_ID);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, ITEM_I_MANUFACT);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, BRAND);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, BRAND_ID);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, __av);
    }
  };
  struct EXT_PRICESTORE1CUSTOMER_ADDRESS1_mapkey012345_idxfn {
    FORCE_INLINE static size_t hash(const EXT_PRICESTORE1CUSTOMER_ADDRESS1_entry& e) {
      size_t h = 0;
      hash_combine(h, e.EXT_PRICESTORE1CUSTOMER_ADDRESSCUSTOMER_ADDRESS_CA_ADDRESS_SK);
      hash_combine(h, e.EXT_PRICESTORESTORE_S_STORE_SK);
      hash_combine(h, e.ITEM_I_MANUFACT_ID);
      hash_combine(h, e.ITEM_I_MANUFACT);
      hash_combine(h, e.BRAND);
      hash_combine(h, e.BRAND_ID);
      return h;
    }
    FORCE_INLINE static bool equals(const EXT_PRICESTORE1CUSTOMER_ADDRESS1_entry& x, const EXT_PRICESTORE1CUSTOMER_ADDRESS1_entry& y) {
      return x.EXT_PRICESTORE1CUSTOMER_ADDRESSCUSTOMER_ADDRESS_CA_ADDRESS_SK == y.EXT_PRICESTORE1CUSTOMER_ADDRESSCUSTOMER_ADDRESS_CA_ADDRESS_SK && x.EXT_PRICESTORESTORE_S_STORE_SK == y.EXT_PRICESTORESTORE_S_STORE_SK && x.ITEM_I_MANUFACT_ID == y.ITEM_I_MANUFACT_ID && x.ITEM_I_MANUFACT == y.ITEM_I_MANUFACT && x.BRAND == y.BRAND && x.BRAND_ID == y.BRAND_ID;
    }
  };
  
  struct EXT_PRICESTORE1CUSTOMER_ADDRESS1_mapkey0_idxfn {
    FORCE_INLINE static size_t hash(const EXT_PRICESTORE1CUSTOMER_ADDRESS1_entry& e) {
      size_t h = 0;
      hash_combine(h, e.EXT_PRICESTORE1CUSTOMER_ADDRESSCUSTOMER_ADDRESS_CA_ADDRESS_SK);
      return h;
    }
    FORCE_INLINE static bool equals(const EXT_PRICESTORE1CUSTOMER_ADDRESS1_entry& x, const EXT_PRICESTORE1CUSTOMER_ADDRESS1_entry& y) {
      return x.EXT_PRICESTORE1CUSTOMER_ADDRESSCUSTOMER_ADDRESS_CA_ADDRESS_SK == y.EXT_PRICESTORE1CUSTOMER_ADDRESSCUSTOMER_ADDRESS_CA_ADDRESS_SK;
    }
  };
  
  struct EXT_PRICESTORE1CUSTOMER_ADDRESS1_mapkey1_idxfn {
    FORCE_INLINE static size_t hash(const EXT_PRICESTORE1CUSTOMER_ADDRESS1_entry& e) {
      size_t h = 0;
      hash_combine(h, e.EXT_PRICESTORESTORE_S_STORE_SK);
      return h;
    }
    FORCE_INLINE static bool equals(const EXT_PRICESTORE1CUSTOMER_ADDRESS1_entry& x, const EXT_PRICESTORE1CUSTOMER_ADDRESS1_entry& y) {
      return x.EXT_PRICESTORESTORE_S_STORE_SK == y.EXT_PRICESTORESTORE_S_STORE_SK;
    }
  };
  
  typedef MultiHashMap<EXT_PRICESTORE1CUSTOMER_ADDRESS1_entry,DOUBLE_TYPE,
    HashIndex<EXT_PRICESTORE1CUSTOMER_ADDRESS1_entry,DOUBLE_TYPE,EXT_PRICESTORE1CUSTOMER_ADDRESS1_mapkey012345_idxfn,true>,
    HashIndex<EXT_PRICESTORE1CUSTOMER_ADDRESS1_entry,DOUBLE_TYPE,EXT_PRICESTORE1CUSTOMER_ADDRESS1_mapkey0_idxfn,false>,
    HashIndex<EXT_PRICESTORE1CUSTOMER_ADDRESS1_entry,DOUBLE_TYPE,EXT_PRICESTORE1CUSTOMER_ADDRESS1_mapkey1_idxfn,false>
  > EXT_PRICESTORE1CUSTOMER_ADDRESS1_map;
  typedef HashIndex<EXT_PRICESTORE1CUSTOMER_ADDRESS1_entry,DOUBLE_TYPE,EXT_PRICESTORE1CUSTOMER_ADDRESS1_mapkey012345_idxfn,true> HashIndex_EXT_PRICESTORE1CUSTOMER_ADDRESS1_map_012345;
  typedef HashIndex<EXT_PRICESTORE1CUSTOMER_ADDRESS1_entry,DOUBLE_TYPE,EXT_PRICESTORE1CUSTOMER_ADDRESS1_mapkey0_idxfn,false> HashIndex_EXT_PRICESTORE1CUSTOMER_ADDRESS1_map_0;
  typedef HashIndex<EXT_PRICESTORE1CUSTOMER_ADDRESS1_entry,DOUBLE_TYPE,EXT_PRICESTORE1CUSTOMER_ADDRESS1_mapkey1_idxfn,false> HashIndex_EXT_PRICESTORE1CUSTOMER_ADDRESS1_map_1;
  
  struct EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2_entry {
    long EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEMITEM_I_ITEM_SK; long EXT_PRICESTORESTORE_S_STORE_SK; long EXT_PRICESTORE1CUSTOMER_ADDRESSCUSTOMER_ADDRESS_CA_ADDRESS_SK; DOUBLE_TYPE __av; 
    explicit EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2_entry() { /*EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEMITEM_I_ITEM_SK = 0L; EXT_PRICESTORESTORE_S_STORE_SK = 0L; EXT_PRICESTORE1CUSTOMER_ADDRESSCUSTOMER_ADDRESS_CA_ADDRESS_SK = 0L; __av = 0.0; */ }
    explicit EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2_entry(const long c0, const long c1, const long c2, const DOUBLE_TYPE c3) { EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEMITEM_I_ITEM_SK = c0; EXT_PRICESTORESTORE_S_STORE_SK = c1; EXT_PRICESTORE1CUSTOMER_ADDRESSCUSTOMER_ADDRESS_CA_ADDRESS_SK = c2; __av = c3; }
    EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2_entry(const EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2_entry& other) : EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEMITEM_I_ITEM_SK( other.EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEMITEM_I_ITEM_SK ), EXT_PRICESTORESTORE_S_STORE_SK( other.EXT_PRICESTORESTORE_S_STORE_SK ), EXT_PRICESTORE1CUSTOMER_ADDRESSCUSTOMER_ADDRESS_CA_ADDRESS_SK( other.EXT_PRICESTORE1CUSTOMER_ADDRESSCUSTOMER_ADDRESS_CA_ADDRESS_SK ), __av( other.__av ) {}
    FORCE_INLINE EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2_entry& modify(const long c0, const long c1, const long c2) { EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEMITEM_I_ITEM_SK = c0; EXT_PRICESTORESTORE_S_STORE_SK = c1; EXT_PRICESTORE1CUSTOMER_ADDRESSCUSTOMER_ADDRESS_CA_ADDRESS_SK = c2;  return *this; }
    FORCE_INLINE EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2_entry& modify0(const long c0) { EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEMITEM_I_ITEM_SK = c0;  return *this; }
    FORCE_INLINE EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2_entry& modify2(const long c2) { EXT_PRICESTORE1CUSTOMER_ADDRESSCUSTOMER_ADDRESS_CA_ADDRESS_SK = c2;  return *this; }
    FORCE_INLINE EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2_entry& modify1(const long c1) { EXT_PRICESTORESTORE_S_STORE_SK = c1;  return *this; }
    template<class Archive>
    void serialize(Archive& ar, const unsigned int version) const 
    {
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEMITEM_I_ITEM_SK);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, EXT_PRICESTORESTORE_S_STORE_SK);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, EXT_PRICESTORE1CUSTOMER_ADDRESSCUSTOMER_ADDRESS_CA_ADDRESS_SK);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, __av);
    }
  };
  struct EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2_mapkey012_idxfn {
    FORCE_INLINE static size_t hash(const EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2_entry& e) {
      size_t h = 0;
      hash_combine(h, e.EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEMITEM_I_ITEM_SK);
      hash_combine(h, e.EXT_PRICESTORESTORE_S_STORE_SK);
      hash_combine(h, e.EXT_PRICESTORE1CUSTOMER_ADDRESSCUSTOMER_ADDRESS_CA_ADDRESS_SK);
      return h;
    }
    FORCE_INLINE static bool equals(const EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2_entry& x, const EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2_entry& y) {
      return x.EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEMITEM_I_ITEM_SK == y.EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEMITEM_I_ITEM_SK && x.EXT_PRICESTORESTORE_S_STORE_SK == y.EXT_PRICESTORESTORE_S_STORE_SK && x.EXT_PRICESTORE1CUSTOMER_ADDRESSCUSTOMER_ADDRESS_CA_ADDRESS_SK == y.EXT_PRICESTORE1CUSTOMER_ADDRESSCUSTOMER_ADDRESS_CA_ADDRESS_SK;
    }
  };
  
  struct EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2_mapkey0_idxfn {
    FORCE_INLINE static size_t hash(const EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2_entry& e) {
      size_t h = 0;
      hash_combine(h, e.EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEMITEM_I_ITEM_SK);
      return h;
    }
    FORCE_INLINE static bool equals(const EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2_entry& x, const EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2_entry& y) {
      return x.EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEMITEM_I_ITEM_SK == y.EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEMITEM_I_ITEM_SK;
    }
  };
  
  struct EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2_mapkey2_idxfn {
    FORCE_INLINE static size_t hash(const EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2_entry& e) {
      size_t h = 0;
      hash_combine(h, e.EXT_PRICESTORE1CUSTOMER_ADDRESSCUSTOMER_ADDRESS_CA_ADDRESS_SK);
      return h;
    }
    FORCE_INLINE static bool equals(const EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2_entry& x, const EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2_entry& y) {
      return x.EXT_PRICESTORE1CUSTOMER_ADDRESSCUSTOMER_ADDRESS_CA_ADDRESS_SK == y.EXT_PRICESTORE1CUSTOMER_ADDRESSCUSTOMER_ADDRESS_CA_ADDRESS_SK;
    }
  };
  
  struct EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2_mapkey1_idxfn {
    FORCE_INLINE static size_t hash(const EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2_entry& e) {
      size_t h = 0;
      hash_combine(h, e.EXT_PRICESTORESTORE_S_STORE_SK);
      return h;
    }
    FORCE_INLINE static bool equals(const EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2_entry& x, const EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2_entry& y) {
      return x.EXT_PRICESTORESTORE_S_STORE_SK == y.EXT_PRICESTORESTORE_S_STORE_SK;
    }
  };
  
  typedef MultiHashMap<EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2_entry,DOUBLE_TYPE,
    HashIndex<EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2_entry,DOUBLE_TYPE,EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2_mapkey012_idxfn,true>,
    HashIndex<EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2_entry,DOUBLE_TYPE,EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2_mapkey0_idxfn,false>,
    HashIndex<EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2_entry,DOUBLE_TYPE,EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2_mapkey2_idxfn,false>,
    HashIndex<EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2_entry,DOUBLE_TYPE,EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2_mapkey1_idxfn,false>
  > EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2_map;
  typedef HashIndex<EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2_entry,DOUBLE_TYPE,EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2_mapkey012_idxfn,true> HashIndex_EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2_map_012;
  typedef HashIndex<EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2_entry,DOUBLE_TYPE,EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2_mapkey0_idxfn,false> HashIndex_EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2_map_0;
  typedef HashIndex<EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2_entry,DOUBLE_TYPE,EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2_mapkey2_idxfn,false> HashIndex_EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2_map_2;
  typedef HashIndex<EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2_entry,DOUBLE_TYPE,EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2_mapkey1_idxfn,false> HashIndex_EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2_map_1;
  
  struct EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2CUSTOMER1_entry {
    long EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEMITEM_I_ITEM_SK; long EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2CUSTOMERCUSTOMER_C_CUSTOMER_SK; long EXT_PRICESTORESTORE_S_STORE_SK; DOUBLE_TYPE __av; 
    explicit EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2CUSTOMER1_entry() { /*EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEMITEM_I_ITEM_SK = 0L; EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2CUSTOMERCUSTOMER_C_CUSTOMER_SK = 0L; EXT_PRICESTORESTORE_S_STORE_SK = 0L; __av = 0.0; */ }
    explicit EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2CUSTOMER1_entry(const long c0, const long c1, const long c2, const DOUBLE_TYPE c3) { EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEMITEM_I_ITEM_SK = c0; EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2CUSTOMERCUSTOMER_C_CUSTOMER_SK = c1; EXT_PRICESTORESTORE_S_STORE_SK = c2; __av = c3; }
    EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2CUSTOMER1_entry(const EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2CUSTOMER1_entry& other) : EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEMITEM_I_ITEM_SK( other.EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEMITEM_I_ITEM_SK ), EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2CUSTOMERCUSTOMER_C_CUSTOMER_SK( other.EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2CUSTOMERCUSTOMER_C_CUSTOMER_SK ), EXT_PRICESTORESTORE_S_STORE_SK( other.EXT_PRICESTORESTORE_S_STORE_SK ), __av( other.__av ) {}
    FORCE_INLINE EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2CUSTOMER1_entry& modify(const long c0, const long c1, const long c2) { EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEMITEM_I_ITEM_SK = c0; EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2CUSTOMERCUSTOMER_C_CUSTOMER_SK = c1; EXT_PRICESTORESTORE_S_STORE_SK = c2;  return *this; }
    FORCE_INLINE EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2CUSTOMER1_entry& modify0(const long c0) { EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEMITEM_I_ITEM_SK = c0;  return *this; }
    FORCE_INLINE EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2CUSTOMER1_entry& modify1(const long c1) { EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2CUSTOMERCUSTOMER_C_CUSTOMER_SK = c1;  return *this; }
    FORCE_INLINE EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2CUSTOMER1_entry& modify2(const long c2) { EXT_PRICESTORESTORE_S_STORE_SK = c2;  return *this; }
    template<class Archive>
    void serialize(Archive& ar, const unsigned int version) const 
    {
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEMITEM_I_ITEM_SK);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2CUSTOMERCUSTOMER_C_CUSTOMER_SK);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, EXT_PRICESTORESTORE_S_STORE_SK);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, __av);
    }
  };
  struct EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2CUSTOMER1_mapkey012_idxfn {
    FORCE_INLINE static size_t hash(const EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2CUSTOMER1_entry& e) {
      size_t h = 0;
      hash_combine(h, e.EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEMITEM_I_ITEM_SK);
      hash_combine(h, e.EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2CUSTOMERCUSTOMER_C_CUSTOMER_SK);
      hash_combine(h, e.EXT_PRICESTORESTORE_S_STORE_SK);
      return h;
    }
    FORCE_INLINE static bool equals(const EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2CUSTOMER1_entry& x, const EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2CUSTOMER1_entry& y) {
      return x.EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEMITEM_I_ITEM_SK == y.EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEMITEM_I_ITEM_SK && x.EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2CUSTOMERCUSTOMER_C_CUSTOMER_SK == y.EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2CUSTOMERCUSTOMER_C_CUSTOMER_SK && x.EXT_PRICESTORESTORE_S_STORE_SK == y.EXT_PRICESTORESTORE_S_STORE_SK;
    }
  };
  
  struct EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2CUSTOMER1_mapkey0_idxfn {
    FORCE_INLINE static size_t hash(const EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2CUSTOMER1_entry& e) {
      size_t h = 0;
      hash_combine(h, e.EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEMITEM_I_ITEM_SK);
      return h;
    }
    FORCE_INLINE static bool equals(const EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2CUSTOMER1_entry& x, const EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2CUSTOMER1_entry& y) {
      return x.EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEMITEM_I_ITEM_SK == y.EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEMITEM_I_ITEM_SK;
    }
  };
  
  struct EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2CUSTOMER1_mapkey1_idxfn {
    FORCE_INLINE static size_t hash(const EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2CUSTOMER1_entry& e) {
      size_t h = 0;
      hash_combine(h, e.EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2CUSTOMERCUSTOMER_C_CUSTOMER_SK);
      return h;
    }
    FORCE_INLINE static bool equals(const EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2CUSTOMER1_entry& x, const EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2CUSTOMER1_entry& y) {
      return x.EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2CUSTOMERCUSTOMER_C_CUSTOMER_SK == y.EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2CUSTOMERCUSTOMER_C_CUSTOMER_SK;
    }
  };
  
  struct EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2CUSTOMER1_mapkey2_idxfn {
    FORCE_INLINE static size_t hash(const EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2CUSTOMER1_entry& e) {
      size_t h = 0;
      hash_combine(h, e.EXT_PRICESTORESTORE_S_STORE_SK);
      return h;
    }
    FORCE_INLINE static bool equals(const EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2CUSTOMER1_entry& x, const EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2CUSTOMER1_entry& y) {
      return x.EXT_PRICESTORESTORE_S_STORE_SK == y.EXT_PRICESTORESTORE_S_STORE_SK;
    }
  };
  
  typedef MultiHashMap<EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2CUSTOMER1_entry,DOUBLE_TYPE,
    HashIndex<EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2CUSTOMER1_entry,DOUBLE_TYPE,EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2CUSTOMER1_mapkey012_idxfn,true>,
    HashIndex<EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2CUSTOMER1_entry,DOUBLE_TYPE,EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2CUSTOMER1_mapkey0_idxfn,false>,
    HashIndex<EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2CUSTOMER1_entry,DOUBLE_TYPE,EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2CUSTOMER1_mapkey1_idxfn,false>,
    HashIndex<EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2CUSTOMER1_entry,DOUBLE_TYPE,EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2CUSTOMER1_mapkey2_idxfn,false>
  > EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2CUSTOMER1_map;
  typedef HashIndex<EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2CUSTOMER1_entry,DOUBLE_TYPE,EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2CUSTOMER1_mapkey012_idxfn,true> HashIndex_EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2CUSTOMER1_map_012;
  typedef HashIndex<EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2CUSTOMER1_entry,DOUBLE_TYPE,EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2CUSTOMER1_mapkey0_idxfn,false> HashIndex_EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2CUSTOMER1_map_0;
  typedef HashIndex<EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2CUSTOMER1_entry,DOUBLE_TYPE,EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2CUSTOMER1_mapkey1_idxfn,false> HashIndex_EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2CUSTOMER1_map_1;
  typedef HashIndex<EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2CUSTOMER1_entry,DOUBLE_TYPE,EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2CUSTOMER1_mapkey2_idxfn,false> HashIndex_EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2CUSTOMER1_map_2;
  
  struct EXT_PRICESTORE1CUSTOMER_ADDRESS1STORE_SALES2_entry {
    long EXT_PRICESTORE1CUSTOMER_ADDRESS1STORE_SALESSTORE_SALES_SS_ITEM_SK; long ITEM_I_MANUFACT_ID; STRING_TYPE ITEM_I_MANUFACT; long BRAND_ID; STRING_TYPE BRAND; long __av; 
    explicit EXT_PRICESTORE1CUSTOMER_ADDRESS1STORE_SALES2_entry() { /*EXT_PRICESTORE1CUSTOMER_ADDRESS1STORE_SALESSTORE_SALES_SS_ITEM_SK = 0L; ITEM_I_MANUFACT_ID = 0L; ITEM_I_MANUFACT = ""; BRAND_ID = 0L; BRAND = ""; __av = 0L; */ }
    explicit EXT_PRICESTORE1CUSTOMER_ADDRESS1STORE_SALES2_entry(const long c0, const long c1, const STRING_TYPE& c2, const long c3, const STRING_TYPE& c4, const long c5) { EXT_PRICESTORE1CUSTOMER_ADDRESS1STORE_SALESSTORE_SALES_SS_ITEM_SK = c0; ITEM_I_MANUFACT_ID = c1; ITEM_I_MANUFACT = c2; BRAND_ID = c3; BRAND = c4; __av = c5; }
    EXT_PRICESTORE1CUSTOMER_ADDRESS1STORE_SALES2_entry(const EXT_PRICESTORE1CUSTOMER_ADDRESS1STORE_SALES2_entry& other) : EXT_PRICESTORE1CUSTOMER_ADDRESS1STORE_SALESSTORE_SALES_SS_ITEM_SK( other.EXT_PRICESTORE1CUSTOMER_ADDRESS1STORE_SALESSTORE_SALES_SS_ITEM_SK ), ITEM_I_MANUFACT_ID( other.ITEM_I_MANUFACT_ID ), ITEM_I_MANUFACT( other.ITEM_I_MANUFACT ), BRAND_ID( other.BRAND_ID ), BRAND( other.BRAND ), __av( other.__av ) {}
    FORCE_INLINE EXT_PRICESTORE1CUSTOMER_ADDRESS1STORE_SALES2_entry& modify(const long c0, const long c1, const STRING_TYPE& c2, const long c3, const STRING_TYPE& c4) { EXT_PRICESTORE1CUSTOMER_ADDRESS1STORE_SALESSTORE_SALES_SS_ITEM_SK = c0; ITEM_I_MANUFACT_ID = c1; ITEM_I_MANUFACT = c2; BRAND_ID = c3; BRAND = c4;  return *this; }
    FORCE_INLINE EXT_PRICESTORE1CUSTOMER_ADDRESS1STORE_SALES2_entry& modify0(const long c0) { EXT_PRICESTORE1CUSTOMER_ADDRESS1STORE_SALESSTORE_SALES_SS_ITEM_SK = c0;  return *this; }
    template<class Archive>
    void serialize(Archive& ar, const unsigned int version) const 
    {
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, EXT_PRICESTORE1CUSTOMER_ADDRESS1STORE_SALESSTORE_SALES_SS_ITEM_SK);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, ITEM_I_MANUFACT_ID);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, ITEM_I_MANUFACT);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, BRAND_ID);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, BRAND);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, __av);
    }
  };
  struct EXT_PRICESTORE1CUSTOMER_ADDRESS1STORE_SALES2_mapkey01234_idxfn {
    FORCE_INLINE static size_t hash(const EXT_PRICESTORE1CUSTOMER_ADDRESS1STORE_SALES2_entry& e) {
      size_t h = 0;
      hash_combine(h, e.EXT_PRICESTORE1CUSTOMER_ADDRESS1STORE_SALESSTORE_SALES_SS_ITEM_SK);
      hash_combine(h, e.ITEM_I_MANUFACT_ID);
      hash_combine(h, e.ITEM_I_MANUFACT);
      hash_combine(h, e.BRAND_ID);
      hash_combine(h, e.BRAND);
      return h;
    }
    FORCE_INLINE static bool equals(const EXT_PRICESTORE1CUSTOMER_ADDRESS1STORE_SALES2_entry& x, const EXT_PRICESTORE1CUSTOMER_ADDRESS1STORE_SALES2_entry& y) {
      return x.EXT_PRICESTORE1CUSTOMER_ADDRESS1STORE_SALESSTORE_SALES_SS_ITEM_SK == y.EXT_PRICESTORE1CUSTOMER_ADDRESS1STORE_SALESSTORE_SALES_SS_ITEM_SK && x.ITEM_I_MANUFACT_ID == y.ITEM_I_MANUFACT_ID && x.ITEM_I_MANUFACT == y.ITEM_I_MANUFACT && x.BRAND_ID == y.BRAND_ID && x.BRAND == y.BRAND;
    }
  };
  
  struct EXT_PRICESTORE1CUSTOMER_ADDRESS1STORE_SALES2_mapkey0_idxfn {
    FORCE_INLINE static size_t hash(const EXT_PRICESTORE1CUSTOMER_ADDRESS1STORE_SALES2_entry& e) {
      size_t h = 0;
      hash_combine(h, e.EXT_PRICESTORE1CUSTOMER_ADDRESS1STORE_SALESSTORE_SALES_SS_ITEM_SK);
      return h;
    }
    FORCE_INLINE static bool equals(const EXT_PRICESTORE1CUSTOMER_ADDRESS1STORE_SALES2_entry& x, const EXT_PRICESTORE1CUSTOMER_ADDRESS1STORE_SALES2_entry& y) {
      return x.EXT_PRICESTORE1CUSTOMER_ADDRESS1STORE_SALESSTORE_SALES_SS_ITEM_SK == y.EXT_PRICESTORE1CUSTOMER_ADDRESS1STORE_SALESSTORE_SALES_SS_ITEM_SK;
    }
  };
  
  typedef MultiHashMap<EXT_PRICESTORE1CUSTOMER_ADDRESS1STORE_SALES2_entry,long,
    HashIndex<EXT_PRICESTORE1CUSTOMER_ADDRESS1STORE_SALES2_entry,long,EXT_PRICESTORE1CUSTOMER_ADDRESS1STORE_SALES2_mapkey01234_idxfn,true>,
    HashIndex<EXT_PRICESTORE1CUSTOMER_ADDRESS1STORE_SALES2_entry,long,EXT_PRICESTORE1CUSTOMER_ADDRESS1STORE_SALES2_mapkey0_idxfn,false>
  > EXT_PRICESTORE1CUSTOMER_ADDRESS1STORE_SALES2_map;
  typedef HashIndex<EXT_PRICESTORE1CUSTOMER_ADDRESS1STORE_SALES2_entry,long,EXT_PRICESTORE1CUSTOMER_ADDRESS1STORE_SALES2_mapkey01234_idxfn,true> HashIndex_EXT_PRICESTORE1CUSTOMER_ADDRESS1STORE_SALES2_map_01234;
  typedef HashIndex<EXT_PRICESTORE1CUSTOMER_ADDRESS1STORE_SALES2_entry,long,EXT_PRICESTORE1CUSTOMER_ADDRESS1STORE_SALES2_mapkey0_idxfn,false> HashIndex_EXT_PRICESTORE1CUSTOMER_ADDRESS1STORE_SALES2_map_0;
  
  struct EXT_PRICESTORE1CUSTOMER_ADDRESS1STORE_SALES3_entry {
    long EXT_PRICESTORE1CUSTOMER_ADDRESS1STORE_SALESSTORE_SALES_SS_CUSTOMER_SK; long EXT_PRICESTORE1CUSTOMER_ADDRESSCUSTOMER_ADDRESS_CA_ADDRESS_SK; long __av; 
    explicit EXT_PRICESTORE1CUSTOMER_ADDRESS1STORE_SALES3_entry() { /*EXT_PRICESTORE1CUSTOMER_ADDRESS1STORE_SALESSTORE_SALES_SS_CUSTOMER_SK = 0L; EXT_PRICESTORE1CUSTOMER_ADDRESSCUSTOMER_ADDRESS_CA_ADDRESS_SK = 0L; __av = 0L; */ }
    explicit EXT_PRICESTORE1CUSTOMER_ADDRESS1STORE_SALES3_entry(const long c0, const long c1, const long c2) { EXT_PRICESTORE1CUSTOMER_ADDRESS1STORE_SALESSTORE_SALES_SS_CUSTOMER_SK = c0; EXT_PRICESTORE1CUSTOMER_ADDRESSCUSTOMER_ADDRESS_CA_ADDRESS_SK = c1; __av = c2; }
    EXT_PRICESTORE1CUSTOMER_ADDRESS1STORE_SALES3_entry(const EXT_PRICESTORE1CUSTOMER_ADDRESS1STORE_SALES3_entry& other) : EXT_PRICESTORE1CUSTOMER_ADDRESS1STORE_SALESSTORE_SALES_SS_CUSTOMER_SK( other.EXT_PRICESTORE1CUSTOMER_ADDRESS1STORE_SALESSTORE_SALES_SS_CUSTOMER_SK ), EXT_PRICESTORE1CUSTOMER_ADDRESSCUSTOMER_ADDRESS_CA_ADDRESS_SK( other.EXT_PRICESTORE1CUSTOMER_ADDRESSCUSTOMER_ADDRESS_CA_ADDRESS_SK ), __av( other.__av ) {}
    FORCE_INLINE EXT_PRICESTORE1CUSTOMER_ADDRESS1STORE_SALES3_entry& modify(const long c0, const long c1) { EXT_PRICESTORE1CUSTOMER_ADDRESS1STORE_SALESSTORE_SALES_SS_CUSTOMER_SK = c0; EXT_PRICESTORE1CUSTOMER_ADDRESSCUSTOMER_ADDRESS_CA_ADDRESS_SK = c1;  return *this; }
    FORCE_INLINE EXT_PRICESTORE1CUSTOMER_ADDRESS1STORE_SALES3_entry& modify0(const long c0) { EXT_PRICESTORE1CUSTOMER_ADDRESS1STORE_SALESSTORE_SALES_SS_CUSTOMER_SK = c0;  return *this; }
    FORCE_INLINE EXT_PRICESTORE1CUSTOMER_ADDRESS1STORE_SALES3_entry& modify1(const long c1) { EXT_PRICESTORE1CUSTOMER_ADDRESSCUSTOMER_ADDRESS_CA_ADDRESS_SK = c1;  return *this; }
    template<class Archive>
    void serialize(Archive& ar, const unsigned int version) const 
    {
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, EXT_PRICESTORE1CUSTOMER_ADDRESS1STORE_SALESSTORE_SALES_SS_CUSTOMER_SK);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, EXT_PRICESTORE1CUSTOMER_ADDRESSCUSTOMER_ADDRESS_CA_ADDRESS_SK);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, __av);
    }
  };
  struct EXT_PRICESTORE1CUSTOMER_ADDRESS1STORE_SALES3_mapkey01_idxfn {
    FORCE_INLINE static size_t hash(const EXT_PRICESTORE1CUSTOMER_ADDRESS1STORE_SALES3_entry& e) {
      size_t h = 0;
      hash_combine(h, e.EXT_PRICESTORE1CUSTOMER_ADDRESS1STORE_SALESSTORE_SALES_SS_CUSTOMER_SK);
      hash_combine(h, e.EXT_PRICESTORE1CUSTOMER_ADDRESSCUSTOMER_ADDRESS_CA_ADDRESS_SK);
      return h;
    }
    FORCE_INLINE static bool equals(const EXT_PRICESTORE1CUSTOMER_ADDRESS1STORE_SALES3_entry& x, const EXT_PRICESTORE1CUSTOMER_ADDRESS1STORE_SALES3_entry& y) {
      return x.EXT_PRICESTORE1CUSTOMER_ADDRESS1STORE_SALESSTORE_SALES_SS_CUSTOMER_SK == y.EXT_PRICESTORE1CUSTOMER_ADDRESS1STORE_SALESSTORE_SALES_SS_CUSTOMER_SK && x.EXT_PRICESTORE1CUSTOMER_ADDRESSCUSTOMER_ADDRESS_CA_ADDRESS_SK == y.EXT_PRICESTORE1CUSTOMER_ADDRESSCUSTOMER_ADDRESS_CA_ADDRESS_SK;
    }
  };
  
  struct EXT_PRICESTORE1CUSTOMER_ADDRESS1STORE_SALES3_mapkey0_idxfn {
    FORCE_INLINE static size_t hash(const EXT_PRICESTORE1CUSTOMER_ADDRESS1STORE_SALES3_entry& e) {
      size_t h = 0;
      hash_combine(h, e.EXT_PRICESTORE1CUSTOMER_ADDRESS1STORE_SALESSTORE_SALES_SS_CUSTOMER_SK);
      return h;
    }
    FORCE_INLINE static bool equals(const EXT_PRICESTORE1CUSTOMER_ADDRESS1STORE_SALES3_entry& x, const EXT_PRICESTORE1CUSTOMER_ADDRESS1STORE_SALES3_entry& y) {
      return x.EXT_PRICESTORE1CUSTOMER_ADDRESS1STORE_SALESSTORE_SALES_SS_CUSTOMER_SK == y.EXT_PRICESTORE1CUSTOMER_ADDRESS1STORE_SALESSTORE_SALES_SS_CUSTOMER_SK;
    }
  };
  
  struct EXT_PRICESTORE1CUSTOMER_ADDRESS1STORE_SALES3_mapkey1_idxfn {
    FORCE_INLINE static size_t hash(const EXT_PRICESTORE1CUSTOMER_ADDRESS1STORE_SALES3_entry& e) {
      size_t h = 0;
      hash_combine(h, e.EXT_PRICESTORE1CUSTOMER_ADDRESSCUSTOMER_ADDRESS_CA_ADDRESS_SK);
      return h;
    }
    FORCE_INLINE static bool equals(const EXT_PRICESTORE1CUSTOMER_ADDRESS1STORE_SALES3_entry& x, const EXT_PRICESTORE1CUSTOMER_ADDRESS1STORE_SALES3_entry& y) {
      return x.EXT_PRICESTORE1CUSTOMER_ADDRESSCUSTOMER_ADDRESS_CA_ADDRESS_SK == y.EXT_PRICESTORE1CUSTOMER_ADDRESSCUSTOMER_ADDRESS_CA_ADDRESS_SK;
    }
  };
  
  typedef MultiHashMap<EXT_PRICESTORE1CUSTOMER_ADDRESS1STORE_SALES3_entry,long,
    HashIndex<EXT_PRICESTORE1CUSTOMER_ADDRESS1STORE_SALES3_entry,long,EXT_PRICESTORE1CUSTOMER_ADDRESS1STORE_SALES3_mapkey01_idxfn,true>,
    HashIndex<EXT_PRICESTORE1CUSTOMER_ADDRESS1STORE_SALES3_entry,long,EXT_PRICESTORE1CUSTOMER_ADDRESS1STORE_SALES3_mapkey0_idxfn,false>,
    HashIndex<EXT_PRICESTORE1CUSTOMER_ADDRESS1STORE_SALES3_entry,long,EXT_PRICESTORE1CUSTOMER_ADDRESS1STORE_SALES3_mapkey1_idxfn,false>
  > EXT_PRICESTORE1CUSTOMER_ADDRESS1STORE_SALES3_map;
  typedef HashIndex<EXT_PRICESTORE1CUSTOMER_ADDRESS1STORE_SALES3_entry,long,EXT_PRICESTORE1CUSTOMER_ADDRESS1STORE_SALES3_mapkey01_idxfn,true> HashIndex_EXT_PRICESTORE1CUSTOMER_ADDRESS1STORE_SALES3_map_01;
  typedef HashIndex<EXT_PRICESTORE1CUSTOMER_ADDRESS1STORE_SALES3_entry,long,EXT_PRICESTORE1CUSTOMER_ADDRESS1STORE_SALES3_mapkey0_idxfn,false> HashIndex_EXT_PRICESTORE1CUSTOMER_ADDRESS1STORE_SALES3_map_0;
  typedef HashIndex<EXT_PRICESTORE1CUSTOMER_ADDRESS1STORE_SALES3_entry,long,EXT_PRICESTORE1CUSTOMER_ADDRESS1STORE_SALES3_mapkey1_idxfn,false> HashIndex_EXT_PRICESTORE1CUSTOMER_ADDRESS1STORE_SALES3_map_1;
  
  struct EXT_PRICESTORE1CUSTOMER_ADDRESS1CUSTOMER1_entry {
    long EXT_PRICESTORE1CUSTOMER_ADDRESS1CUSTOMERCUSTOMER_C_CUSTOMER_SK; long EXT_PRICESTORESTORE_S_STORE_SK; long ITEM_I_MANUFACT_ID; STRING_TYPE ITEM_I_MANUFACT; long BRAND_ID; STRING_TYPE BRAND; DOUBLE_TYPE __av; 
    explicit EXT_PRICESTORE1CUSTOMER_ADDRESS1CUSTOMER1_entry() { /*EXT_PRICESTORE1CUSTOMER_ADDRESS1CUSTOMERCUSTOMER_C_CUSTOMER_SK = 0L; EXT_PRICESTORESTORE_S_STORE_SK = 0L; ITEM_I_MANUFACT_ID = 0L; ITEM_I_MANUFACT = ""; BRAND_ID = 0L; BRAND = ""; __av = 0.0; */ }
    explicit EXT_PRICESTORE1CUSTOMER_ADDRESS1CUSTOMER1_entry(const long c0, const long c1, const long c2, const STRING_TYPE& c3, const long c4, const STRING_TYPE& c5, const DOUBLE_TYPE c6) { EXT_PRICESTORE1CUSTOMER_ADDRESS1CUSTOMERCUSTOMER_C_CUSTOMER_SK = c0; EXT_PRICESTORESTORE_S_STORE_SK = c1; ITEM_I_MANUFACT_ID = c2; ITEM_I_MANUFACT = c3; BRAND_ID = c4; BRAND = c5; __av = c6; }
    EXT_PRICESTORE1CUSTOMER_ADDRESS1CUSTOMER1_entry(const EXT_PRICESTORE1CUSTOMER_ADDRESS1CUSTOMER1_entry& other) : EXT_PRICESTORE1CUSTOMER_ADDRESS1CUSTOMERCUSTOMER_C_CUSTOMER_SK( other.EXT_PRICESTORE1CUSTOMER_ADDRESS1CUSTOMERCUSTOMER_C_CUSTOMER_SK ), EXT_PRICESTORESTORE_S_STORE_SK( other.EXT_PRICESTORESTORE_S_STORE_SK ), ITEM_I_MANUFACT_ID( other.ITEM_I_MANUFACT_ID ), ITEM_I_MANUFACT( other.ITEM_I_MANUFACT ), BRAND_ID( other.BRAND_ID ), BRAND( other.BRAND ), __av( other.__av ) {}
    FORCE_INLINE EXT_PRICESTORE1CUSTOMER_ADDRESS1CUSTOMER1_entry& modify(const long c0, const long c1, const long c2, const STRING_TYPE& c3, const long c4, const STRING_TYPE& c5) { EXT_PRICESTORE1CUSTOMER_ADDRESS1CUSTOMERCUSTOMER_C_CUSTOMER_SK = c0; EXT_PRICESTORESTORE_S_STORE_SK = c1; ITEM_I_MANUFACT_ID = c2; ITEM_I_MANUFACT = c3; BRAND_ID = c4; BRAND = c5;  return *this; }
    FORCE_INLINE EXT_PRICESTORE1CUSTOMER_ADDRESS1CUSTOMER1_entry& modify0(const long c0) { EXT_PRICESTORE1CUSTOMER_ADDRESS1CUSTOMERCUSTOMER_C_CUSTOMER_SK = c0;  return *this; }
    FORCE_INLINE EXT_PRICESTORE1CUSTOMER_ADDRESS1CUSTOMER1_entry& modify1(const long c1) { EXT_PRICESTORESTORE_S_STORE_SK = c1;  return *this; }
    template<class Archive>
    void serialize(Archive& ar, const unsigned int version) const 
    {
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, EXT_PRICESTORE1CUSTOMER_ADDRESS1CUSTOMERCUSTOMER_C_CUSTOMER_SK);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, EXT_PRICESTORESTORE_S_STORE_SK);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, ITEM_I_MANUFACT_ID);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, ITEM_I_MANUFACT);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, BRAND_ID);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, BRAND);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, __av);
    }
  };
  struct EXT_PRICESTORE1CUSTOMER_ADDRESS1CUSTOMER1_mapkey012345_idxfn {
    FORCE_INLINE static size_t hash(const EXT_PRICESTORE1CUSTOMER_ADDRESS1CUSTOMER1_entry& e) {
      size_t h = 0;
      hash_combine(h, e.EXT_PRICESTORE1CUSTOMER_ADDRESS1CUSTOMERCUSTOMER_C_CUSTOMER_SK);
      hash_combine(h, e.EXT_PRICESTORESTORE_S_STORE_SK);
      hash_combine(h, e.ITEM_I_MANUFACT_ID);
      hash_combine(h, e.ITEM_I_MANUFACT);
      hash_combine(h, e.BRAND_ID);
      hash_combine(h, e.BRAND);
      return h;
    }
    FORCE_INLINE static bool equals(const EXT_PRICESTORE1CUSTOMER_ADDRESS1CUSTOMER1_entry& x, const EXT_PRICESTORE1CUSTOMER_ADDRESS1CUSTOMER1_entry& y) {
      return x.EXT_PRICESTORE1CUSTOMER_ADDRESS1CUSTOMERCUSTOMER_C_CUSTOMER_SK == y.EXT_PRICESTORE1CUSTOMER_ADDRESS1CUSTOMERCUSTOMER_C_CUSTOMER_SK && x.EXT_PRICESTORESTORE_S_STORE_SK == y.EXT_PRICESTORESTORE_S_STORE_SK && x.ITEM_I_MANUFACT_ID == y.ITEM_I_MANUFACT_ID && x.ITEM_I_MANUFACT == y.ITEM_I_MANUFACT && x.BRAND_ID == y.BRAND_ID && x.BRAND == y.BRAND;
    }
  };
  
  struct EXT_PRICESTORE1CUSTOMER_ADDRESS1CUSTOMER1_mapkey0_idxfn {
    FORCE_INLINE static size_t hash(const EXT_PRICESTORE1CUSTOMER_ADDRESS1CUSTOMER1_entry& e) {
      size_t h = 0;
      hash_combine(h, e.EXT_PRICESTORE1CUSTOMER_ADDRESS1CUSTOMERCUSTOMER_C_CUSTOMER_SK);
      return h;
    }
    FORCE_INLINE static bool equals(const EXT_PRICESTORE1CUSTOMER_ADDRESS1CUSTOMER1_entry& x, const EXT_PRICESTORE1CUSTOMER_ADDRESS1CUSTOMER1_entry& y) {
      return x.EXT_PRICESTORE1CUSTOMER_ADDRESS1CUSTOMERCUSTOMER_C_CUSTOMER_SK == y.EXT_PRICESTORE1CUSTOMER_ADDRESS1CUSTOMERCUSTOMER_C_CUSTOMER_SK;
    }
  };
  
  struct EXT_PRICESTORE1CUSTOMER_ADDRESS1CUSTOMER1_mapkey1_idxfn {
    FORCE_INLINE static size_t hash(const EXT_PRICESTORE1CUSTOMER_ADDRESS1CUSTOMER1_entry& e) {
      size_t h = 0;
      hash_combine(h, e.EXT_PRICESTORESTORE_S_STORE_SK);
      return h;
    }
    FORCE_INLINE static bool equals(const EXT_PRICESTORE1CUSTOMER_ADDRESS1CUSTOMER1_entry& x, const EXT_PRICESTORE1CUSTOMER_ADDRESS1CUSTOMER1_entry& y) {
      return x.EXT_PRICESTORESTORE_S_STORE_SK == y.EXT_PRICESTORESTORE_S_STORE_SK;
    }
  };
  
  typedef MultiHashMap<EXT_PRICESTORE1CUSTOMER_ADDRESS1CUSTOMER1_entry,DOUBLE_TYPE,
    HashIndex<EXT_PRICESTORE1CUSTOMER_ADDRESS1CUSTOMER1_entry,DOUBLE_TYPE,EXT_PRICESTORE1CUSTOMER_ADDRESS1CUSTOMER1_mapkey012345_idxfn,true>,
    HashIndex<EXT_PRICESTORE1CUSTOMER_ADDRESS1CUSTOMER1_entry,DOUBLE_TYPE,EXT_PRICESTORE1CUSTOMER_ADDRESS1CUSTOMER1_mapkey0_idxfn,false>,
    HashIndex<EXT_PRICESTORE1CUSTOMER_ADDRESS1CUSTOMER1_entry,DOUBLE_TYPE,EXT_PRICESTORE1CUSTOMER_ADDRESS1CUSTOMER1_mapkey1_idxfn,false>
  > EXT_PRICESTORE1CUSTOMER_ADDRESS1CUSTOMER1_map;
  typedef HashIndex<EXT_PRICESTORE1CUSTOMER_ADDRESS1CUSTOMER1_entry,DOUBLE_TYPE,EXT_PRICESTORE1CUSTOMER_ADDRESS1CUSTOMER1_mapkey012345_idxfn,true> HashIndex_EXT_PRICESTORE1CUSTOMER_ADDRESS1CUSTOMER1_map_012345;
  typedef HashIndex<EXT_PRICESTORE1CUSTOMER_ADDRESS1CUSTOMER1_entry,DOUBLE_TYPE,EXT_PRICESTORE1CUSTOMER_ADDRESS1CUSTOMER1_mapkey0_idxfn,false> HashIndex_EXT_PRICESTORE1CUSTOMER_ADDRESS1CUSTOMER1_map_0;
  typedef HashIndex<EXT_PRICESTORE1CUSTOMER_ADDRESS1CUSTOMER1_entry,DOUBLE_TYPE,EXT_PRICESTORE1CUSTOMER_ADDRESS1CUSTOMER1_mapkey1_idxfn,false> HashIndex_EXT_PRICESTORE1CUSTOMER_ADDRESS1CUSTOMER1_map_1;
  
  struct EXT_PRICESTORE1CUSTOMER1_entry {
    long EXT_PRICESTORE1CUSTOMERCUSTOMER_C_CUSTOMER_SK; long EXT_PRICESTORESTORE_S_STORE_SK; long ITEM_I_MANUFACT_ID; STRING_TYPE ITEM_I_MANUFACT; STRING_TYPE BRAND; long BRAND_ID; DOUBLE_TYPE __av; 
    explicit EXT_PRICESTORE1CUSTOMER1_entry() { /*EXT_PRICESTORE1CUSTOMERCUSTOMER_C_CUSTOMER_SK = 0L; EXT_PRICESTORESTORE_S_STORE_SK = 0L; ITEM_I_MANUFACT_ID = 0L; ITEM_I_MANUFACT = ""; BRAND = ""; BRAND_ID = 0L; __av = 0.0; */ }
    explicit EXT_PRICESTORE1CUSTOMER1_entry(const long c0, const long c1, const long c2, const STRING_TYPE& c3, const STRING_TYPE& c4, const long c5, const DOUBLE_TYPE c6) { EXT_PRICESTORE1CUSTOMERCUSTOMER_C_CUSTOMER_SK = c0; EXT_PRICESTORESTORE_S_STORE_SK = c1; ITEM_I_MANUFACT_ID = c2; ITEM_I_MANUFACT = c3; BRAND = c4; BRAND_ID = c5; __av = c6; }
    EXT_PRICESTORE1CUSTOMER1_entry(const EXT_PRICESTORE1CUSTOMER1_entry& other) : EXT_PRICESTORE1CUSTOMERCUSTOMER_C_CUSTOMER_SK( other.EXT_PRICESTORE1CUSTOMERCUSTOMER_C_CUSTOMER_SK ), EXT_PRICESTORESTORE_S_STORE_SK( other.EXT_PRICESTORESTORE_S_STORE_SK ), ITEM_I_MANUFACT_ID( other.ITEM_I_MANUFACT_ID ), ITEM_I_MANUFACT( other.ITEM_I_MANUFACT ), BRAND( other.BRAND ), BRAND_ID( other.BRAND_ID ), __av( other.__av ) {}
    FORCE_INLINE EXT_PRICESTORE1CUSTOMER1_entry& modify(const long c0, const long c1, const long c2, const STRING_TYPE& c3, const STRING_TYPE& c4, const long c5) { EXT_PRICESTORE1CUSTOMERCUSTOMER_C_CUSTOMER_SK = c0; EXT_PRICESTORESTORE_S_STORE_SK = c1; ITEM_I_MANUFACT_ID = c2; ITEM_I_MANUFACT = c3; BRAND = c4; BRAND_ID = c5;  return *this; }
    FORCE_INLINE EXT_PRICESTORE1CUSTOMER1_entry& modify0(const long c0) { EXT_PRICESTORE1CUSTOMERCUSTOMER_C_CUSTOMER_SK = c0;  return *this; }
    FORCE_INLINE EXT_PRICESTORE1CUSTOMER1_entry& modify1(const long c1) { EXT_PRICESTORESTORE_S_STORE_SK = c1;  return *this; }
    template<class Archive>
    void serialize(Archive& ar, const unsigned int version) const 
    {
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, EXT_PRICESTORE1CUSTOMERCUSTOMER_C_CUSTOMER_SK);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, EXT_PRICESTORESTORE_S_STORE_SK);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, ITEM_I_MANUFACT_ID);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, ITEM_I_MANUFACT);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, BRAND);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, BRAND_ID);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, __av);
    }
  };
  struct EXT_PRICESTORE1CUSTOMER1_mapkey012345_idxfn {
    FORCE_INLINE static size_t hash(const EXT_PRICESTORE1CUSTOMER1_entry& e) {
      size_t h = 0;
      hash_combine(h, e.EXT_PRICESTORE1CUSTOMERCUSTOMER_C_CUSTOMER_SK);
      hash_combine(h, e.EXT_PRICESTORESTORE_S_STORE_SK);
      hash_combine(h, e.ITEM_I_MANUFACT_ID);
      hash_combine(h, e.ITEM_I_MANUFACT);
      hash_combine(h, e.BRAND);
      hash_combine(h, e.BRAND_ID);
      return h;
    }
    FORCE_INLINE static bool equals(const EXT_PRICESTORE1CUSTOMER1_entry& x, const EXT_PRICESTORE1CUSTOMER1_entry& y) {
      return x.EXT_PRICESTORE1CUSTOMERCUSTOMER_C_CUSTOMER_SK == y.EXT_PRICESTORE1CUSTOMERCUSTOMER_C_CUSTOMER_SK && x.EXT_PRICESTORESTORE_S_STORE_SK == y.EXT_PRICESTORESTORE_S_STORE_SK && x.ITEM_I_MANUFACT_ID == y.ITEM_I_MANUFACT_ID && x.ITEM_I_MANUFACT == y.ITEM_I_MANUFACT && x.BRAND == y.BRAND && x.BRAND_ID == y.BRAND_ID;
    }
  };
  
  struct EXT_PRICESTORE1CUSTOMER1_mapkey0_idxfn {
    FORCE_INLINE static size_t hash(const EXT_PRICESTORE1CUSTOMER1_entry& e) {
      size_t h = 0;
      hash_combine(h, e.EXT_PRICESTORE1CUSTOMERCUSTOMER_C_CUSTOMER_SK);
      return h;
    }
    FORCE_INLINE static bool equals(const EXT_PRICESTORE1CUSTOMER1_entry& x, const EXT_PRICESTORE1CUSTOMER1_entry& y) {
      return x.EXT_PRICESTORE1CUSTOMERCUSTOMER_C_CUSTOMER_SK == y.EXT_PRICESTORE1CUSTOMERCUSTOMER_C_CUSTOMER_SK;
    }
  };
  
  struct EXT_PRICESTORE1CUSTOMER1_mapkey1_idxfn {
    FORCE_INLINE static size_t hash(const EXT_PRICESTORE1CUSTOMER1_entry& e) {
      size_t h = 0;
      hash_combine(h, e.EXT_PRICESTORESTORE_S_STORE_SK);
      return h;
    }
    FORCE_INLINE static bool equals(const EXT_PRICESTORE1CUSTOMER1_entry& x, const EXT_PRICESTORE1CUSTOMER1_entry& y) {
      return x.EXT_PRICESTORESTORE_S_STORE_SK == y.EXT_PRICESTORESTORE_S_STORE_SK;
    }
  };
  
  typedef MultiHashMap<EXT_PRICESTORE1CUSTOMER1_entry,DOUBLE_TYPE,
    HashIndex<EXT_PRICESTORE1CUSTOMER1_entry,DOUBLE_TYPE,EXT_PRICESTORE1CUSTOMER1_mapkey012345_idxfn,true>,
    HashIndex<EXT_PRICESTORE1CUSTOMER1_entry,DOUBLE_TYPE,EXT_PRICESTORE1CUSTOMER1_mapkey0_idxfn,false>,
    HashIndex<EXT_PRICESTORE1CUSTOMER1_entry,DOUBLE_TYPE,EXT_PRICESTORE1CUSTOMER1_mapkey1_idxfn,false>
  > EXT_PRICESTORE1CUSTOMER1_map;
  typedef HashIndex<EXT_PRICESTORE1CUSTOMER1_entry,DOUBLE_TYPE,EXT_PRICESTORE1CUSTOMER1_mapkey012345_idxfn,true> HashIndex_EXT_PRICESTORE1CUSTOMER1_map_012345;
  typedef HashIndex<EXT_PRICESTORE1CUSTOMER1_entry,DOUBLE_TYPE,EXT_PRICESTORE1CUSTOMER1_mapkey0_idxfn,false> HashIndex_EXT_PRICESTORE1CUSTOMER1_map_0;
  typedef HashIndex<EXT_PRICESTORE1CUSTOMER1_entry,DOUBLE_TYPE,EXT_PRICESTORE1CUSTOMER1_mapkey1_idxfn,false> HashIndex_EXT_PRICESTORE1CUSTOMER1_map_1;
  
  struct EXT_PRICESTORE1CUSTOMER2_entry {
    long EXT_PRICESTORE1CUSTOMERCUSTOMER_C_CURRENT_ADDR_SK; STRING_TYPE CUSTOMER_ADDRESS_CA_ZIP; long __av; 
    explicit EXT_PRICESTORE1CUSTOMER2_entry() { /*EXT_PRICESTORE1CUSTOMERCUSTOMER_C_CURRENT_ADDR_SK = 0L; CUSTOMER_ADDRESS_CA_ZIP = ""; __av = 0L; */ }
    explicit EXT_PRICESTORE1CUSTOMER2_entry(const long c0, const STRING_TYPE& c1, const long c2) { EXT_PRICESTORE1CUSTOMERCUSTOMER_C_CURRENT_ADDR_SK = c0; CUSTOMER_ADDRESS_CA_ZIP = c1; __av = c2; }
    EXT_PRICESTORE1CUSTOMER2_entry(const EXT_PRICESTORE1CUSTOMER2_entry& other) : EXT_PRICESTORE1CUSTOMERCUSTOMER_C_CURRENT_ADDR_SK( other.EXT_PRICESTORE1CUSTOMERCUSTOMER_C_CURRENT_ADDR_SK ), CUSTOMER_ADDRESS_CA_ZIP( other.CUSTOMER_ADDRESS_CA_ZIP ), __av( other.__av ) {}
    FORCE_INLINE EXT_PRICESTORE1CUSTOMER2_entry& modify(const long c0, const STRING_TYPE& c1) { EXT_PRICESTORE1CUSTOMERCUSTOMER_C_CURRENT_ADDR_SK = c0; CUSTOMER_ADDRESS_CA_ZIP = c1;  return *this; }
    FORCE_INLINE EXT_PRICESTORE1CUSTOMER2_entry& modify0(const long c0) { EXT_PRICESTORE1CUSTOMERCUSTOMER_C_CURRENT_ADDR_SK = c0;  return *this; }
    template<class Archive>
    void serialize(Archive& ar, const unsigned int version) const 
    {
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, EXT_PRICESTORE1CUSTOMERCUSTOMER_C_CURRENT_ADDR_SK);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, CUSTOMER_ADDRESS_CA_ZIP);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, __av);
    }
  };
  struct EXT_PRICESTORE1CUSTOMER2_mapkey01_idxfn {
    FORCE_INLINE static size_t hash(const EXT_PRICESTORE1CUSTOMER2_entry& e) {
      size_t h = 0;
      hash_combine(h, e.EXT_PRICESTORE1CUSTOMERCUSTOMER_C_CURRENT_ADDR_SK);
      hash_combine(h, e.CUSTOMER_ADDRESS_CA_ZIP);
      return h;
    }
    FORCE_INLINE static bool equals(const EXT_PRICESTORE1CUSTOMER2_entry& x, const EXT_PRICESTORE1CUSTOMER2_entry& y) {
      return x.EXT_PRICESTORE1CUSTOMERCUSTOMER_C_CURRENT_ADDR_SK == y.EXT_PRICESTORE1CUSTOMERCUSTOMER_C_CURRENT_ADDR_SK && x.CUSTOMER_ADDRESS_CA_ZIP == y.CUSTOMER_ADDRESS_CA_ZIP;
    }
  };
  
  struct EXT_PRICESTORE1CUSTOMER2_mapkey0_idxfn {
    FORCE_INLINE static size_t hash(const EXT_PRICESTORE1CUSTOMER2_entry& e) {
      size_t h = 0;
      hash_combine(h, e.EXT_PRICESTORE1CUSTOMERCUSTOMER_C_CURRENT_ADDR_SK);
      return h;
    }
    FORCE_INLINE static bool equals(const EXT_PRICESTORE1CUSTOMER2_entry& x, const EXT_PRICESTORE1CUSTOMER2_entry& y) {
      return x.EXT_PRICESTORE1CUSTOMERCUSTOMER_C_CURRENT_ADDR_SK == y.EXT_PRICESTORE1CUSTOMERCUSTOMER_C_CURRENT_ADDR_SK;
    }
  };
  
  typedef MultiHashMap<EXT_PRICESTORE1CUSTOMER2_entry,long,
    HashIndex<EXT_PRICESTORE1CUSTOMER2_entry,long,EXT_PRICESTORE1CUSTOMER2_mapkey01_idxfn,true>,
    HashIndex<EXT_PRICESTORE1CUSTOMER2_entry,long,EXT_PRICESTORE1CUSTOMER2_mapkey0_idxfn,false>
  > EXT_PRICESTORE1CUSTOMER2_map;
  typedef HashIndex<EXT_PRICESTORE1CUSTOMER2_entry,long,EXT_PRICESTORE1CUSTOMER2_mapkey01_idxfn,true> HashIndex_EXT_PRICESTORE1CUSTOMER2_map_01;
  typedef HashIndex<EXT_PRICESTORE1CUSTOMER2_entry,long,EXT_PRICESTORE1CUSTOMER2_mapkey0_idxfn,false> HashIndex_EXT_PRICESTORE1CUSTOMER2_map_0;
  
  struct EXT_PRICESTORE1ITEM2_entry {
    long EXT_PRICESTORE1ITEMITEM_I_ITEM_SK; long EXT_PRICESTORESTORE_S_STORE_SK; STRING_TYPE CUSTOMER_ADDRESS_CA_ZIP; DOUBLE_TYPE __av; 
    explicit EXT_PRICESTORE1ITEM2_entry() { /*EXT_PRICESTORE1ITEMITEM_I_ITEM_SK = 0L; EXT_PRICESTORESTORE_S_STORE_SK = 0L; CUSTOMER_ADDRESS_CA_ZIP = ""; __av = 0.0; */ }
    explicit EXT_PRICESTORE1ITEM2_entry(const long c0, const long c1, const STRING_TYPE& c2, const DOUBLE_TYPE c3) { EXT_PRICESTORE1ITEMITEM_I_ITEM_SK = c0; EXT_PRICESTORESTORE_S_STORE_SK = c1; CUSTOMER_ADDRESS_CA_ZIP = c2; __av = c3; }
    EXT_PRICESTORE1ITEM2_entry(const EXT_PRICESTORE1ITEM2_entry& other) : EXT_PRICESTORE1ITEMITEM_I_ITEM_SK( other.EXT_PRICESTORE1ITEMITEM_I_ITEM_SK ), EXT_PRICESTORESTORE_S_STORE_SK( other.EXT_PRICESTORESTORE_S_STORE_SK ), CUSTOMER_ADDRESS_CA_ZIP( other.CUSTOMER_ADDRESS_CA_ZIP ), __av( other.__av ) {}
    FORCE_INLINE EXT_PRICESTORE1ITEM2_entry& modify(const long c0, const long c1, const STRING_TYPE& c2) { EXT_PRICESTORE1ITEMITEM_I_ITEM_SK = c0; EXT_PRICESTORESTORE_S_STORE_SK = c1; CUSTOMER_ADDRESS_CA_ZIP = c2;  return *this; }
    FORCE_INLINE EXT_PRICESTORE1ITEM2_entry& modify0(const long c0) { EXT_PRICESTORE1ITEMITEM_I_ITEM_SK = c0;  return *this; }
    FORCE_INLINE EXT_PRICESTORE1ITEM2_entry& modify1(const long c1) { EXT_PRICESTORESTORE_S_STORE_SK = c1;  return *this; }
    template<class Archive>
    void serialize(Archive& ar, const unsigned int version) const 
    {
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, EXT_PRICESTORE1ITEMITEM_I_ITEM_SK);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, EXT_PRICESTORESTORE_S_STORE_SK);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, CUSTOMER_ADDRESS_CA_ZIP);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, __av);
    }
  };
  struct EXT_PRICESTORE1ITEM2_mapkey012_idxfn {
    FORCE_INLINE static size_t hash(const EXT_PRICESTORE1ITEM2_entry& e) {
      size_t h = 0;
      hash_combine(h, e.EXT_PRICESTORE1ITEMITEM_I_ITEM_SK);
      hash_combine(h, e.EXT_PRICESTORESTORE_S_STORE_SK);
      hash_combine(h, e.CUSTOMER_ADDRESS_CA_ZIP);
      return h;
    }
    FORCE_INLINE static bool equals(const EXT_PRICESTORE1ITEM2_entry& x, const EXT_PRICESTORE1ITEM2_entry& y) {
      return x.EXT_PRICESTORE1ITEMITEM_I_ITEM_SK == y.EXT_PRICESTORE1ITEMITEM_I_ITEM_SK && x.EXT_PRICESTORESTORE_S_STORE_SK == y.EXT_PRICESTORESTORE_S_STORE_SK && x.CUSTOMER_ADDRESS_CA_ZIP == y.CUSTOMER_ADDRESS_CA_ZIP;
    }
  };
  
  struct EXT_PRICESTORE1ITEM2_mapkey0_idxfn {
    FORCE_INLINE static size_t hash(const EXT_PRICESTORE1ITEM2_entry& e) {
      size_t h = 0;
      hash_combine(h, e.EXT_PRICESTORE1ITEMITEM_I_ITEM_SK);
      return h;
    }
    FORCE_INLINE static bool equals(const EXT_PRICESTORE1ITEM2_entry& x, const EXT_PRICESTORE1ITEM2_entry& y) {
      return x.EXT_PRICESTORE1ITEMITEM_I_ITEM_SK == y.EXT_PRICESTORE1ITEMITEM_I_ITEM_SK;
    }
  };
  
  struct EXT_PRICESTORE1ITEM2_mapkey1_idxfn {
    FORCE_INLINE static size_t hash(const EXT_PRICESTORE1ITEM2_entry& e) {
      size_t h = 0;
      hash_combine(h, e.EXT_PRICESTORESTORE_S_STORE_SK);
      return h;
    }
    FORCE_INLINE static bool equals(const EXT_PRICESTORE1ITEM2_entry& x, const EXT_PRICESTORE1ITEM2_entry& y) {
      return x.EXT_PRICESTORESTORE_S_STORE_SK == y.EXT_PRICESTORESTORE_S_STORE_SK;
    }
  };
  
  typedef MultiHashMap<EXT_PRICESTORE1ITEM2_entry,DOUBLE_TYPE,
    HashIndex<EXT_PRICESTORE1ITEM2_entry,DOUBLE_TYPE,EXT_PRICESTORE1ITEM2_mapkey012_idxfn,true>,
    HashIndex<EXT_PRICESTORE1ITEM2_entry,DOUBLE_TYPE,EXT_PRICESTORE1ITEM2_mapkey0_idxfn,false>,
    HashIndex<EXT_PRICESTORE1ITEM2_entry,DOUBLE_TYPE,EXT_PRICESTORE1ITEM2_mapkey1_idxfn,false>
  > EXT_PRICESTORE1ITEM2_map;
  typedef HashIndex<EXT_PRICESTORE1ITEM2_entry,DOUBLE_TYPE,EXT_PRICESTORE1ITEM2_mapkey012_idxfn,true> HashIndex_EXT_PRICESTORE1ITEM2_map_012;
  typedef HashIndex<EXT_PRICESTORE1ITEM2_entry,DOUBLE_TYPE,EXT_PRICESTORE1ITEM2_mapkey0_idxfn,false> HashIndex_EXT_PRICESTORE1ITEM2_map_0;
  typedef HashIndex<EXT_PRICESTORE1ITEM2_entry,DOUBLE_TYPE,EXT_PRICESTORE1ITEM2_mapkey1_idxfn,false> HashIndex_EXT_PRICESTORE1ITEM2_map_1;
  
  struct EXT_PRICESTORE1STORE_SALES3_entry {
    long EXT_PRICESTORE1STORE_SALESSTORE_SALES_SS_CUSTOMER_SK; STRING_TYPE CUSTOMER_ADDRESS_CA_ZIP; long __av; 
    explicit EXT_PRICESTORE1STORE_SALES3_entry() { /*EXT_PRICESTORE1STORE_SALESSTORE_SALES_SS_CUSTOMER_SK = 0L; CUSTOMER_ADDRESS_CA_ZIP = ""; __av = 0L; */ }
    explicit EXT_PRICESTORE1STORE_SALES3_entry(const long c0, const STRING_TYPE& c1, const long c2) { EXT_PRICESTORE1STORE_SALESSTORE_SALES_SS_CUSTOMER_SK = c0; CUSTOMER_ADDRESS_CA_ZIP = c1; __av = c2; }
    EXT_PRICESTORE1STORE_SALES3_entry(const EXT_PRICESTORE1STORE_SALES3_entry& other) : EXT_PRICESTORE1STORE_SALESSTORE_SALES_SS_CUSTOMER_SK( other.EXT_PRICESTORE1STORE_SALESSTORE_SALES_SS_CUSTOMER_SK ), CUSTOMER_ADDRESS_CA_ZIP( other.CUSTOMER_ADDRESS_CA_ZIP ), __av( other.__av ) {}
    FORCE_INLINE EXT_PRICESTORE1STORE_SALES3_entry& modify(const long c0, const STRING_TYPE& c1) { EXT_PRICESTORE1STORE_SALESSTORE_SALES_SS_CUSTOMER_SK = c0; CUSTOMER_ADDRESS_CA_ZIP = c1;  return *this; }
    FORCE_INLINE EXT_PRICESTORE1STORE_SALES3_entry& modify0(const long c0) { EXT_PRICESTORE1STORE_SALESSTORE_SALES_SS_CUSTOMER_SK = c0;  return *this; }
    template<class Archive>
    void serialize(Archive& ar, const unsigned int version) const 
    {
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, EXT_PRICESTORE1STORE_SALESSTORE_SALES_SS_CUSTOMER_SK);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, CUSTOMER_ADDRESS_CA_ZIP);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, __av);
    }
  };
  struct EXT_PRICESTORE1STORE_SALES3_mapkey01_idxfn {
    FORCE_INLINE static size_t hash(const EXT_PRICESTORE1STORE_SALES3_entry& e) {
      size_t h = 0;
      hash_combine(h, e.EXT_PRICESTORE1STORE_SALESSTORE_SALES_SS_CUSTOMER_SK);
      hash_combine(h, e.CUSTOMER_ADDRESS_CA_ZIP);
      return h;
    }
    FORCE_INLINE static bool equals(const EXT_PRICESTORE1STORE_SALES3_entry& x, const EXT_PRICESTORE1STORE_SALES3_entry& y) {
      return x.EXT_PRICESTORE1STORE_SALESSTORE_SALES_SS_CUSTOMER_SK == y.EXT_PRICESTORE1STORE_SALESSTORE_SALES_SS_CUSTOMER_SK && x.CUSTOMER_ADDRESS_CA_ZIP == y.CUSTOMER_ADDRESS_CA_ZIP;
    }
  };
  
  struct EXT_PRICESTORE1STORE_SALES3_mapkey0_idxfn {
    FORCE_INLINE static size_t hash(const EXT_PRICESTORE1STORE_SALES3_entry& e) {
      size_t h = 0;
      hash_combine(h, e.EXT_PRICESTORE1STORE_SALESSTORE_SALES_SS_CUSTOMER_SK);
      return h;
    }
    FORCE_INLINE static bool equals(const EXT_PRICESTORE1STORE_SALES3_entry& x, const EXT_PRICESTORE1STORE_SALES3_entry& y) {
      return x.EXT_PRICESTORE1STORE_SALESSTORE_SALES_SS_CUSTOMER_SK == y.EXT_PRICESTORE1STORE_SALESSTORE_SALES_SS_CUSTOMER_SK;
    }
  };
  
  typedef MultiHashMap<EXT_PRICESTORE1STORE_SALES3_entry,long,
    HashIndex<EXT_PRICESTORE1STORE_SALES3_entry,long,EXT_PRICESTORE1STORE_SALES3_mapkey01_idxfn,true>,
    HashIndex<EXT_PRICESTORE1STORE_SALES3_entry,long,EXT_PRICESTORE1STORE_SALES3_mapkey0_idxfn,false>
  > EXT_PRICESTORE1STORE_SALES3_map;
  typedef HashIndex<EXT_PRICESTORE1STORE_SALES3_entry,long,EXT_PRICESTORE1STORE_SALES3_mapkey01_idxfn,true> HashIndex_EXT_PRICESTORE1STORE_SALES3_map_01;
  typedef HashIndex<EXT_PRICESTORE1STORE_SALES3_entry,long,EXT_PRICESTORE1STORE_SALES3_mapkey0_idxfn,false> HashIndex_EXT_PRICESTORE1STORE_SALES3_map_0;
  
  struct EXT_PRICECUSTOMER_ADDRESS1_entry {
    long EXT_PRICECUSTOMER_ADDRESSCUSTOMER_ADDRESS_CA_ADDRESS_SK; long ITEM_I_MANUFACT_ID; STRING_TYPE ITEM_I_MANUFACT; STRING_TYPE STORE_S_ZIP; STRING_TYPE BRAND; long BRAND_ID; DOUBLE_TYPE __av; 
    explicit EXT_PRICECUSTOMER_ADDRESS1_entry() { /*EXT_PRICECUSTOMER_ADDRESSCUSTOMER_ADDRESS_CA_ADDRESS_SK = 0L; ITEM_I_MANUFACT_ID = 0L; ITEM_I_MANUFACT = ""; STORE_S_ZIP = ""; BRAND = ""; BRAND_ID = 0L; __av = 0.0; */ }
    explicit EXT_PRICECUSTOMER_ADDRESS1_entry(const long c0, const long c1, const STRING_TYPE& c2, const STRING_TYPE& c3, const STRING_TYPE& c4, const long c5, const DOUBLE_TYPE c6) { EXT_PRICECUSTOMER_ADDRESSCUSTOMER_ADDRESS_CA_ADDRESS_SK = c0; ITEM_I_MANUFACT_ID = c1; ITEM_I_MANUFACT = c2; STORE_S_ZIP = c3; BRAND = c4; BRAND_ID = c5; __av = c6; }
    EXT_PRICECUSTOMER_ADDRESS1_entry(const EXT_PRICECUSTOMER_ADDRESS1_entry& other) : EXT_PRICECUSTOMER_ADDRESSCUSTOMER_ADDRESS_CA_ADDRESS_SK( other.EXT_PRICECUSTOMER_ADDRESSCUSTOMER_ADDRESS_CA_ADDRESS_SK ), ITEM_I_MANUFACT_ID( other.ITEM_I_MANUFACT_ID ), ITEM_I_MANUFACT( other.ITEM_I_MANUFACT ), STORE_S_ZIP( other.STORE_S_ZIP ), BRAND( other.BRAND ), BRAND_ID( other.BRAND_ID ), __av( other.__av ) {}
    FORCE_INLINE EXT_PRICECUSTOMER_ADDRESS1_entry& modify(const long c0, const long c1, const STRING_TYPE& c2, const STRING_TYPE& c3, const STRING_TYPE& c4, const long c5) { EXT_PRICECUSTOMER_ADDRESSCUSTOMER_ADDRESS_CA_ADDRESS_SK = c0; ITEM_I_MANUFACT_ID = c1; ITEM_I_MANUFACT = c2; STORE_S_ZIP = c3; BRAND = c4; BRAND_ID = c5;  return *this; }
    FORCE_INLINE EXT_PRICECUSTOMER_ADDRESS1_entry& modify0(const long c0) { EXT_PRICECUSTOMER_ADDRESSCUSTOMER_ADDRESS_CA_ADDRESS_SK = c0;  return *this; }
    template<class Archive>
    void serialize(Archive& ar, const unsigned int version) const 
    {
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, EXT_PRICECUSTOMER_ADDRESSCUSTOMER_ADDRESS_CA_ADDRESS_SK);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, ITEM_I_MANUFACT_ID);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, ITEM_I_MANUFACT);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, STORE_S_ZIP);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, BRAND);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, BRAND_ID);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, __av);
    }
  };
  struct EXT_PRICECUSTOMER_ADDRESS1_mapkey012345_idxfn {
    FORCE_INLINE static size_t hash(const EXT_PRICECUSTOMER_ADDRESS1_entry& e) {
      size_t h = 0;
      hash_combine(h, e.EXT_PRICECUSTOMER_ADDRESSCUSTOMER_ADDRESS_CA_ADDRESS_SK);
      hash_combine(h, e.ITEM_I_MANUFACT_ID);
      hash_combine(h, e.ITEM_I_MANUFACT);
      hash_combine(h, e.STORE_S_ZIP);
      hash_combine(h, e.BRAND);
      hash_combine(h, e.BRAND_ID);
      return h;
    }
    FORCE_INLINE static bool equals(const EXT_PRICECUSTOMER_ADDRESS1_entry& x, const EXT_PRICECUSTOMER_ADDRESS1_entry& y) {
      return x.EXT_PRICECUSTOMER_ADDRESSCUSTOMER_ADDRESS_CA_ADDRESS_SK == y.EXT_PRICECUSTOMER_ADDRESSCUSTOMER_ADDRESS_CA_ADDRESS_SK && x.ITEM_I_MANUFACT_ID == y.ITEM_I_MANUFACT_ID && x.ITEM_I_MANUFACT == y.ITEM_I_MANUFACT && x.STORE_S_ZIP == y.STORE_S_ZIP && x.BRAND == y.BRAND && x.BRAND_ID == y.BRAND_ID;
    }
  };
  
  struct EXT_PRICECUSTOMER_ADDRESS1_mapkey0_idxfn {
    FORCE_INLINE static size_t hash(const EXT_PRICECUSTOMER_ADDRESS1_entry& e) {
      size_t h = 0;
      hash_combine(h, e.EXT_PRICECUSTOMER_ADDRESSCUSTOMER_ADDRESS_CA_ADDRESS_SK);
      return h;
    }
    FORCE_INLINE static bool equals(const EXT_PRICECUSTOMER_ADDRESS1_entry& x, const EXT_PRICECUSTOMER_ADDRESS1_entry& y) {
      return x.EXT_PRICECUSTOMER_ADDRESSCUSTOMER_ADDRESS_CA_ADDRESS_SK == y.EXT_PRICECUSTOMER_ADDRESSCUSTOMER_ADDRESS_CA_ADDRESS_SK;
    }
  };
  
  typedef MultiHashMap<EXT_PRICECUSTOMER_ADDRESS1_entry,DOUBLE_TYPE,
    HashIndex<EXT_PRICECUSTOMER_ADDRESS1_entry,DOUBLE_TYPE,EXT_PRICECUSTOMER_ADDRESS1_mapkey012345_idxfn,true>,
    HashIndex<EXT_PRICECUSTOMER_ADDRESS1_entry,DOUBLE_TYPE,EXT_PRICECUSTOMER_ADDRESS1_mapkey0_idxfn,false>
  > EXT_PRICECUSTOMER_ADDRESS1_map;
  typedef HashIndex<EXT_PRICECUSTOMER_ADDRESS1_entry,DOUBLE_TYPE,EXT_PRICECUSTOMER_ADDRESS1_mapkey012345_idxfn,true> HashIndex_EXT_PRICECUSTOMER_ADDRESS1_map_012345;
  typedef HashIndex<EXT_PRICECUSTOMER_ADDRESS1_entry,DOUBLE_TYPE,EXT_PRICECUSTOMER_ADDRESS1_mapkey0_idxfn,false> HashIndex_EXT_PRICECUSTOMER_ADDRESS1_map_0;
  
  struct EXT_PRICECUSTOMER_ADDRESS1ITEM2_entry {
    long EXT_PRICECUSTOMER_ADDRESS1ITEMITEM_I_ITEM_SK; long EXT_PRICECUSTOMER_ADDRESSCUSTOMER_ADDRESS_CA_ADDRESS_SK; STRING_TYPE STORE_S_ZIP; DOUBLE_TYPE __av; 
    explicit EXT_PRICECUSTOMER_ADDRESS1ITEM2_entry() { /*EXT_PRICECUSTOMER_ADDRESS1ITEMITEM_I_ITEM_SK = 0L; EXT_PRICECUSTOMER_ADDRESSCUSTOMER_ADDRESS_CA_ADDRESS_SK = 0L; STORE_S_ZIP = ""; __av = 0.0; */ }
    explicit EXT_PRICECUSTOMER_ADDRESS1ITEM2_entry(const long c0, const long c1, const STRING_TYPE& c2, const DOUBLE_TYPE c3) { EXT_PRICECUSTOMER_ADDRESS1ITEMITEM_I_ITEM_SK = c0; EXT_PRICECUSTOMER_ADDRESSCUSTOMER_ADDRESS_CA_ADDRESS_SK = c1; STORE_S_ZIP = c2; __av = c3; }
    EXT_PRICECUSTOMER_ADDRESS1ITEM2_entry(const EXT_PRICECUSTOMER_ADDRESS1ITEM2_entry& other) : EXT_PRICECUSTOMER_ADDRESS1ITEMITEM_I_ITEM_SK( other.EXT_PRICECUSTOMER_ADDRESS1ITEMITEM_I_ITEM_SK ), EXT_PRICECUSTOMER_ADDRESSCUSTOMER_ADDRESS_CA_ADDRESS_SK( other.EXT_PRICECUSTOMER_ADDRESSCUSTOMER_ADDRESS_CA_ADDRESS_SK ), STORE_S_ZIP( other.STORE_S_ZIP ), __av( other.__av ) {}
    FORCE_INLINE EXT_PRICECUSTOMER_ADDRESS1ITEM2_entry& modify(const long c0, const long c1, const STRING_TYPE& c2) { EXT_PRICECUSTOMER_ADDRESS1ITEMITEM_I_ITEM_SK = c0; EXT_PRICECUSTOMER_ADDRESSCUSTOMER_ADDRESS_CA_ADDRESS_SK = c1; STORE_S_ZIP = c2;  return *this; }
    FORCE_INLINE EXT_PRICECUSTOMER_ADDRESS1ITEM2_entry& modify0(const long c0) { EXT_PRICECUSTOMER_ADDRESS1ITEMITEM_I_ITEM_SK = c0;  return *this; }
    FORCE_INLINE EXT_PRICECUSTOMER_ADDRESS1ITEM2_entry& modify1(const long c1) { EXT_PRICECUSTOMER_ADDRESSCUSTOMER_ADDRESS_CA_ADDRESS_SK = c1;  return *this; }
    template<class Archive>
    void serialize(Archive& ar, const unsigned int version) const 
    {
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, EXT_PRICECUSTOMER_ADDRESS1ITEMITEM_I_ITEM_SK);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, EXT_PRICECUSTOMER_ADDRESSCUSTOMER_ADDRESS_CA_ADDRESS_SK);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, STORE_S_ZIP);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, __av);
    }
  };
  struct EXT_PRICECUSTOMER_ADDRESS1ITEM2_mapkey012_idxfn {
    FORCE_INLINE static size_t hash(const EXT_PRICECUSTOMER_ADDRESS1ITEM2_entry& e) {
      size_t h = 0;
      hash_combine(h, e.EXT_PRICECUSTOMER_ADDRESS1ITEMITEM_I_ITEM_SK);
      hash_combine(h, e.EXT_PRICECUSTOMER_ADDRESSCUSTOMER_ADDRESS_CA_ADDRESS_SK);
      hash_combine(h, e.STORE_S_ZIP);
      return h;
    }
    FORCE_INLINE static bool equals(const EXT_PRICECUSTOMER_ADDRESS1ITEM2_entry& x, const EXT_PRICECUSTOMER_ADDRESS1ITEM2_entry& y) {
      return x.EXT_PRICECUSTOMER_ADDRESS1ITEMITEM_I_ITEM_SK == y.EXT_PRICECUSTOMER_ADDRESS1ITEMITEM_I_ITEM_SK && x.EXT_PRICECUSTOMER_ADDRESSCUSTOMER_ADDRESS_CA_ADDRESS_SK == y.EXT_PRICECUSTOMER_ADDRESSCUSTOMER_ADDRESS_CA_ADDRESS_SK && x.STORE_S_ZIP == y.STORE_S_ZIP;
    }
  };
  
  struct EXT_PRICECUSTOMER_ADDRESS1ITEM2_mapkey0_idxfn {
    FORCE_INLINE static size_t hash(const EXT_PRICECUSTOMER_ADDRESS1ITEM2_entry& e) {
      size_t h = 0;
      hash_combine(h, e.EXT_PRICECUSTOMER_ADDRESS1ITEMITEM_I_ITEM_SK);
      return h;
    }
    FORCE_INLINE static bool equals(const EXT_PRICECUSTOMER_ADDRESS1ITEM2_entry& x, const EXT_PRICECUSTOMER_ADDRESS1ITEM2_entry& y) {
      return x.EXT_PRICECUSTOMER_ADDRESS1ITEMITEM_I_ITEM_SK == y.EXT_PRICECUSTOMER_ADDRESS1ITEMITEM_I_ITEM_SK;
    }
  };
  
  struct EXT_PRICECUSTOMER_ADDRESS1ITEM2_mapkey1_idxfn {
    FORCE_INLINE static size_t hash(const EXT_PRICECUSTOMER_ADDRESS1ITEM2_entry& e) {
      size_t h = 0;
      hash_combine(h, e.EXT_PRICECUSTOMER_ADDRESSCUSTOMER_ADDRESS_CA_ADDRESS_SK);
      return h;
    }
    FORCE_INLINE static bool equals(const EXT_PRICECUSTOMER_ADDRESS1ITEM2_entry& x, const EXT_PRICECUSTOMER_ADDRESS1ITEM2_entry& y) {
      return x.EXT_PRICECUSTOMER_ADDRESSCUSTOMER_ADDRESS_CA_ADDRESS_SK == y.EXT_PRICECUSTOMER_ADDRESSCUSTOMER_ADDRESS_CA_ADDRESS_SK;
    }
  };
  
  typedef MultiHashMap<EXT_PRICECUSTOMER_ADDRESS1ITEM2_entry,DOUBLE_TYPE,
    HashIndex<EXT_PRICECUSTOMER_ADDRESS1ITEM2_entry,DOUBLE_TYPE,EXT_PRICECUSTOMER_ADDRESS1ITEM2_mapkey012_idxfn,true>,
    HashIndex<EXT_PRICECUSTOMER_ADDRESS1ITEM2_entry,DOUBLE_TYPE,EXT_PRICECUSTOMER_ADDRESS1ITEM2_mapkey0_idxfn,false>,
    HashIndex<EXT_PRICECUSTOMER_ADDRESS1ITEM2_entry,DOUBLE_TYPE,EXT_PRICECUSTOMER_ADDRESS1ITEM2_mapkey1_idxfn,false>
  > EXT_PRICECUSTOMER_ADDRESS1ITEM2_map;
  typedef HashIndex<EXT_PRICECUSTOMER_ADDRESS1ITEM2_entry,DOUBLE_TYPE,EXT_PRICECUSTOMER_ADDRESS1ITEM2_mapkey012_idxfn,true> HashIndex_EXT_PRICECUSTOMER_ADDRESS1ITEM2_map_012;
  typedef HashIndex<EXT_PRICECUSTOMER_ADDRESS1ITEM2_entry,DOUBLE_TYPE,EXT_PRICECUSTOMER_ADDRESS1ITEM2_mapkey0_idxfn,false> HashIndex_EXT_PRICECUSTOMER_ADDRESS1ITEM2_map_0;
  typedef HashIndex<EXT_PRICECUSTOMER_ADDRESS1ITEM2_entry,DOUBLE_TYPE,EXT_PRICECUSTOMER_ADDRESS1ITEM2_mapkey1_idxfn,false> HashIndex_EXT_PRICECUSTOMER_ADDRESS1ITEM2_map_1;
  
  struct EXT_PRICECUSTOMER_ADDRESS1ITEM2CUSTOMER1_entry {
    long EXT_PRICECUSTOMER_ADDRESS1ITEMITEM_I_ITEM_SK; long EXT_PRICECUSTOMER_ADDRESS1ITEM2CUSTOMERCUSTOMER_C_CUSTOMER_SK; STRING_TYPE STORE_S_ZIP; DOUBLE_TYPE __av; 
    explicit EXT_PRICECUSTOMER_ADDRESS1ITEM2CUSTOMER1_entry() { /*EXT_PRICECUSTOMER_ADDRESS1ITEMITEM_I_ITEM_SK = 0L; EXT_PRICECUSTOMER_ADDRESS1ITEM2CUSTOMERCUSTOMER_C_CUSTOMER_SK = 0L; STORE_S_ZIP = ""; __av = 0.0; */ }
    explicit EXT_PRICECUSTOMER_ADDRESS1ITEM2CUSTOMER1_entry(const long c0, const long c1, const STRING_TYPE& c2, const DOUBLE_TYPE c3) { EXT_PRICECUSTOMER_ADDRESS1ITEMITEM_I_ITEM_SK = c0; EXT_PRICECUSTOMER_ADDRESS1ITEM2CUSTOMERCUSTOMER_C_CUSTOMER_SK = c1; STORE_S_ZIP = c2; __av = c3; }
    EXT_PRICECUSTOMER_ADDRESS1ITEM2CUSTOMER1_entry(const EXT_PRICECUSTOMER_ADDRESS1ITEM2CUSTOMER1_entry& other) : EXT_PRICECUSTOMER_ADDRESS1ITEMITEM_I_ITEM_SK( other.EXT_PRICECUSTOMER_ADDRESS1ITEMITEM_I_ITEM_SK ), EXT_PRICECUSTOMER_ADDRESS1ITEM2CUSTOMERCUSTOMER_C_CUSTOMER_SK( other.EXT_PRICECUSTOMER_ADDRESS1ITEM2CUSTOMERCUSTOMER_C_CUSTOMER_SK ), STORE_S_ZIP( other.STORE_S_ZIP ), __av( other.__av ) {}
    FORCE_INLINE EXT_PRICECUSTOMER_ADDRESS1ITEM2CUSTOMER1_entry& modify(const long c0, const long c1, const STRING_TYPE& c2) { EXT_PRICECUSTOMER_ADDRESS1ITEMITEM_I_ITEM_SK = c0; EXT_PRICECUSTOMER_ADDRESS1ITEM2CUSTOMERCUSTOMER_C_CUSTOMER_SK = c1; STORE_S_ZIP = c2;  return *this; }
    FORCE_INLINE EXT_PRICECUSTOMER_ADDRESS1ITEM2CUSTOMER1_entry& modify0(const long c0) { EXT_PRICECUSTOMER_ADDRESS1ITEMITEM_I_ITEM_SK = c0;  return *this; }
    FORCE_INLINE EXT_PRICECUSTOMER_ADDRESS1ITEM2CUSTOMER1_entry& modify1(const long c1) { EXT_PRICECUSTOMER_ADDRESS1ITEM2CUSTOMERCUSTOMER_C_CUSTOMER_SK = c1;  return *this; }
    template<class Archive>
    void serialize(Archive& ar, const unsigned int version) const 
    {
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, EXT_PRICECUSTOMER_ADDRESS1ITEMITEM_I_ITEM_SK);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, EXT_PRICECUSTOMER_ADDRESS1ITEM2CUSTOMERCUSTOMER_C_CUSTOMER_SK);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, STORE_S_ZIP);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, __av);
    }
  };
  struct EXT_PRICECUSTOMER_ADDRESS1ITEM2CUSTOMER1_mapkey012_idxfn {
    FORCE_INLINE static size_t hash(const EXT_PRICECUSTOMER_ADDRESS1ITEM2CUSTOMER1_entry& e) {
      size_t h = 0;
      hash_combine(h, e.EXT_PRICECUSTOMER_ADDRESS1ITEMITEM_I_ITEM_SK);
      hash_combine(h, e.EXT_PRICECUSTOMER_ADDRESS1ITEM2CUSTOMERCUSTOMER_C_CUSTOMER_SK);
      hash_combine(h, e.STORE_S_ZIP);
      return h;
    }
    FORCE_INLINE static bool equals(const EXT_PRICECUSTOMER_ADDRESS1ITEM2CUSTOMER1_entry& x, const EXT_PRICECUSTOMER_ADDRESS1ITEM2CUSTOMER1_entry& y) {
      return x.EXT_PRICECUSTOMER_ADDRESS1ITEMITEM_I_ITEM_SK == y.EXT_PRICECUSTOMER_ADDRESS1ITEMITEM_I_ITEM_SK && x.EXT_PRICECUSTOMER_ADDRESS1ITEM2CUSTOMERCUSTOMER_C_CUSTOMER_SK == y.EXT_PRICECUSTOMER_ADDRESS1ITEM2CUSTOMERCUSTOMER_C_CUSTOMER_SK && x.STORE_S_ZIP == y.STORE_S_ZIP;
    }
  };
  
  struct EXT_PRICECUSTOMER_ADDRESS1ITEM2CUSTOMER1_mapkey0_idxfn {
    FORCE_INLINE static size_t hash(const EXT_PRICECUSTOMER_ADDRESS1ITEM2CUSTOMER1_entry& e) {
      size_t h = 0;
      hash_combine(h, e.EXT_PRICECUSTOMER_ADDRESS1ITEMITEM_I_ITEM_SK);
      return h;
    }
    FORCE_INLINE static bool equals(const EXT_PRICECUSTOMER_ADDRESS1ITEM2CUSTOMER1_entry& x, const EXT_PRICECUSTOMER_ADDRESS1ITEM2CUSTOMER1_entry& y) {
      return x.EXT_PRICECUSTOMER_ADDRESS1ITEMITEM_I_ITEM_SK == y.EXT_PRICECUSTOMER_ADDRESS1ITEMITEM_I_ITEM_SK;
    }
  };
  
  struct EXT_PRICECUSTOMER_ADDRESS1ITEM2CUSTOMER1_mapkey1_idxfn {
    FORCE_INLINE static size_t hash(const EXT_PRICECUSTOMER_ADDRESS1ITEM2CUSTOMER1_entry& e) {
      size_t h = 0;
      hash_combine(h, e.EXT_PRICECUSTOMER_ADDRESS1ITEM2CUSTOMERCUSTOMER_C_CUSTOMER_SK);
      return h;
    }
    FORCE_INLINE static bool equals(const EXT_PRICECUSTOMER_ADDRESS1ITEM2CUSTOMER1_entry& x, const EXT_PRICECUSTOMER_ADDRESS1ITEM2CUSTOMER1_entry& y) {
      return x.EXT_PRICECUSTOMER_ADDRESS1ITEM2CUSTOMERCUSTOMER_C_CUSTOMER_SK == y.EXT_PRICECUSTOMER_ADDRESS1ITEM2CUSTOMERCUSTOMER_C_CUSTOMER_SK;
    }
  };
  
  typedef MultiHashMap<EXT_PRICECUSTOMER_ADDRESS1ITEM2CUSTOMER1_entry,DOUBLE_TYPE,
    HashIndex<EXT_PRICECUSTOMER_ADDRESS1ITEM2CUSTOMER1_entry,DOUBLE_TYPE,EXT_PRICECUSTOMER_ADDRESS1ITEM2CUSTOMER1_mapkey012_idxfn,true>,
    HashIndex<EXT_PRICECUSTOMER_ADDRESS1ITEM2CUSTOMER1_entry,DOUBLE_TYPE,EXT_PRICECUSTOMER_ADDRESS1ITEM2CUSTOMER1_mapkey0_idxfn,false>,
    HashIndex<EXT_PRICECUSTOMER_ADDRESS1ITEM2CUSTOMER1_entry,DOUBLE_TYPE,EXT_PRICECUSTOMER_ADDRESS1ITEM2CUSTOMER1_mapkey1_idxfn,false>
  > EXT_PRICECUSTOMER_ADDRESS1ITEM2CUSTOMER1_map;
  typedef HashIndex<EXT_PRICECUSTOMER_ADDRESS1ITEM2CUSTOMER1_entry,DOUBLE_TYPE,EXT_PRICECUSTOMER_ADDRESS1ITEM2CUSTOMER1_mapkey012_idxfn,true> HashIndex_EXT_PRICECUSTOMER_ADDRESS1ITEM2CUSTOMER1_map_012;
  typedef HashIndex<EXT_PRICECUSTOMER_ADDRESS1ITEM2CUSTOMER1_entry,DOUBLE_TYPE,EXT_PRICECUSTOMER_ADDRESS1ITEM2CUSTOMER1_mapkey0_idxfn,false> HashIndex_EXT_PRICECUSTOMER_ADDRESS1ITEM2CUSTOMER1_map_0;
  typedef HashIndex<EXT_PRICECUSTOMER_ADDRESS1ITEM2CUSTOMER1_entry,DOUBLE_TYPE,EXT_PRICECUSTOMER_ADDRESS1ITEM2CUSTOMER1_mapkey1_idxfn,false> HashIndex_EXT_PRICECUSTOMER_ADDRESS1ITEM2CUSTOMER1_map_1;
  
  struct EXT_PRICECUSTOMER_ADDRESS1STORE_SALES4_entry {
    long EXT_PRICECUSTOMER_ADDRESS1STORE_SALESSTORE_SALES_SS_STORE_SK; STRING_TYPE STORE_S_ZIP; long __av; 
    explicit EXT_PRICECUSTOMER_ADDRESS1STORE_SALES4_entry() { /*EXT_PRICECUSTOMER_ADDRESS1STORE_SALESSTORE_SALES_SS_STORE_SK = 0L; STORE_S_ZIP = ""; __av = 0L; */ }
    explicit EXT_PRICECUSTOMER_ADDRESS1STORE_SALES4_entry(const long c0, const STRING_TYPE& c1, const long c2) { EXT_PRICECUSTOMER_ADDRESS1STORE_SALESSTORE_SALES_SS_STORE_SK = c0; STORE_S_ZIP = c1; __av = c2; }
    EXT_PRICECUSTOMER_ADDRESS1STORE_SALES4_entry(const EXT_PRICECUSTOMER_ADDRESS1STORE_SALES4_entry& other) : EXT_PRICECUSTOMER_ADDRESS1STORE_SALESSTORE_SALES_SS_STORE_SK( other.EXT_PRICECUSTOMER_ADDRESS1STORE_SALESSTORE_SALES_SS_STORE_SK ), STORE_S_ZIP( other.STORE_S_ZIP ), __av( other.__av ) {}
    FORCE_INLINE EXT_PRICECUSTOMER_ADDRESS1STORE_SALES4_entry& modify(const long c0, const STRING_TYPE& c1) { EXT_PRICECUSTOMER_ADDRESS1STORE_SALESSTORE_SALES_SS_STORE_SK = c0; STORE_S_ZIP = c1;  return *this; }
    FORCE_INLINE EXT_PRICECUSTOMER_ADDRESS1STORE_SALES4_entry& modify0(const long c0) { EXT_PRICECUSTOMER_ADDRESS1STORE_SALESSTORE_SALES_SS_STORE_SK = c0;  return *this; }
    template<class Archive>
    void serialize(Archive& ar, const unsigned int version) const 
    {
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, EXT_PRICECUSTOMER_ADDRESS1STORE_SALESSTORE_SALES_SS_STORE_SK);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, STORE_S_ZIP);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, __av);
    }
  };
  struct EXT_PRICECUSTOMER_ADDRESS1STORE_SALES4_mapkey01_idxfn {
    FORCE_INLINE static size_t hash(const EXT_PRICECUSTOMER_ADDRESS1STORE_SALES4_entry& e) {
      size_t h = 0;
      hash_combine(h, e.EXT_PRICECUSTOMER_ADDRESS1STORE_SALESSTORE_SALES_SS_STORE_SK);
      hash_combine(h, e.STORE_S_ZIP);
      return h;
    }
    FORCE_INLINE static bool equals(const EXT_PRICECUSTOMER_ADDRESS1STORE_SALES4_entry& x, const EXT_PRICECUSTOMER_ADDRESS1STORE_SALES4_entry& y) {
      return x.EXT_PRICECUSTOMER_ADDRESS1STORE_SALESSTORE_SALES_SS_STORE_SK == y.EXT_PRICECUSTOMER_ADDRESS1STORE_SALESSTORE_SALES_SS_STORE_SK && x.STORE_S_ZIP == y.STORE_S_ZIP;
    }
  };
  
  struct EXT_PRICECUSTOMER_ADDRESS1STORE_SALES4_mapkey0_idxfn {
    FORCE_INLINE static size_t hash(const EXT_PRICECUSTOMER_ADDRESS1STORE_SALES4_entry& e) {
      size_t h = 0;
      hash_combine(h, e.EXT_PRICECUSTOMER_ADDRESS1STORE_SALESSTORE_SALES_SS_STORE_SK);
      return h;
    }
    FORCE_INLINE static bool equals(const EXT_PRICECUSTOMER_ADDRESS1STORE_SALES4_entry& x, const EXT_PRICECUSTOMER_ADDRESS1STORE_SALES4_entry& y) {
      return x.EXT_PRICECUSTOMER_ADDRESS1STORE_SALESSTORE_SALES_SS_STORE_SK == y.EXT_PRICECUSTOMER_ADDRESS1STORE_SALESSTORE_SALES_SS_STORE_SK;
    }
  };
  
  typedef MultiHashMap<EXT_PRICECUSTOMER_ADDRESS1STORE_SALES4_entry,long,
    HashIndex<EXT_PRICECUSTOMER_ADDRESS1STORE_SALES4_entry,long,EXT_PRICECUSTOMER_ADDRESS1STORE_SALES4_mapkey01_idxfn,true>,
    HashIndex<EXT_PRICECUSTOMER_ADDRESS1STORE_SALES4_entry,long,EXT_PRICECUSTOMER_ADDRESS1STORE_SALES4_mapkey0_idxfn,false>
  > EXT_PRICECUSTOMER_ADDRESS1STORE_SALES4_map;
  typedef HashIndex<EXT_PRICECUSTOMER_ADDRESS1STORE_SALES4_entry,long,EXT_PRICECUSTOMER_ADDRESS1STORE_SALES4_mapkey01_idxfn,true> HashIndex_EXT_PRICECUSTOMER_ADDRESS1STORE_SALES4_map_01;
  typedef HashIndex<EXT_PRICECUSTOMER_ADDRESS1STORE_SALES4_entry,long,EXT_PRICECUSTOMER_ADDRESS1STORE_SALES4_mapkey0_idxfn,false> HashIndex_EXT_PRICECUSTOMER_ADDRESS1STORE_SALES4_map_0;
  
  struct EXT_PRICECUSTOMER_ADDRESS1CUSTOMER1_entry {
    long EXT_PRICECUSTOMER_ADDRESS1CUSTOMERCUSTOMER_C_CUSTOMER_SK; long ITEM_I_MANUFACT_ID; STRING_TYPE ITEM_I_MANUFACT; STRING_TYPE STORE_S_ZIP; STRING_TYPE BRAND; long BRAND_ID; DOUBLE_TYPE __av; 
    explicit EXT_PRICECUSTOMER_ADDRESS1CUSTOMER1_entry() { /*EXT_PRICECUSTOMER_ADDRESS1CUSTOMERCUSTOMER_C_CUSTOMER_SK = 0L; ITEM_I_MANUFACT_ID = 0L; ITEM_I_MANUFACT = ""; STORE_S_ZIP = ""; BRAND = ""; BRAND_ID = 0L; __av = 0.0; */ }
    explicit EXT_PRICECUSTOMER_ADDRESS1CUSTOMER1_entry(const long c0, const long c1, const STRING_TYPE& c2, const STRING_TYPE& c3, const STRING_TYPE& c4, const long c5, const DOUBLE_TYPE c6) { EXT_PRICECUSTOMER_ADDRESS1CUSTOMERCUSTOMER_C_CUSTOMER_SK = c0; ITEM_I_MANUFACT_ID = c1; ITEM_I_MANUFACT = c2; STORE_S_ZIP = c3; BRAND = c4; BRAND_ID = c5; __av = c6; }
    EXT_PRICECUSTOMER_ADDRESS1CUSTOMER1_entry(const EXT_PRICECUSTOMER_ADDRESS1CUSTOMER1_entry& other) : EXT_PRICECUSTOMER_ADDRESS1CUSTOMERCUSTOMER_C_CUSTOMER_SK( other.EXT_PRICECUSTOMER_ADDRESS1CUSTOMERCUSTOMER_C_CUSTOMER_SK ), ITEM_I_MANUFACT_ID( other.ITEM_I_MANUFACT_ID ), ITEM_I_MANUFACT( other.ITEM_I_MANUFACT ), STORE_S_ZIP( other.STORE_S_ZIP ), BRAND( other.BRAND ), BRAND_ID( other.BRAND_ID ), __av( other.__av ) {}
    FORCE_INLINE EXT_PRICECUSTOMER_ADDRESS1CUSTOMER1_entry& modify(const long c0, const long c1, const STRING_TYPE& c2, const STRING_TYPE& c3, const STRING_TYPE& c4, const long c5) { EXT_PRICECUSTOMER_ADDRESS1CUSTOMERCUSTOMER_C_CUSTOMER_SK = c0; ITEM_I_MANUFACT_ID = c1; ITEM_I_MANUFACT = c2; STORE_S_ZIP = c3; BRAND = c4; BRAND_ID = c5;  return *this; }
    FORCE_INLINE EXT_PRICECUSTOMER_ADDRESS1CUSTOMER1_entry& modify0(const long c0) { EXT_PRICECUSTOMER_ADDRESS1CUSTOMERCUSTOMER_C_CUSTOMER_SK = c0;  return *this; }
    template<class Archive>
    void serialize(Archive& ar, const unsigned int version) const 
    {
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, EXT_PRICECUSTOMER_ADDRESS1CUSTOMERCUSTOMER_C_CUSTOMER_SK);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, ITEM_I_MANUFACT_ID);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, ITEM_I_MANUFACT);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, STORE_S_ZIP);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, BRAND);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, BRAND_ID);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, __av);
    }
  };
  struct EXT_PRICECUSTOMER_ADDRESS1CUSTOMER1_mapkey012345_idxfn {
    FORCE_INLINE static size_t hash(const EXT_PRICECUSTOMER_ADDRESS1CUSTOMER1_entry& e) {
      size_t h = 0;
      hash_combine(h, e.EXT_PRICECUSTOMER_ADDRESS1CUSTOMERCUSTOMER_C_CUSTOMER_SK);
      hash_combine(h, e.ITEM_I_MANUFACT_ID);
      hash_combine(h, e.ITEM_I_MANUFACT);
      hash_combine(h, e.STORE_S_ZIP);
      hash_combine(h, e.BRAND);
      hash_combine(h, e.BRAND_ID);
      return h;
    }
    FORCE_INLINE static bool equals(const EXT_PRICECUSTOMER_ADDRESS1CUSTOMER1_entry& x, const EXT_PRICECUSTOMER_ADDRESS1CUSTOMER1_entry& y) {
      return x.EXT_PRICECUSTOMER_ADDRESS1CUSTOMERCUSTOMER_C_CUSTOMER_SK == y.EXT_PRICECUSTOMER_ADDRESS1CUSTOMERCUSTOMER_C_CUSTOMER_SK && x.ITEM_I_MANUFACT_ID == y.ITEM_I_MANUFACT_ID && x.ITEM_I_MANUFACT == y.ITEM_I_MANUFACT && x.STORE_S_ZIP == y.STORE_S_ZIP && x.BRAND == y.BRAND && x.BRAND_ID == y.BRAND_ID;
    }
  };
  
  struct EXT_PRICECUSTOMER_ADDRESS1CUSTOMER1_mapkey0_idxfn {
    FORCE_INLINE static size_t hash(const EXT_PRICECUSTOMER_ADDRESS1CUSTOMER1_entry& e) {
      size_t h = 0;
      hash_combine(h, e.EXT_PRICECUSTOMER_ADDRESS1CUSTOMERCUSTOMER_C_CUSTOMER_SK);
      return h;
    }
    FORCE_INLINE static bool equals(const EXT_PRICECUSTOMER_ADDRESS1CUSTOMER1_entry& x, const EXT_PRICECUSTOMER_ADDRESS1CUSTOMER1_entry& y) {
      return x.EXT_PRICECUSTOMER_ADDRESS1CUSTOMERCUSTOMER_C_CUSTOMER_SK == y.EXT_PRICECUSTOMER_ADDRESS1CUSTOMERCUSTOMER_C_CUSTOMER_SK;
    }
  };
  
  typedef MultiHashMap<EXT_PRICECUSTOMER_ADDRESS1CUSTOMER1_entry,DOUBLE_TYPE,
    HashIndex<EXT_PRICECUSTOMER_ADDRESS1CUSTOMER1_entry,DOUBLE_TYPE,EXT_PRICECUSTOMER_ADDRESS1CUSTOMER1_mapkey012345_idxfn,true>,
    HashIndex<EXT_PRICECUSTOMER_ADDRESS1CUSTOMER1_entry,DOUBLE_TYPE,EXT_PRICECUSTOMER_ADDRESS1CUSTOMER1_mapkey0_idxfn,false>
  > EXT_PRICECUSTOMER_ADDRESS1CUSTOMER1_map;
  typedef HashIndex<EXT_PRICECUSTOMER_ADDRESS1CUSTOMER1_entry,DOUBLE_TYPE,EXT_PRICECUSTOMER_ADDRESS1CUSTOMER1_mapkey012345_idxfn,true> HashIndex_EXT_PRICECUSTOMER_ADDRESS1CUSTOMER1_map_012345;
  typedef HashIndex<EXT_PRICECUSTOMER_ADDRESS1CUSTOMER1_entry,DOUBLE_TYPE,EXT_PRICECUSTOMER_ADDRESS1CUSTOMER1_mapkey0_idxfn,false> HashIndex_EXT_PRICECUSTOMER_ADDRESS1CUSTOMER1_map_0;
  
  struct EXT_PRICECUSTOMER1_entry {
    long EXT_PRICECUSTOMERCUSTOMER_C_CUSTOMER_SK; long EXT_PRICECUSTOMERCUSTOMER_C_CURRENT_ADDR_SK; long ITEM_I_MANUFACT_ID; STRING_TYPE ITEM_I_MANUFACT; STRING_TYPE BRAND; long BRAND_ID; DOUBLE_TYPE __av; 
    explicit EXT_PRICECUSTOMER1_entry() { /*EXT_PRICECUSTOMERCUSTOMER_C_CUSTOMER_SK = 0L; EXT_PRICECUSTOMERCUSTOMER_C_CURRENT_ADDR_SK = 0L; ITEM_I_MANUFACT_ID = 0L; ITEM_I_MANUFACT = ""; BRAND = ""; BRAND_ID = 0L; __av = 0.0; */ }
    explicit EXT_PRICECUSTOMER1_entry(const long c0, const long c1, const long c2, const STRING_TYPE& c3, const STRING_TYPE& c4, const long c5, const DOUBLE_TYPE c6) { EXT_PRICECUSTOMERCUSTOMER_C_CUSTOMER_SK = c0; EXT_PRICECUSTOMERCUSTOMER_C_CURRENT_ADDR_SK = c1; ITEM_I_MANUFACT_ID = c2; ITEM_I_MANUFACT = c3; BRAND = c4; BRAND_ID = c5; __av = c6; }
    EXT_PRICECUSTOMER1_entry(const EXT_PRICECUSTOMER1_entry& other) : EXT_PRICECUSTOMERCUSTOMER_C_CUSTOMER_SK( other.EXT_PRICECUSTOMERCUSTOMER_C_CUSTOMER_SK ), EXT_PRICECUSTOMERCUSTOMER_C_CURRENT_ADDR_SK( other.EXT_PRICECUSTOMERCUSTOMER_C_CURRENT_ADDR_SK ), ITEM_I_MANUFACT_ID( other.ITEM_I_MANUFACT_ID ), ITEM_I_MANUFACT( other.ITEM_I_MANUFACT ), BRAND( other.BRAND ), BRAND_ID( other.BRAND_ID ), __av( other.__av ) {}
    FORCE_INLINE EXT_PRICECUSTOMER1_entry& modify(const long c0, const long c1, const long c2, const STRING_TYPE& c3, const STRING_TYPE& c4, const long c5) { EXT_PRICECUSTOMERCUSTOMER_C_CUSTOMER_SK = c0; EXT_PRICECUSTOMERCUSTOMER_C_CURRENT_ADDR_SK = c1; ITEM_I_MANUFACT_ID = c2; ITEM_I_MANUFACT = c3; BRAND = c4; BRAND_ID = c5;  return *this; }
    FORCE_INLINE EXT_PRICECUSTOMER1_entry& modify01(const long c0, const long c1) { EXT_PRICECUSTOMERCUSTOMER_C_CUSTOMER_SK = c0; EXT_PRICECUSTOMERCUSTOMER_C_CURRENT_ADDR_SK = c1;  return *this; }
    template<class Archive>
    void serialize(Archive& ar, const unsigned int version) const 
    {
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, EXT_PRICECUSTOMERCUSTOMER_C_CUSTOMER_SK);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, EXT_PRICECUSTOMERCUSTOMER_C_CURRENT_ADDR_SK);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, ITEM_I_MANUFACT_ID);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, ITEM_I_MANUFACT);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, BRAND);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, BRAND_ID);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, __av);
    }
  };
  struct EXT_PRICECUSTOMER1_mapkey012345_idxfn {
    FORCE_INLINE static size_t hash(const EXT_PRICECUSTOMER1_entry& e) {
      size_t h = 0;
      hash_combine(h, e.EXT_PRICECUSTOMERCUSTOMER_C_CUSTOMER_SK);
      hash_combine(h, e.EXT_PRICECUSTOMERCUSTOMER_C_CURRENT_ADDR_SK);
      hash_combine(h, e.ITEM_I_MANUFACT_ID);
      hash_combine(h, e.ITEM_I_MANUFACT);
      hash_combine(h, e.BRAND);
      hash_combine(h, e.BRAND_ID);
      return h;
    }
    FORCE_INLINE static bool equals(const EXT_PRICECUSTOMER1_entry& x, const EXT_PRICECUSTOMER1_entry& y) {
      return x.EXT_PRICECUSTOMERCUSTOMER_C_CUSTOMER_SK == y.EXT_PRICECUSTOMERCUSTOMER_C_CUSTOMER_SK && x.EXT_PRICECUSTOMERCUSTOMER_C_CURRENT_ADDR_SK == y.EXT_PRICECUSTOMERCUSTOMER_C_CURRENT_ADDR_SK && x.ITEM_I_MANUFACT_ID == y.ITEM_I_MANUFACT_ID && x.ITEM_I_MANUFACT == y.ITEM_I_MANUFACT && x.BRAND == y.BRAND && x.BRAND_ID == y.BRAND_ID;
    }
  };
  
  struct EXT_PRICECUSTOMER1_mapkey01_idxfn {
    FORCE_INLINE static size_t hash(const EXT_PRICECUSTOMER1_entry& e) {
      size_t h = 0;
      hash_combine(h, e.EXT_PRICECUSTOMERCUSTOMER_C_CUSTOMER_SK);
      hash_combine(h, e.EXT_PRICECUSTOMERCUSTOMER_C_CURRENT_ADDR_SK);
      return h;
    }
    FORCE_INLINE static bool equals(const EXT_PRICECUSTOMER1_entry& x, const EXT_PRICECUSTOMER1_entry& y) {
      return x.EXT_PRICECUSTOMERCUSTOMER_C_CUSTOMER_SK == y.EXT_PRICECUSTOMERCUSTOMER_C_CUSTOMER_SK && x.EXT_PRICECUSTOMERCUSTOMER_C_CURRENT_ADDR_SK == y.EXT_PRICECUSTOMERCUSTOMER_C_CURRENT_ADDR_SK;
    }
  };
  
  typedef MultiHashMap<EXT_PRICECUSTOMER1_entry,DOUBLE_TYPE,
    HashIndex<EXT_PRICECUSTOMER1_entry,DOUBLE_TYPE,EXT_PRICECUSTOMER1_mapkey012345_idxfn,true>,
    HashIndex<EXT_PRICECUSTOMER1_entry,DOUBLE_TYPE,EXT_PRICECUSTOMER1_mapkey01_idxfn,false>
  > EXT_PRICECUSTOMER1_map;
  typedef HashIndex<EXT_PRICECUSTOMER1_entry,DOUBLE_TYPE,EXT_PRICECUSTOMER1_mapkey012345_idxfn,true> HashIndex_EXT_PRICECUSTOMER1_map_012345;
  typedef HashIndex<EXT_PRICECUSTOMER1_entry,DOUBLE_TYPE,EXT_PRICECUSTOMER1_mapkey01_idxfn,false> HashIndex_EXT_PRICECUSTOMER1_map_01;
  
  struct EXT_PRICECUSTOMER1ITEM2_entry {
    long EXT_PRICECUSTOMER1ITEMITEM_I_ITEM_SK; long EXT_PRICECUSTOMERCUSTOMER_C_CUSTOMER_SK; long EXT_PRICECUSTOMERCUSTOMER_C_CURRENT_ADDR_SK; DOUBLE_TYPE __av; 
    explicit EXT_PRICECUSTOMER1ITEM2_entry() { /*EXT_PRICECUSTOMER1ITEMITEM_I_ITEM_SK = 0L; EXT_PRICECUSTOMERCUSTOMER_C_CUSTOMER_SK = 0L; EXT_PRICECUSTOMERCUSTOMER_C_CURRENT_ADDR_SK = 0L; __av = 0.0; */ }
    explicit EXT_PRICECUSTOMER1ITEM2_entry(const long c0, const long c1, const long c2, const DOUBLE_TYPE c3) { EXT_PRICECUSTOMER1ITEMITEM_I_ITEM_SK = c0; EXT_PRICECUSTOMERCUSTOMER_C_CUSTOMER_SK = c1; EXT_PRICECUSTOMERCUSTOMER_C_CURRENT_ADDR_SK = c2; __av = c3; }
    EXT_PRICECUSTOMER1ITEM2_entry(const EXT_PRICECUSTOMER1ITEM2_entry& other) : EXT_PRICECUSTOMER1ITEMITEM_I_ITEM_SK( other.EXT_PRICECUSTOMER1ITEMITEM_I_ITEM_SK ), EXT_PRICECUSTOMERCUSTOMER_C_CUSTOMER_SK( other.EXT_PRICECUSTOMERCUSTOMER_C_CUSTOMER_SK ), EXT_PRICECUSTOMERCUSTOMER_C_CURRENT_ADDR_SK( other.EXT_PRICECUSTOMERCUSTOMER_C_CURRENT_ADDR_SK ), __av( other.__av ) {}
    FORCE_INLINE EXT_PRICECUSTOMER1ITEM2_entry& modify(const long c0, const long c1, const long c2) { EXT_PRICECUSTOMER1ITEMITEM_I_ITEM_SK = c0; EXT_PRICECUSTOMERCUSTOMER_C_CUSTOMER_SK = c1; EXT_PRICECUSTOMERCUSTOMER_C_CURRENT_ADDR_SK = c2;  return *this; }
    FORCE_INLINE EXT_PRICECUSTOMER1ITEM2_entry& modify0(const long c0) { EXT_PRICECUSTOMER1ITEMITEM_I_ITEM_SK = c0;  return *this; }
    FORCE_INLINE EXT_PRICECUSTOMER1ITEM2_entry& modify12(const long c1, const long c2) { EXT_PRICECUSTOMERCUSTOMER_C_CUSTOMER_SK = c1; EXT_PRICECUSTOMERCUSTOMER_C_CURRENT_ADDR_SK = c2;  return *this; }
    template<class Archive>
    void serialize(Archive& ar, const unsigned int version) const 
    {
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, EXT_PRICECUSTOMER1ITEMITEM_I_ITEM_SK);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, EXT_PRICECUSTOMERCUSTOMER_C_CUSTOMER_SK);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, EXT_PRICECUSTOMERCUSTOMER_C_CURRENT_ADDR_SK);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, __av);
    }
  };
  struct EXT_PRICECUSTOMER1ITEM2_mapkey012_idxfn {
    FORCE_INLINE static size_t hash(const EXT_PRICECUSTOMER1ITEM2_entry& e) {
      size_t h = 0;
      hash_combine(h, e.EXT_PRICECUSTOMER1ITEMITEM_I_ITEM_SK);
      hash_combine(h, e.EXT_PRICECUSTOMERCUSTOMER_C_CUSTOMER_SK);
      hash_combine(h, e.EXT_PRICECUSTOMERCUSTOMER_C_CURRENT_ADDR_SK);
      return h;
    }
    FORCE_INLINE static bool equals(const EXT_PRICECUSTOMER1ITEM2_entry& x, const EXT_PRICECUSTOMER1ITEM2_entry& y) {
      return x.EXT_PRICECUSTOMER1ITEMITEM_I_ITEM_SK == y.EXT_PRICECUSTOMER1ITEMITEM_I_ITEM_SK && x.EXT_PRICECUSTOMERCUSTOMER_C_CUSTOMER_SK == y.EXT_PRICECUSTOMERCUSTOMER_C_CUSTOMER_SK && x.EXT_PRICECUSTOMERCUSTOMER_C_CURRENT_ADDR_SK == y.EXT_PRICECUSTOMERCUSTOMER_C_CURRENT_ADDR_SK;
    }
  };
  
  struct EXT_PRICECUSTOMER1ITEM2_mapkey0_idxfn {
    FORCE_INLINE static size_t hash(const EXT_PRICECUSTOMER1ITEM2_entry& e) {
      size_t h = 0;
      hash_combine(h, e.EXT_PRICECUSTOMER1ITEMITEM_I_ITEM_SK);
      return h;
    }
    FORCE_INLINE static bool equals(const EXT_PRICECUSTOMER1ITEM2_entry& x, const EXT_PRICECUSTOMER1ITEM2_entry& y) {
      return x.EXT_PRICECUSTOMER1ITEMITEM_I_ITEM_SK == y.EXT_PRICECUSTOMER1ITEMITEM_I_ITEM_SK;
    }
  };
  
  struct EXT_PRICECUSTOMER1ITEM2_mapkey12_idxfn {
    FORCE_INLINE static size_t hash(const EXT_PRICECUSTOMER1ITEM2_entry& e) {
      size_t h = 0;
      hash_combine(h, e.EXT_PRICECUSTOMERCUSTOMER_C_CUSTOMER_SK);
      hash_combine(h, e.EXT_PRICECUSTOMERCUSTOMER_C_CURRENT_ADDR_SK);
      return h;
    }
    FORCE_INLINE static bool equals(const EXT_PRICECUSTOMER1ITEM2_entry& x, const EXT_PRICECUSTOMER1ITEM2_entry& y) {
      return x.EXT_PRICECUSTOMERCUSTOMER_C_CUSTOMER_SK == y.EXT_PRICECUSTOMERCUSTOMER_C_CUSTOMER_SK && x.EXT_PRICECUSTOMERCUSTOMER_C_CURRENT_ADDR_SK == y.EXT_PRICECUSTOMERCUSTOMER_C_CURRENT_ADDR_SK;
    }
  };
  
  typedef MultiHashMap<EXT_PRICECUSTOMER1ITEM2_entry,DOUBLE_TYPE,
    HashIndex<EXT_PRICECUSTOMER1ITEM2_entry,DOUBLE_TYPE,EXT_PRICECUSTOMER1ITEM2_mapkey012_idxfn,true>,
    HashIndex<EXT_PRICECUSTOMER1ITEM2_entry,DOUBLE_TYPE,EXT_PRICECUSTOMER1ITEM2_mapkey0_idxfn,false>,
    HashIndex<EXT_PRICECUSTOMER1ITEM2_entry,DOUBLE_TYPE,EXT_PRICECUSTOMER1ITEM2_mapkey12_idxfn,false>
  > EXT_PRICECUSTOMER1ITEM2_map;
  typedef HashIndex<EXT_PRICECUSTOMER1ITEM2_entry,DOUBLE_TYPE,EXT_PRICECUSTOMER1ITEM2_mapkey012_idxfn,true> HashIndex_EXT_PRICECUSTOMER1ITEM2_map_012;
  typedef HashIndex<EXT_PRICECUSTOMER1ITEM2_entry,DOUBLE_TYPE,EXT_PRICECUSTOMER1ITEM2_mapkey0_idxfn,false> HashIndex_EXT_PRICECUSTOMER1ITEM2_map_0;
  typedef HashIndex<EXT_PRICECUSTOMER1ITEM2_entry,DOUBLE_TYPE,EXT_PRICECUSTOMER1ITEM2_mapkey12_idxfn,false> HashIndex_EXT_PRICECUSTOMER1ITEM2_map_12;
  
  struct EXT_PRICECUSTOMER1STORE_SALES3_entry {
    long EXT_PRICECUSTOMER1STORE_SALESSTORE_SALES_SS_STORE_SK; long EXT_PRICECUSTOMERCUSTOMER_C_CURRENT_ADDR_SK; long __av; 
    explicit EXT_PRICECUSTOMER1STORE_SALES3_entry() { /*EXT_PRICECUSTOMER1STORE_SALESSTORE_SALES_SS_STORE_SK = 0L; EXT_PRICECUSTOMERCUSTOMER_C_CURRENT_ADDR_SK = 0L; __av = 0L; */ }
    explicit EXT_PRICECUSTOMER1STORE_SALES3_entry(const long c0, const long c1, const long c2) { EXT_PRICECUSTOMER1STORE_SALESSTORE_SALES_SS_STORE_SK = c0; EXT_PRICECUSTOMERCUSTOMER_C_CURRENT_ADDR_SK = c1; __av = c2; }
    EXT_PRICECUSTOMER1STORE_SALES3_entry(const EXT_PRICECUSTOMER1STORE_SALES3_entry& other) : EXT_PRICECUSTOMER1STORE_SALESSTORE_SALES_SS_STORE_SK( other.EXT_PRICECUSTOMER1STORE_SALESSTORE_SALES_SS_STORE_SK ), EXT_PRICECUSTOMERCUSTOMER_C_CURRENT_ADDR_SK( other.EXT_PRICECUSTOMERCUSTOMER_C_CURRENT_ADDR_SK ), __av( other.__av ) {}
    FORCE_INLINE EXT_PRICECUSTOMER1STORE_SALES3_entry& modify(const long c0, const long c1) { EXT_PRICECUSTOMER1STORE_SALESSTORE_SALES_SS_STORE_SK = c0; EXT_PRICECUSTOMERCUSTOMER_C_CURRENT_ADDR_SK = c1;  return *this; }
    FORCE_INLINE EXT_PRICECUSTOMER1STORE_SALES3_entry& modify0(const long c0) { EXT_PRICECUSTOMER1STORE_SALESSTORE_SALES_SS_STORE_SK = c0;  return *this; }
    FORCE_INLINE EXT_PRICECUSTOMER1STORE_SALES3_entry& modify1(const long c1) { EXT_PRICECUSTOMERCUSTOMER_C_CURRENT_ADDR_SK = c1;  return *this; }
    template<class Archive>
    void serialize(Archive& ar, const unsigned int version) const 
    {
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, EXT_PRICECUSTOMER1STORE_SALESSTORE_SALES_SS_STORE_SK);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, EXT_PRICECUSTOMERCUSTOMER_C_CURRENT_ADDR_SK);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, __av);
    }
  };
  struct EXT_PRICECUSTOMER1STORE_SALES3_mapkey01_idxfn {
    FORCE_INLINE static size_t hash(const EXT_PRICECUSTOMER1STORE_SALES3_entry& e) {
      size_t h = 0;
      hash_combine(h, e.EXT_PRICECUSTOMER1STORE_SALESSTORE_SALES_SS_STORE_SK);
      hash_combine(h, e.EXT_PRICECUSTOMERCUSTOMER_C_CURRENT_ADDR_SK);
      return h;
    }
    FORCE_INLINE static bool equals(const EXT_PRICECUSTOMER1STORE_SALES3_entry& x, const EXT_PRICECUSTOMER1STORE_SALES3_entry& y) {
      return x.EXT_PRICECUSTOMER1STORE_SALESSTORE_SALES_SS_STORE_SK == y.EXT_PRICECUSTOMER1STORE_SALESSTORE_SALES_SS_STORE_SK && x.EXT_PRICECUSTOMERCUSTOMER_C_CURRENT_ADDR_SK == y.EXT_PRICECUSTOMERCUSTOMER_C_CURRENT_ADDR_SK;
    }
  };
  
  struct EXT_PRICECUSTOMER1STORE_SALES3_mapkey0_idxfn {
    FORCE_INLINE static size_t hash(const EXT_PRICECUSTOMER1STORE_SALES3_entry& e) {
      size_t h = 0;
      hash_combine(h, e.EXT_PRICECUSTOMER1STORE_SALESSTORE_SALES_SS_STORE_SK);
      return h;
    }
    FORCE_INLINE static bool equals(const EXT_PRICECUSTOMER1STORE_SALES3_entry& x, const EXT_PRICECUSTOMER1STORE_SALES3_entry& y) {
      return x.EXT_PRICECUSTOMER1STORE_SALESSTORE_SALES_SS_STORE_SK == y.EXT_PRICECUSTOMER1STORE_SALESSTORE_SALES_SS_STORE_SK;
    }
  };
  
  struct EXT_PRICECUSTOMER1STORE_SALES3_mapkey1_idxfn {
    FORCE_INLINE static size_t hash(const EXT_PRICECUSTOMER1STORE_SALES3_entry& e) {
      size_t h = 0;
      hash_combine(h, e.EXT_PRICECUSTOMERCUSTOMER_C_CURRENT_ADDR_SK);
      return h;
    }
    FORCE_INLINE static bool equals(const EXT_PRICECUSTOMER1STORE_SALES3_entry& x, const EXT_PRICECUSTOMER1STORE_SALES3_entry& y) {
      return x.EXT_PRICECUSTOMERCUSTOMER_C_CURRENT_ADDR_SK == y.EXT_PRICECUSTOMERCUSTOMER_C_CURRENT_ADDR_SK;
    }
  };
  
  typedef MultiHashMap<EXT_PRICECUSTOMER1STORE_SALES3_entry,long,
    HashIndex<EXT_PRICECUSTOMER1STORE_SALES3_entry,long,EXT_PRICECUSTOMER1STORE_SALES3_mapkey01_idxfn,true>,
    HashIndex<EXT_PRICECUSTOMER1STORE_SALES3_entry,long,EXT_PRICECUSTOMER1STORE_SALES3_mapkey0_idxfn,false>,
    HashIndex<EXT_PRICECUSTOMER1STORE_SALES3_entry,long,EXT_PRICECUSTOMER1STORE_SALES3_mapkey1_idxfn,false>
  > EXT_PRICECUSTOMER1STORE_SALES3_map;
  typedef HashIndex<EXT_PRICECUSTOMER1STORE_SALES3_entry,long,EXT_PRICECUSTOMER1STORE_SALES3_mapkey01_idxfn,true> HashIndex_EXT_PRICECUSTOMER1STORE_SALES3_map_01;
  typedef HashIndex<EXT_PRICECUSTOMER1STORE_SALES3_entry,long,EXT_PRICECUSTOMER1STORE_SALES3_mapkey0_idxfn,false> HashIndex_EXT_PRICECUSTOMER1STORE_SALES3_map_0;
  typedef HashIndex<EXT_PRICECUSTOMER1STORE_SALES3_entry,long,EXT_PRICECUSTOMER1STORE_SALES3_mapkey1_idxfn,false> HashIndex_EXT_PRICECUSTOMER1STORE_SALES3_map_1;
  
  struct EXT_PRICEITEM2_entry {
    long EXT_PRICEITEMITEM_I_ITEM_SK; DOUBLE_TYPE __av; 
    explicit EXT_PRICEITEM2_entry() { /*EXT_PRICEITEMITEM_I_ITEM_SK = 0L; __av = 0.0; */ }
    explicit EXT_PRICEITEM2_entry(const long c0, const DOUBLE_TYPE c1) { EXT_PRICEITEMITEM_I_ITEM_SK = c0; __av = c1; }
    EXT_PRICEITEM2_entry(const EXT_PRICEITEM2_entry& other) : EXT_PRICEITEMITEM_I_ITEM_SK( other.EXT_PRICEITEMITEM_I_ITEM_SK ), __av( other.__av ) {}
    FORCE_INLINE EXT_PRICEITEM2_entry& modify(const long c0) { EXT_PRICEITEMITEM_I_ITEM_SK = c0;  return *this; }
    template<class Archive>
    void serialize(Archive& ar, const unsigned int version) const 
    {
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, EXT_PRICEITEMITEM_I_ITEM_SK);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, __av);
    }
  };
  struct EXT_PRICEITEM2_mapkey0_idxfn {
    FORCE_INLINE static size_t hash(const EXT_PRICEITEM2_entry& e) {
      size_t h = 0;
      hash_combine(h, e.EXT_PRICEITEMITEM_I_ITEM_SK);
      return h;
    }
    FORCE_INLINE static bool equals(const EXT_PRICEITEM2_entry& x, const EXT_PRICEITEM2_entry& y) {
      return x.EXT_PRICEITEMITEM_I_ITEM_SK == y.EXT_PRICEITEMITEM_I_ITEM_SK;
    }
  };
  
  typedef MultiHashMap<EXT_PRICEITEM2_entry,DOUBLE_TYPE,
    HashIndex<EXT_PRICEITEM2_entry,DOUBLE_TYPE,EXT_PRICEITEM2_mapkey0_idxfn,true>
  > EXT_PRICEITEM2_map;
  typedef HashIndex<EXT_PRICEITEM2_entry,DOUBLE_TYPE,EXT_PRICEITEM2_mapkey0_idxfn,true> HashIndex_EXT_PRICEITEM2_map_0;
  
  struct EXT_PRICESTORE_SALES1_entry {
    long EXT_PRICESTORE_SALESSTORE_SALES_SS_ITEM_SK; long ITEM_I_MANUFACT_ID; STRING_TYPE ITEM_I_MANUFACT; STRING_TYPE BRAND; long BRAND_ID; long __av; 
    explicit EXT_PRICESTORE_SALES1_entry() { /*EXT_PRICESTORE_SALESSTORE_SALES_SS_ITEM_SK = 0L; ITEM_I_MANUFACT_ID = 0L; ITEM_I_MANUFACT = ""; BRAND = ""; BRAND_ID = 0L; __av = 0L; */ }
    explicit EXT_PRICESTORE_SALES1_entry(const long c0, const long c1, const STRING_TYPE& c2, const STRING_TYPE& c3, const long c4, const long c5) { EXT_PRICESTORE_SALESSTORE_SALES_SS_ITEM_SK = c0; ITEM_I_MANUFACT_ID = c1; ITEM_I_MANUFACT = c2; BRAND = c3; BRAND_ID = c4; __av = c5; }
    EXT_PRICESTORE_SALES1_entry(const EXT_PRICESTORE_SALES1_entry& other) : EXT_PRICESTORE_SALESSTORE_SALES_SS_ITEM_SK( other.EXT_PRICESTORE_SALESSTORE_SALES_SS_ITEM_SK ), ITEM_I_MANUFACT_ID( other.ITEM_I_MANUFACT_ID ), ITEM_I_MANUFACT( other.ITEM_I_MANUFACT ), BRAND( other.BRAND ), BRAND_ID( other.BRAND_ID ), __av( other.__av ) {}
    FORCE_INLINE EXT_PRICESTORE_SALES1_entry& modify(const long c0, const long c1, const STRING_TYPE& c2, const STRING_TYPE& c3, const long c4) { EXT_PRICESTORE_SALESSTORE_SALES_SS_ITEM_SK = c0; ITEM_I_MANUFACT_ID = c1; ITEM_I_MANUFACT = c2; BRAND = c3; BRAND_ID = c4;  return *this; }
    FORCE_INLINE EXT_PRICESTORE_SALES1_entry& modify0(const long c0) { EXT_PRICESTORE_SALESSTORE_SALES_SS_ITEM_SK = c0;  return *this; }
    template<class Archive>
    void serialize(Archive& ar, const unsigned int version) const 
    {
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, EXT_PRICESTORE_SALESSTORE_SALES_SS_ITEM_SK);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, ITEM_I_MANUFACT_ID);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, ITEM_I_MANUFACT);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, BRAND);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, BRAND_ID);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, __av);
    }
  };
  struct EXT_PRICESTORE_SALES1_mapkey01234_idxfn {
    FORCE_INLINE static size_t hash(const EXT_PRICESTORE_SALES1_entry& e) {
      size_t h = 0;
      hash_combine(h, e.EXT_PRICESTORE_SALESSTORE_SALES_SS_ITEM_SK);
      hash_combine(h, e.ITEM_I_MANUFACT_ID);
      hash_combine(h, e.ITEM_I_MANUFACT);
      hash_combine(h, e.BRAND);
      hash_combine(h, e.BRAND_ID);
      return h;
    }
    FORCE_INLINE static bool equals(const EXT_PRICESTORE_SALES1_entry& x, const EXT_PRICESTORE_SALES1_entry& y) {
      return x.EXT_PRICESTORE_SALESSTORE_SALES_SS_ITEM_SK == y.EXT_PRICESTORE_SALESSTORE_SALES_SS_ITEM_SK && x.ITEM_I_MANUFACT_ID == y.ITEM_I_MANUFACT_ID && x.ITEM_I_MANUFACT == y.ITEM_I_MANUFACT && x.BRAND == y.BRAND && x.BRAND_ID == y.BRAND_ID;
    }
  };
  
  struct EXT_PRICESTORE_SALES1_mapkey0_idxfn {
    FORCE_INLINE static size_t hash(const EXT_PRICESTORE_SALES1_entry& e) {
      size_t h = 0;
      hash_combine(h, e.EXT_PRICESTORE_SALESSTORE_SALES_SS_ITEM_SK);
      return h;
    }
    FORCE_INLINE static bool equals(const EXT_PRICESTORE_SALES1_entry& x, const EXT_PRICESTORE_SALES1_entry& y) {
      return x.EXT_PRICESTORE_SALESSTORE_SALES_SS_ITEM_SK == y.EXT_PRICESTORE_SALESSTORE_SALES_SS_ITEM_SK;
    }
  };
  
  typedef MultiHashMap<EXT_PRICESTORE_SALES1_entry,long,
    HashIndex<EXT_PRICESTORE_SALES1_entry,long,EXT_PRICESTORE_SALES1_mapkey01234_idxfn,true>,
    HashIndex<EXT_PRICESTORE_SALES1_entry,long,EXT_PRICESTORE_SALES1_mapkey0_idxfn,false>
  > EXT_PRICESTORE_SALES1_map;
  typedef HashIndex<EXT_PRICESTORE_SALES1_entry,long,EXT_PRICESTORE_SALES1_mapkey01234_idxfn,true> HashIndex_EXT_PRICESTORE_SALES1_map_01234;
  typedef HashIndex<EXT_PRICESTORE_SALES1_entry,long,EXT_PRICESTORE_SALES1_mapkey0_idxfn,false> HashIndex_EXT_PRICESTORE_SALES1_map_0;
  
  struct EXT_PRICESTORE_SALES2_entry {
    long EXT_PRICESTORE_SALESSTORE_SALES_SS_SOLD_DATE_SK; long __av; 
    explicit EXT_PRICESTORE_SALES2_entry() { /*EXT_PRICESTORE_SALESSTORE_SALES_SS_SOLD_DATE_SK = 0L; __av = 0L; */ }
    explicit EXT_PRICESTORE_SALES2_entry(const long c0, const long c1) { EXT_PRICESTORE_SALESSTORE_SALES_SS_SOLD_DATE_SK = c0; __av = c1; }
    EXT_PRICESTORE_SALES2_entry(const EXT_PRICESTORE_SALES2_entry& other) : EXT_PRICESTORE_SALESSTORE_SALES_SS_SOLD_DATE_SK( other.EXT_PRICESTORE_SALESSTORE_SALES_SS_SOLD_DATE_SK ), __av( other.__av ) {}
    FORCE_INLINE EXT_PRICESTORE_SALES2_entry& modify(const long c0) { EXT_PRICESTORE_SALESSTORE_SALES_SS_SOLD_DATE_SK = c0;  return *this; }
    template<class Archive>
    void serialize(Archive& ar, const unsigned int version) const 
    {
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, EXT_PRICESTORE_SALESSTORE_SALES_SS_SOLD_DATE_SK);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, __av);
    }
  };
  struct EXT_PRICESTORE_SALES2_mapkey0_idxfn {
    FORCE_INLINE static size_t hash(const EXT_PRICESTORE_SALES2_entry& e) {
      size_t h = 0;
      hash_combine(h, e.EXT_PRICESTORE_SALESSTORE_SALES_SS_SOLD_DATE_SK);
      return h;
    }
    FORCE_INLINE static bool equals(const EXT_PRICESTORE_SALES2_entry& x, const EXT_PRICESTORE_SALES2_entry& y) {
      return x.EXT_PRICESTORE_SALESSTORE_SALES_SS_SOLD_DATE_SK == y.EXT_PRICESTORE_SALESSTORE_SALES_SS_SOLD_DATE_SK;
    }
  };
  
  typedef MultiHashMap<EXT_PRICESTORE_SALES2_entry,long,
    HashIndex<EXT_PRICESTORE_SALES2_entry,long,EXT_PRICESTORE_SALES2_mapkey0_idxfn,true>
  > EXT_PRICESTORE_SALES2_map;
  typedef HashIndex<EXT_PRICESTORE_SALES2_entry,long,EXT_PRICESTORE_SALES2_mapkey0_idxfn,true> HashIndex_EXT_PRICESTORE_SALES2_map_0;
  
  struct EXT_PRICESTORE_SALES3_entry {
    long EXT_PRICESTORE_SALESSTORE_SALES_SS_CUSTOMER_SK; long EXT_PRICESTORE_SALESSTORE_SALES_SS_STORE_SK; long __av; 
    explicit EXT_PRICESTORE_SALES3_entry() { /*EXT_PRICESTORE_SALESSTORE_SALES_SS_CUSTOMER_SK = 0L; EXT_PRICESTORE_SALESSTORE_SALES_SS_STORE_SK = 0L; __av = 0L; */ }
    explicit EXT_PRICESTORE_SALES3_entry(const long c0, const long c1, const long c2) { EXT_PRICESTORE_SALESSTORE_SALES_SS_CUSTOMER_SK = c0; EXT_PRICESTORE_SALESSTORE_SALES_SS_STORE_SK = c1; __av = c2; }
    EXT_PRICESTORE_SALES3_entry(const EXT_PRICESTORE_SALES3_entry& other) : EXT_PRICESTORE_SALESSTORE_SALES_SS_CUSTOMER_SK( other.EXT_PRICESTORE_SALESSTORE_SALES_SS_CUSTOMER_SK ), EXT_PRICESTORE_SALESSTORE_SALES_SS_STORE_SK( other.EXT_PRICESTORE_SALESSTORE_SALES_SS_STORE_SK ), __av( other.__av ) {}
    FORCE_INLINE EXT_PRICESTORE_SALES3_entry& modify(const long c0, const long c1) { EXT_PRICESTORE_SALESSTORE_SALES_SS_CUSTOMER_SK = c0; EXT_PRICESTORE_SALESSTORE_SALES_SS_STORE_SK = c1;  return *this; }
    template<class Archive>
    void serialize(Archive& ar, const unsigned int version) const 
    {
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, EXT_PRICESTORE_SALESSTORE_SALES_SS_CUSTOMER_SK);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, EXT_PRICESTORE_SALESSTORE_SALES_SS_STORE_SK);
      ar << ELEM_SEPARATOR;
      DBT_SERIALIZATION_NVP(ar, __av);
    }
  };
  struct EXT_PRICESTORE_SALES3_mapkey01_idxfn {
    FORCE_INLINE static size_t hash(const EXT_PRICESTORE_SALES3_entry& e) {
      size_t h = 0;
      hash_combine(h, e.EXT_PRICESTORE_SALESSTORE_SALES_SS_CUSTOMER_SK);
      hash_combine(h, e.EXT_PRICESTORE_SALESSTORE_SALES_SS_STORE_SK);
      return h;
    }
    FORCE_INLINE static bool equals(const EXT_PRICESTORE_SALES3_entry& x, const EXT_PRICESTORE_SALES3_entry& y) {
      return x.EXT_PRICESTORE_SALESSTORE_SALES_SS_CUSTOMER_SK == y.EXT_PRICESTORE_SALESSTORE_SALES_SS_CUSTOMER_SK && x.EXT_PRICESTORE_SALESSTORE_SALES_SS_STORE_SK == y.EXT_PRICESTORE_SALESSTORE_SALES_SS_STORE_SK;
    }
  };
  
  typedef MultiHashMap<EXT_PRICESTORE_SALES3_entry,long,
    HashIndex<EXT_PRICESTORE_SALES3_entry,long,EXT_PRICESTORE_SALES3_mapkey01_idxfn,true>
  > EXT_PRICESTORE_SALES3_map;
  typedef HashIndex<EXT_PRICESTORE_SALES3_entry,long,EXT_PRICESTORE_SALES3_mapkey01_idxfn,true> HashIndex_EXT_PRICESTORE_SALES3_map_01;
  
  struct tuple3_LL_D {
    long _1; long _2; DOUBLE_TYPE __av;
    explicit tuple3_LL_D() { }
    explicit tuple3_LL_D(const long c1, const long c2, DOUBLE_TYPE c__av=0.0) { _1 = c1; _2 = c2; __av = c__av;}
    int operator==(const tuple3_LL_D &rhs) const { return ((this->_1==rhs._1) && (this->_2==rhs._2)); }
    FORCE_INLINE tuple3_LL_D& modify(const long c0, const long c1, DOUBLE_TYPE c__av) { _1 = c0; _2 = c1; __av = c__av; return *this; }
    static bool equals(const tuple3_LL_D &x, const tuple3_LL_D &y) { return ((x._1==y._1) && (x._2==y._2)); }
    static long hash(const tuple3_LL_D &e) {
      size_t h = 0;
      hash_combine(h, e._1);
      hash_combine(h, e._2);
      return h;
    }
  };
  struct tuple6_LLSSL_D {
    long _1; long _2; STRING_TYPE _3; STRING_TYPE _4; long _5; DOUBLE_TYPE __av;
    explicit tuple6_LLSSL_D() { }
    explicit tuple6_LLSSL_D(const long c1, const long c2, const STRING_TYPE& c3, const STRING_TYPE& c4, const long c5, DOUBLE_TYPE c__av=0.0) { _1 = c1; _2 = c2; _3 = c3; _4 = c4; _5 = c5; __av = c__av;}
    int operator==(const tuple6_LLSSL_D &rhs) const { return ((this->_1==rhs._1) && (this->_2==rhs._2) && (this->_3==rhs._3) && (this->_4==rhs._4) && (this->_5==rhs._5)); }
    FORCE_INLINE tuple6_LLSSL_D& modify(const long c0, const long c1, const STRING_TYPE& c2, const STRING_TYPE& c3, const long c4, DOUBLE_TYPE c__av) { _1 = c0; _2 = c1; _3 = c2; _4 = c3; _5 = c4; __av = c__av; return *this; }
    static bool equals(const tuple6_LLSSL_D &x, const tuple6_LLSSL_D &y) { return ((x._1==y._1) && (x._2==y._2) && (x._3==y._3) && (x._4==y._4) && (x._5==y._5)); }
    static long hash(const tuple6_LLSSL_D &e) {
      size_t h = 0;
      hash_combine(h, e._1);
      hash_combine(h, e._2);
      hash_combine(h, e._3);
      hash_combine(h, e._4);
      hash_combine(h, e._5);
      return h;
    }
  };
  struct tuple2_L_L {
    long _1; long __av;
    explicit tuple2_L_L() { }
    explicit tuple2_L_L(const long c1, long c__av=0L) { _1 = c1; __av = c__av;}
    int operator==(const tuple2_L_L &rhs) const { return ((this->_1==rhs._1)); }
    FORCE_INLINE tuple2_L_L& modify(const long c0, long c__av) { _1 = c0; __av = c__av; return *this; }
    static bool equals(const tuple2_L_L &x, const tuple2_L_L &y) { return ((x._1==y._1)); }
    static long hash(const tuple2_L_L &e) {
      size_t h = 0;
      hash_combine(h, e._1);
      return h;
    }
  };
  
  /* Type definition providing a way to access the results of the sql program */
  struct tlq_t{
    struct timeval t0,t; long tT,tN,tS;
    tlq_t(): tN(0), tS(0) { gettimeofday(&t0,NULL); }
  
  /* Serialization Code */
    template<class Archive>
    void serialize(Archive& ar, const unsigned int version) const {
  
      ar << "\n";
      const EXT_PRICE_map& _EXT_PRICE = get_EXT_PRICE();
      dbtoaster::serialize_nvp_tabbed(ar, STRING_TYPE(EXT_PRICE), _EXT_PRICE, "\t");
  
    }
  
    /* Functions returning / computing the results of top level queries */
    const EXT_PRICE_map& get_EXT_PRICE() const {
      return EXT_PRICE;
    
    }
  
  protected:
  
    /* Data structures used for storing / computing top level queries */
    EXT_PRICE_map EXT_PRICE;
  
  };
  
  /* Type definition providing a way to incrementally maintain the results of the sql program */
  struct data_t : tlq_t{
    data_t(): tlq_t(), agg6(16U), agg8(16U), agg2(16U), agg5(16U), agg4(16U), agg7(16U), agg1(16U), agg3(16U) {
      
    }
  
  
    /* Trigger functions for table relations */
    void on_insert_DATE_DIM(const long date_dim_d_date_sk, const STRING_TYPE date_dim_d_date_id, const date date_dim_d_date, const long date_dim_d_month_seq, const long date_dim_d_week_seq, const long date_dim_d_quarter_seq, const long date_dim_d_year, const long date_dim_d_dow, const long date_dim_d_moy, const long date_dim_d_dom, const long date_dim_d_qoy, const long date_dim_d_fy_year, const long date_dim_d_fy_quarter_seq, const long date_dim_d_fy_week_seq, const STRING_TYPE date_dim_d_day_name, const STRING_TYPE date_dim_d_quarter_name, const STRING_TYPE date_dim_d_holiday, const STRING_TYPE date_dim_d_weekend, const STRING_TYPE date_dim_d_following_holiday, const long date_dim_d_first_dom, const long date_dim_d_last_dom, const long date_dim_d_same_day_ly, const long date_dim_d_same_day_lq, const STRING_TYPE date_dim_d_current_day, const STRING_TYPE date_dim_d_current_week, const STRING_TYPE date_dim_d_current_month, const STRING_TYPE date_dim_d_current_quarter, const STRING_TYPE date_dim_d_current_year) {
      DATE_DIM_entry e(date_dim_d_date_sk, date_dim_d_date_id, date_dim_d_date, date_dim_d_month_seq, date_dim_d_week_seq, date_dim_d_quarter_seq, date_dim_d_year, date_dim_d_dow, date_dim_d_moy, date_dim_d_dom, date_dim_d_qoy, date_dim_d_fy_year, date_dim_d_fy_quarter_seq, date_dim_d_fy_week_seq, date_dim_d_day_name, date_dim_d_quarter_name, date_dim_d_holiday, date_dim_d_weekend, date_dim_d_following_holiday, date_dim_d_first_dom, date_dim_d_last_dom, date_dim_d_same_day_ly, date_dim_d_same_day_lq, date_dim_d_current_day, date_dim_d_current_week, date_dim_d_current_month, date_dim_d_current_quarter, date_dim_d_current_year, 1L);
      DATE_DIM.addOrDelOnZero(e,1L);
    }
    
    
    
    /* Trigger functions for stream relations */
    void on_insert_STORE_SALES(const long store_sales_ss_sold_date_sk, const long store_sales_ss_sold_time_sk, const long store_sales_ss_item_sk, const long store_sales_ss_customer_sk, const long store_sales_ss_cdemo_sk, const long store_sales_ss_hdemo_sk, const long store_sales_ss_addr_sk, const long store_sales_ss_store_sk, const long store_sales_ss_promo_sk, const long store_sales_ss_ticket_number, const long store_sales_ss_quantity, const DOUBLE_TYPE store_sales_ss_wholesale_cost, const DOUBLE_TYPE store_sales_ss_list_price, const DOUBLE_TYPE store_sales_ss_sales_price, const DOUBLE_TYPE store_sales_ss_ext_discount_amt, const DOUBLE_TYPE store_sales_ss_ext_sales_price, const DOUBLE_TYPE store_sales_ss_ext_wholesale_cost, const DOUBLE_TYPE store_sales_ss_ext_list_price, const DOUBLE_TYPE store_sales_ss_ext_tax, const DOUBLE_TYPE store_sales_ss_coupon_amt, const DOUBLE_TYPE store_sales_ss_net_paid, const DOUBLE_TYPE store_sales_ss_net_paid_inc_tax, const DOUBLE_TYPE store_sales_ss_net_profit) {
      {  if (tS>0) { ++tS; return; } if ((tN&127)==0) { gettimeofday(&(t),NULL); tT=((t).tv_sec-(t0).tv_sec)*1000000L+((t).tv_usec-(t0).tv_usec); if (tT>3600000000L) { tS=1; return; } } ++tN;
        { //slice 
          const HashIndex_EXT_PRICESTORE_SALES1_map_0* i1 = static_cast<HashIndex_EXT_PRICESTORE_SALES1_map_0*>(EXT_PRICESTORE_SALES1.index[1]);
          const HASH_RES_t h1 = EXT_PRICESTORE_SALES1_mapkey0_idxfn::hash(se4.modify0(store_sales_ss_item_sk));
          HashIndex_EXT_PRICESTORE_SALES1_map_0::IdxNode* n1 = static_cast<HashIndex_EXT_PRICESTORE_SALES1_map_0::IdxNode*>(i1->slice(se4, h1));
          EXT_PRICESTORE_SALES1_entry* e1;
         
          if (n1 && (e1 = n1->obj)) {
            do {                
              long item_i_manufact_id = e1->ITEM_I_MANUFACT_ID;
              STRING_TYPE item_i_manufact = e1->ITEM_I_MANUFACT;
              STRING_TYPE brand = e1->BRAND;
              long brand_id = e1->BRAND_ID;
              long v1 = e1->__av;
              EXT_PRICE.addOrDelOnZero(se1.modify(brand_id,brand,item_i_manufact_id,item_i_manufact),(EXT_PRICESTORE_SALES2.getValueOrDefault(se2.modify(store_sales_ss_sold_date_sk)) * (EXT_PRICESTORE_SALES3.getValueOrDefault(se3.modify(store_sales_ss_customer_sk,store_sales_ss_store_sk)) * (v1 * store_sales_ss_ext_sales_price))));
              n1 = n1->nxt;
            } while (n1 && (e1 = n1->obj) && h1 == n1->hash &&  EXT_PRICESTORE_SALES1_mapkey0_idxfn::equals(se4, *e1)); 
          }
        }{ //slice 
          const HashIndex_EXT_PRICESTORE1STORE_SALES3_map_0* i2 = static_cast<HashIndex_EXT_PRICESTORE1STORE_SALES3_map_0*>(EXT_PRICESTORE1STORE_SALES3.index[1]);
          const HASH_RES_t h3 = EXT_PRICESTORE1STORE_SALES3_mapkey0_idxfn::hash(se8.modify0(store_sales_ss_customer_sk));
          HashIndex_EXT_PRICESTORE1STORE_SALES3_map_0::IdxNode* n2 = static_cast<HashIndex_EXT_PRICESTORE1STORE_SALES3_map_0::IdxNode*>(i2->slice(se8, h3));
          EXT_PRICESTORE1STORE_SALES3_entry* e2;
         
          if (n2 && (e2 = n2->obj)) {
            do {                
              STRING_TYPE customer_address_ca_zip = e2->CUSTOMER_ADDRESS_CA_ZIP;
              long v2 = e2->__av;
              { //slice 
                const HashIndex_EXT_PRICESTORE_SALES1_map_0* i3 = static_cast<HashIndex_EXT_PRICESTORE_SALES1_map_0*>(EXT_PRICESTORE_SALES1.index[1]);
                const HASH_RES_t h2 = EXT_PRICESTORE_SALES1_mapkey0_idxfn::hash(se7.modify0(store_sales_ss_item_sk));
                HashIndex_EXT_PRICESTORE_SALES1_map_0::IdxNode* n3 = static_cast<HashIndex_EXT_PRICESTORE_SALES1_map_0::IdxNode*>(i3->slice(se7, h2));
                EXT_PRICESTORE_SALES1_entry* e3;
               
                if (n3 && (e3 = n3->obj)) {
                  do {                
                    long item_i_manufact_id = e3->ITEM_I_MANUFACT_ID;
                    STRING_TYPE item_i_manufact = e3->ITEM_I_MANUFACT;
                    STRING_TYPE brand = e3->BRAND;
                    long brand_id = e3->BRAND_ID;
                    long v3 = e3->__av;
                    EXT_PRICESTORE1.addOrDelOnZero(se5.modify(store_sales_ss_store_sk,item_i_manufact_id,item_i_manufact,customer_address_ca_zip,brand,brand_id),(EXT_PRICESTORE_SALES2.getValueOrDefault(se6.modify(store_sales_ss_sold_date_sk)) * (v2 * (v3 * store_sales_ss_ext_sales_price))));
                    n3 = n3->nxt;
                  } while (n3 && (e3 = n3->obj) && h2 == n3->hash &&  EXT_PRICESTORE_SALES1_mapkey0_idxfn::equals(se7, *e3)); 
                }
              }
              n2 = n2->nxt;
            } while (n2 && (e2 = n2->obj) && h3 == n2->hash &&  EXT_PRICESTORE1STORE_SALES3_mapkey0_idxfn::equals(se8, *e2)); 
          }
        }{ //slice 
          const HashIndex_EXT_PRICESTORE1CUSTOMER_ADDRESS1STORE_SALES2_map_0* i4 = static_cast<HashIndex_EXT_PRICESTORE1CUSTOMER_ADDRESS1STORE_SALES2_map_0*>(EXT_PRICESTORE1CUSTOMER_ADDRESS1STORE_SALES2.index[1]);
          const HASH_RES_t h5 = EXT_PRICESTORE1CUSTOMER_ADDRESS1STORE_SALES2_mapkey0_idxfn::hash(se12.modify0(store_sales_ss_item_sk));
          HashIndex_EXT_PRICESTORE1CUSTOMER_ADDRESS1STORE_SALES2_map_0::IdxNode* n4 = static_cast<HashIndex_EXT_PRICESTORE1CUSTOMER_ADDRESS1STORE_SALES2_map_0::IdxNode*>(i4->slice(se12, h5));
          EXT_PRICESTORE1CUSTOMER_ADDRESS1STORE_SALES2_entry* e4;
         
          if (n4 && (e4 = n4->obj)) {
            do {                
              long item_i_manufact_id = e4->ITEM_I_MANUFACT_ID;
              STRING_TYPE item_i_manufact = e4->ITEM_I_MANUFACT;
              long brand_id = e4->BRAND_ID;
              STRING_TYPE brand = e4->BRAND;
              long v4 = e4->__av;
              { //slice 
                const HashIndex_EXT_PRICESTORE1CUSTOMER_ADDRESS1STORE_SALES3_map_0* i5 = static_cast<HashIndex_EXT_PRICESTORE1CUSTOMER_ADDRESS1STORE_SALES3_map_0*>(EXT_PRICESTORE1CUSTOMER_ADDRESS1STORE_SALES3.index[1]);
                const HASH_RES_t h4 = EXT_PRICESTORE1CUSTOMER_ADDRESS1STORE_SALES3_mapkey0_idxfn::hash(se11.modify0(store_sales_ss_customer_sk));
                HashIndex_EXT_PRICESTORE1CUSTOMER_ADDRESS1STORE_SALES3_map_0::IdxNode* n5 = static_cast<HashIndex_EXT_PRICESTORE1CUSTOMER_ADDRESS1STORE_SALES3_map_0::IdxNode*>(i5->slice(se11, h4));
                EXT_PRICESTORE1CUSTOMER_ADDRESS1STORE_SALES3_entry* e5;
               
                if (n5 && (e5 = n5->obj)) {
                  do {                
                    long ext_pricestore1customer_addresscustomer_address_ca_address_sk = e5->EXT_PRICESTORE1CUSTOMER_ADDRESSCUSTOMER_ADDRESS_CA_ADDRESS_SK;
                    long v5 = e5->__av;
                    EXT_PRICESTORE1CUSTOMER_ADDRESS1.addOrDelOnZero(se9.modify(ext_pricestore1customer_addresscustomer_address_ca_address_sk,store_sales_ss_store_sk,item_i_manufact_id,item_i_manufact,brand,brand_id),(EXT_PRICESTORE_SALES2.getValueOrDefault(se10.modify(store_sales_ss_sold_date_sk)) * (v4 * (v5 * store_sales_ss_ext_sales_price))));
                    n5 = n5->nxt;
                  } while (n5 && (e5 = n5->obj) && h4 == n5->hash &&  EXT_PRICESTORE1CUSTOMER_ADDRESS1STORE_SALES3_mapkey0_idxfn::equals(se11, *e5)); 
                }
              }
              n4 = n4->nxt;
            } while (n4 && (e4 = n4->obj) && h5 == n4->hash &&  EXT_PRICESTORE1CUSTOMER_ADDRESS1STORE_SALES2_mapkey0_idxfn::equals(se12, *e4)); 
          }
        }{ //slice 
          const HashIndex_EXT_PRICESTORE1CUSTOMER_ADDRESS1STORE_SALES3_map_0* i6 = static_cast<HashIndex_EXT_PRICESTORE1CUSTOMER_ADDRESS1STORE_SALES3_map_0*>(EXT_PRICESTORE1CUSTOMER_ADDRESS1STORE_SALES3.index[1]);
          const HASH_RES_t h6 = EXT_PRICESTORE1CUSTOMER_ADDRESS1STORE_SALES3_mapkey0_idxfn::hash(se15.modify0(store_sales_ss_customer_sk));
          HashIndex_EXT_PRICESTORE1CUSTOMER_ADDRESS1STORE_SALES3_map_0::IdxNode* n6 = static_cast<HashIndex_EXT_PRICESTORE1CUSTOMER_ADDRESS1STORE_SALES3_map_0::IdxNode*>(i6->slice(se15, h6));
          EXT_PRICESTORE1CUSTOMER_ADDRESS1STORE_SALES3_entry* e6;
         
          if (n6 && (e6 = n6->obj)) {
            do {                
              long ext_pricestore1customer_addresscustomer_address_ca_address_sk = e6->EXT_PRICESTORE1CUSTOMER_ADDRESSCUSTOMER_ADDRESS_CA_ADDRESS_SK;
              long v6 = e6->__av;
              EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2.addOrDelOnZero(se13.modify(store_sales_ss_item_sk,store_sales_ss_store_sk,ext_pricestore1customer_addresscustomer_address_ca_address_sk),(EXT_PRICESTORE_SALES2.getValueOrDefault(se14.modify(store_sales_ss_sold_date_sk)) * (v6 * store_sales_ss_ext_sales_price)));
              n6 = n6->nxt;
            } while (n6 && (e6 = n6->obj) && h6 == n6->hash &&  EXT_PRICESTORE1CUSTOMER_ADDRESS1STORE_SALES3_mapkey0_idxfn::equals(se15, *e6)); 
          }
        }EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2CUSTOMER1.addOrDelOnZero(se16.modify(store_sales_ss_item_sk,store_sales_ss_customer_sk,store_sales_ss_store_sk),(EXT_PRICESTORE_SALES2.getValueOrDefault(se17.modify(store_sales_ss_sold_date_sk)) * store_sales_ss_ext_sales_price));
        { //slice 
          const HashIndex_EXT_PRICESTORE_SALES1_map_0* i7 = static_cast<HashIndex_EXT_PRICESTORE_SALES1_map_0*>(EXT_PRICESTORE_SALES1.index[1]);
          const HASH_RES_t h7 = EXT_PRICESTORE_SALES1_mapkey0_idxfn::hash(se20.modify0(store_sales_ss_item_sk));
          HashIndex_EXT_PRICESTORE_SALES1_map_0::IdxNode* n7 = static_cast<HashIndex_EXT_PRICESTORE_SALES1_map_0::IdxNode*>(i7->slice(se20, h7));
          EXT_PRICESTORE_SALES1_entry* e7;
         
          if (n7 && (e7 = n7->obj)) {
            do {                
              long item_i_manufact_id = e7->ITEM_I_MANUFACT_ID;
              STRING_TYPE item_i_manufact = e7->ITEM_I_MANUFACT;
              STRING_TYPE brand = e7->BRAND;
              long brand_id = e7->BRAND_ID;
              long v7 = e7->__av;
              EXT_PRICESTORE1CUSTOMER_ADDRESS1CUSTOMER1.addOrDelOnZero(se18.modify(store_sales_ss_customer_sk,store_sales_ss_store_sk,item_i_manufact_id,item_i_manufact,brand_id,brand),(EXT_PRICESTORE_SALES2.getValueOrDefault(se19.modify(store_sales_ss_sold_date_sk)) * (v7 * store_sales_ss_ext_sales_price)));
              n7 = n7->nxt;
            } while (n7 && (e7 = n7->obj) && h7 == n7->hash &&  EXT_PRICESTORE_SALES1_mapkey0_idxfn::equals(se20, *e7)); 
          }
        }{ //slice 
          const HashIndex_EXT_PRICESTORE1CUSTOMER_ADDRESS1STORE_SALES2_map_0* i8 = static_cast<HashIndex_EXT_PRICESTORE1CUSTOMER_ADDRESS1STORE_SALES2_map_0*>(EXT_PRICESTORE1CUSTOMER_ADDRESS1STORE_SALES2.index[1]);
          const HASH_RES_t h8 = EXT_PRICESTORE1CUSTOMER_ADDRESS1STORE_SALES2_mapkey0_idxfn::hash(se23.modify0(store_sales_ss_item_sk));
          HashIndex_EXT_PRICESTORE1CUSTOMER_ADDRESS1STORE_SALES2_map_0::IdxNode* n8 = static_cast<HashIndex_EXT_PRICESTORE1CUSTOMER_ADDRESS1STORE_SALES2_map_0::IdxNode*>(i8->slice(se23, h8));
          EXT_PRICESTORE1CUSTOMER_ADDRESS1STORE_SALES2_entry* e8;
         
          if (n8 && (e8 = n8->obj)) {
            do {                
              long item_i_manufact_id = e8->ITEM_I_MANUFACT_ID;
              STRING_TYPE item_i_manufact = e8->ITEM_I_MANUFACT;
              long brand_id = e8->BRAND_ID;
              STRING_TYPE brand = e8->BRAND;
              long v8 = e8->__av;
              EXT_PRICESTORE1CUSTOMER1.addOrDelOnZero(se21.modify(store_sales_ss_customer_sk,store_sales_ss_store_sk,item_i_manufact_id,item_i_manufact,brand,brand_id),(EXT_PRICESTORE_SALES2.getValueOrDefault(se22.modify(store_sales_ss_sold_date_sk)) * (v8 * store_sales_ss_ext_sales_price)));
              n8 = n8->nxt;
            } while (n8 && (e8 = n8->obj) && h8 == n8->hash &&  EXT_PRICESTORE1CUSTOMER_ADDRESS1STORE_SALES2_mapkey0_idxfn::equals(se23, *e8)); 
          }
        }{ //slice 
          const HashIndex_EXT_PRICESTORE1STORE_SALES3_map_0* i9 = static_cast<HashIndex_EXT_PRICESTORE1STORE_SALES3_map_0*>(EXT_PRICESTORE1STORE_SALES3.index[1]);
          const HASH_RES_t h9 = EXT_PRICESTORE1STORE_SALES3_mapkey0_idxfn::hash(se26.modify0(store_sales_ss_customer_sk));
          HashIndex_EXT_PRICESTORE1STORE_SALES3_map_0::IdxNode* n9 = static_cast<HashIndex_EXT_PRICESTORE1STORE_SALES3_map_0::IdxNode*>(i9->slice(se26, h9));
          EXT_PRICESTORE1STORE_SALES3_entry* e9;
         
          if (n9 && (e9 = n9->obj)) {
            do {                
              STRING_TYPE customer_address_ca_zip = e9->CUSTOMER_ADDRESS_CA_ZIP;
              long v9 = e9->__av;
              EXT_PRICESTORE1ITEM2.addOrDelOnZero(se24.modify(store_sales_ss_item_sk,store_sales_ss_store_sk,customer_address_ca_zip),(EXT_PRICESTORE_SALES2.getValueOrDefault(se25.modify(store_sales_ss_sold_date_sk)) * (v9 * store_sales_ss_ext_sales_price)));
              n9 = n9->nxt;
            } while (n9 && (e9 = n9->obj) && h9 == n9->hash &&  EXT_PRICESTORE1STORE_SALES3_mapkey0_idxfn::equals(se26, *e9)); 
          }
        }{ //slice 
          const HashIndex_EXT_PRICECUSTOMER_ADDRESS1STORE_SALES4_map_0* i10 = static_cast<HashIndex_EXT_PRICECUSTOMER_ADDRESS1STORE_SALES4_map_0*>(EXT_PRICECUSTOMER_ADDRESS1STORE_SALES4.index[1]);
          const HASH_RES_t h12 = EXT_PRICECUSTOMER_ADDRESS1STORE_SALES4_mapkey0_idxfn::hash(se31.modify0(store_sales_ss_store_sk));
          HashIndex_EXT_PRICECUSTOMER_ADDRESS1STORE_SALES4_map_0::IdxNode* n10 = static_cast<HashIndex_EXT_PRICECUSTOMER_ADDRESS1STORE_SALES4_map_0::IdxNode*>(i10->slice(se31, h12));
          EXT_PRICECUSTOMER_ADDRESS1STORE_SALES4_entry* e10;
         
          if (n10 && (e10 = n10->obj)) {
            do {                
              STRING_TYPE store_s_zip = e10->STORE_S_ZIP;
              long v10 = e10->__av;
              { //slice 
                const HashIndex_EXT_PRICESTORE1CUSTOMER_ADDRESS1STORE_SALES3_map_0* i11 = static_cast<HashIndex_EXT_PRICESTORE1CUSTOMER_ADDRESS1STORE_SALES3_map_0*>(EXT_PRICESTORE1CUSTOMER_ADDRESS1STORE_SALES3.index[1]);
                const HASH_RES_t h11 = EXT_PRICESTORE1CUSTOMER_ADDRESS1STORE_SALES3_mapkey0_idxfn::hash(se30.modify0(store_sales_ss_customer_sk));
                HashIndex_EXT_PRICESTORE1CUSTOMER_ADDRESS1STORE_SALES3_map_0::IdxNode* n11 = static_cast<HashIndex_EXT_PRICESTORE1CUSTOMER_ADDRESS1STORE_SALES3_map_0::IdxNode*>(i11->slice(se30, h11));
                EXT_PRICESTORE1CUSTOMER_ADDRESS1STORE_SALES3_entry* e11;
               
                if (n11 && (e11 = n11->obj)) {
                  do {                
                    long ext_pricecustomer_addresscustomer_address_ca_address_sk = e11->EXT_PRICESTORE1CUSTOMER_ADDRESSCUSTOMER_ADDRESS_CA_ADDRESS_SK;
                    long v11 = e11->__av;
                    { //slice 
                      const HashIndex_EXT_PRICESTORE_SALES1_map_0* i12 = static_cast<HashIndex_EXT_PRICESTORE_SALES1_map_0*>(EXT_PRICESTORE_SALES1.index[1]);
                      const HASH_RES_t h10 = EXT_PRICESTORE_SALES1_mapkey0_idxfn::hash(se29.modify0(store_sales_ss_item_sk));
                      HashIndex_EXT_PRICESTORE_SALES1_map_0::IdxNode* n12 = static_cast<HashIndex_EXT_PRICESTORE_SALES1_map_0::IdxNode*>(i12->slice(se29, h10));
                      EXT_PRICESTORE_SALES1_entry* e12;
                     
                      if (n12 && (e12 = n12->obj)) {
                        do {                
                          long item_i_manufact_id = e12->ITEM_I_MANUFACT_ID;
                          STRING_TYPE item_i_manufact = e12->ITEM_I_MANUFACT;
                          STRING_TYPE brand = e12->BRAND;
                          long brand_id = e12->BRAND_ID;
                          long v12 = e12->__av;
                          EXT_PRICECUSTOMER_ADDRESS1.addOrDelOnZero(se27.modify(ext_pricecustomer_addresscustomer_address_ca_address_sk,item_i_manufact_id,item_i_manufact,store_s_zip,brand,brand_id),(EXT_PRICESTORE_SALES2.getValueOrDefault(se28.modify(store_sales_ss_sold_date_sk)) * (v10 * (v11 * (v12 * store_sales_ss_ext_sales_price)))));
                          n12 = n12->nxt;
                        } while (n12 && (e12 = n12->obj) && h10 == n12->hash &&  EXT_PRICESTORE_SALES1_mapkey0_idxfn::equals(se29, *e12)); 
                      }
                    }
                    n11 = n11->nxt;
                  } while (n11 && (e11 = n11->obj) && h11 == n11->hash &&  EXT_PRICESTORE1CUSTOMER_ADDRESS1STORE_SALES3_mapkey0_idxfn::equals(se30, *e11)); 
                }
              }
              n10 = n10->nxt;
            } while (n10 && (e10 = n10->obj) && h12 == n10->hash &&  EXT_PRICECUSTOMER_ADDRESS1STORE_SALES4_mapkey0_idxfn::equals(se31, *e10)); 
          }
        }{ //slice 
          const HashIndex_EXT_PRICESTORE1CUSTOMER_ADDRESS1STORE_SALES3_map_0* i13 = static_cast<HashIndex_EXT_PRICESTORE1CUSTOMER_ADDRESS1STORE_SALES3_map_0*>(EXT_PRICESTORE1CUSTOMER_ADDRESS1STORE_SALES3.index[1]);
          const HASH_RES_t h14 = EXT_PRICESTORE1CUSTOMER_ADDRESS1STORE_SALES3_mapkey0_idxfn::hash(se35.modify0(store_sales_ss_customer_sk));
          HashIndex_EXT_PRICESTORE1CUSTOMER_ADDRESS1STORE_SALES3_map_0::IdxNode* n13 = static_cast<HashIndex_EXT_PRICESTORE1CUSTOMER_ADDRESS1STORE_SALES3_map_0::IdxNode*>(i13->slice(se35, h14));
          EXT_PRICESTORE1CUSTOMER_ADDRESS1STORE_SALES3_entry* e13;
         
          if (n13 && (e13 = n13->obj)) {
            do {                
              long ext_pricecustomer_addresscustomer_address_ca_address_sk = e13->EXT_PRICESTORE1CUSTOMER_ADDRESSCUSTOMER_ADDRESS_CA_ADDRESS_SK;
              long v13 = e13->__av;
              { //slice 
                const HashIndex_EXT_PRICECUSTOMER_ADDRESS1STORE_SALES4_map_0* i14 = static_cast<HashIndex_EXT_PRICECUSTOMER_ADDRESS1STORE_SALES4_map_0*>(EXT_PRICECUSTOMER_ADDRESS1STORE_SALES4.index[1]);
                const HASH_RES_t h13 = EXT_PRICECUSTOMER_ADDRESS1STORE_SALES4_mapkey0_idxfn::hash(se34.modify0(store_sales_ss_store_sk));
                HashIndex_EXT_PRICECUSTOMER_ADDRESS1STORE_SALES4_map_0::IdxNode* n14 = static_cast<HashIndex_EXT_PRICECUSTOMER_ADDRESS1STORE_SALES4_map_0::IdxNode*>(i14->slice(se34, h13));
                EXT_PRICECUSTOMER_ADDRESS1STORE_SALES4_entry* e14;
               
                if (n14 && (e14 = n14->obj)) {
                  do {                
                    STRING_TYPE store_s_zip = e14->STORE_S_ZIP;
                    long v14 = e14->__av;
                    EXT_PRICECUSTOMER_ADDRESS1ITEM2.addOrDelOnZero(se32.modify(store_sales_ss_item_sk,ext_pricecustomer_addresscustomer_address_ca_address_sk,store_s_zip),(EXT_PRICESTORE_SALES2.getValueOrDefault(se33.modify(store_sales_ss_sold_date_sk)) * (v13 * (v14 * store_sales_ss_ext_sales_price))));
                    n14 = n14->nxt;
                  } while (n14 && (e14 = n14->obj) && h13 == n14->hash &&  EXT_PRICECUSTOMER_ADDRESS1STORE_SALES4_mapkey0_idxfn::equals(se34, *e14)); 
                }
              }
              n13 = n13->nxt;
            } while (n13 && (e13 = n13->obj) && h14 == n13->hash &&  EXT_PRICESTORE1CUSTOMER_ADDRESS1STORE_SALES3_mapkey0_idxfn::equals(se35, *e13)); 
          }
        }{ //slice 
          const HashIndex_EXT_PRICECUSTOMER_ADDRESS1STORE_SALES4_map_0* i15 = static_cast<HashIndex_EXT_PRICECUSTOMER_ADDRESS1STORE_SALES4_map_0*>(EXT_PRICECUSTOMER_ADDRESS1STORE_SALES4.index[1]);
          const HASH_RES_t h15 = EXT_PRICECUSTOMER_ADDRESS1STORE_SALES4_mapkey0_idxfn::hash(se38.modify0(store_sales_ss_store_sk));
          HashIndex_EXT_PRICECUSTOMER_ADDRESS1STORE_SALES4_map_0::IdxNode* n15 = static_cast<HashIndex_EXT_PRICECUSTOMER_ADDRESS1STORE_SALES4_map_0::IdxNode*>(i15->slice(se38, h15));
          EXT_PRICECUSTOMER_ADDRESS1STORE_SALES4_entry* e15;
         
          if (n15 && (e15 = n15->obj)) {
            do {                
              STRING_TYPE store_s_zip = e15->STORE_S_ZIP;
              long v15 = e15->__av;
              EXT_PRICECUSTOMER_ADDRESS1ITEM2CUSTOMER1.addOrDelOnZero(se36.modify(store_sales_ss_item_sk,store_sales_ss_customer_sk,store_s_zip),(EXT_PRICESTORE_SALES2.getValueOrDefault(se37.modify(store_sales_ss_sold_date_sk)) * (v15 * store_sales_ss_ext_sales_price)));
              n15 = n15->nxt;
            } while (n15 && (e15 = n15->obj) && h15 == n15->hash &&  EXT_PRICECUSTOMER_ADDRESS1STORE_SALES4_mapkey0_idxfn::equals(se38, *e15)); 
          }
        }{ //slice 
          const HashIndex_EXT_PRICECUSTOMER_ADDRESS1STORE_SALES4_map_0* i16 = static_cast<HashIndex_EXT_PRICECUSTOMER_ADDRESS1STORE_SALES4_map_0*>(EXT_PRICECUSTOMER_ADDRESS1STORE_SALES4.index[1]);
          const HASH_RES_t h17 = EXT_PRICECUSTOMER_ADDRESS1STORE_SALES4_mapkey0_idxfn::hash(se42.modify0(store_sales_ss_store_sk));
          HashIndex_EXT_PRICECUSTOMER_ADDRESS1STORE_SALES4_map_0::IdxNode* n16 = static_cast<HashIndex_EXT_PRICECUSTOMER_ADDRESS1STORE_SALES4_map_0::IdxNode*>(i16->slice(se42, h17));
          EXT_PRICECUSTOMER_ADDRESS1STORE_SALES4_entry* e16;
         
          if (n16 && (e16 = n16->obj)) {
            do {                
              STRING_TYPE store_s_zip = e16->STORE_S_ZIP;
              long v16 = e16->__av;
              { //slice 
                const HashIndex_EXT_PRICESTORE_SALES1_map_0* i17 = static_cast<HashIndex_EXT_PRICESTORE_SALES1_map_0*>(EXT_PRICESTORE_SALES1.index[1]);
                const HASH_RES_t h16 = EXT_PRICESTORE_SALES1_mapkey0_idxfn::hash(se41.modify0(store_sales_ss_item_sk));
                HashIndex_EXT_PRICESTORE_SALES1_map_0::IdxNode* n17 = static_cast<HashIndex_EXT_PRICESTORE_SALES1_map_0::IdxNode*>(i17->slice(se41, h16));
                EXT_PRICESTORE_SALES1_entry* e17;
               
                if (n17 && (e17 = n17->obj)) {
                  do {                
                    long item_i_manufact_id = e17->ITEM_I_MANUFACT_ID;
                    STRING_TYPE item_i_manufact = e17->ITEM_I_MANUFACT;
                    STRING_TYPE brand = e17->BRAND;
                    long brand_id = e17->BRAND_ID;
                    long v17 = e17->__av;
                    EXT_PRICECUSTOMER_ADDRESS1CUSTOMER1.addOrDelOnZero(se39.modify(store_sales_ss_customer_sk,item_i_manufact_id,item_i_manufact,store_s_zip,brand,brand_id),(EXT_PRICESTORE_SALES2.getValueOrDefault(se40.modify(store_sales_ss_sold_date_sk)) * (v16 * (v17 * store_sales_ss_ext_sales_price))));
                    n17 = n17->nxt;
                  } while (n17 && (e17 = n17->obj) && h16 == n17->hash &&  EXT_PRICESTORE_SALES1_mapkey0_idxfn::equals(se41, *e17)); 
                }
              }
              n16 = n16->nxt;
            } while (n16 && (e16 = n16->obj) && h17 == n16->hash &&  EXT_PRICECUSTOMER_ADDRESS1STORE_SALES4_mapkey0_idxfn::equals(se42, *e16)); 
          }
        }{ //slice 
          const HashIndex_EXT_PRICESTORE1CUSTOMER_ADDRESS1STORE_SALES2_map_0* i18 = static_cast<HashIndex_EXT_PRICESTORE1CUSTOMER_ADDRESS1STORE_SALES2_map_0*>(EXT_PRICESTORE1CUSTOMER_ADDRESS1STORE_SALES2.index[1]);
          const HASH_RES_t h19 = EXT_PRICESTORE1CUSTOMER_ADDRESS1STORE_SALES2_mapkey0_idxfn::hash(se46.modify0(store_sales_ss_item_sk));
          HashIndex_EXT_PRICESTORE1CUSTOMER_ADDRESS1STORE_SALES2_map_0::IdxNode* n18 = static_cast<HashIndex_EXT_PRICESTORE1CUSTOMER_ADDRESS1STORE_SALES2_map_0::IdxNode*>(i18->slice(se46, h19));
          EXT_PRICESTORE1CUSTOMER_ADDRESS1STORE_SALES2_entry* e18;
         
          if (n18 && (e18 = n18->obj)) {
            do {                
              long item_i_manufact_id = e18->ITEM_I_MANUFACT_ID;
              STRING_TYPE item_i_manufact = e18->ITEM_I_MANUFACT;
              long brand_id = e18->BRAND_ID;
              STRING_TYPE brand = e18->BRAND;
              long v18 = e18->__av;
              { //slice 
                const HashIndex_EXT_PRICECUSTOMER1STORE_SALES3_map_0* i19 = static_cast<HashIndex_EXT_PRICECUSTOMER1STORE_SALES3_map_0*>(EXT_PRICECUSTOMER1STORE_SALES3.index[1]);
                const HASH_RES_t h18 = EXT_PRICECUSTOMER1STORE_SALES3_mapkey0_idxfn::hash(se45.modify0(store_sales_ss_store_sk));
                HashIndex_EXT_PRICECUSTOMER1STORE_SALES3_map_0::IdxNode* n19 = static_cast<HashIndex_EXT_PRICECUSTOMER1STORE_SALES3_map_0::IdxNode*>(i19->slice(se45, h18));
                EXT_PRICECUSTOMER1STORE_SALES3_entry* e19;
               
                if (n19 && (e19 = n19->obj)) {
                  do {                
                    long ext_pricecustomercustomer_c_current_addr_sk = e19->EXT_PRICECUSTOMERCUSTOMER_C_CURRENT_ADDR_SK;
                    long v19 = e19->__av;
                    EXT_PRICECUSTOMER1.addOrDelOnZero(se43.modify(store_sales_ss_customer_sk,ext_pricecustomercustomer_c_current_addr_sk,item_i_manufact_id,item_i_manufact,brand,brand_id),(EXT_PRICESTORE_SALES2.getValueOrDefault(se44.modify(store_sales_ss_sold_date_sk)) * (v18 * (v19 * store_sales_ss_ext_sales_price))));
                    n19 = n19->nxt;
                  } while (n19 && (e19 = n19->obj) && h18 == n19->hash &&  EXT_PRICECUSTOMER1STORE_SALES3_mapkey0_idxfn::equals(se45, *e19)); 
                }
              }
              n18 = n18->nxt;
            } while (n18 && (e18 = n18->obj) && h19 == n18->hash &&  EXT_PRICESTORE1CUSTOMER_ADDRESS1STORE_SALES2_mapkey0_idxfn::equals(se46, *e18)); 
          }
        }{ //slice 
          const HashIndex_EXT_PRICECUSTOMER1STORE_SALES3_map_0* i20 = static_cast<HashIndex_EXT_PRICECUSTOMER1STORE_SALES3_map_0*>(EXT_PRICECUSTOMER1STORE_SALES3.index[1]);
          const HASH_RES_t h20 = EXT_PRICECUSTOMER1STORE_SALES3_mapkey0_idxfn::hash(se49.modify0(store_sales_ss_store_sk));
          HashIndex_EXT_PRICECUSTOMER1STORE_SALES3_map_0::IdxNode* n20 = static_cast<HashIndex_EXT_PRICECUSTOMER1STORE_SALES3_map_0::IdxNode*>(i20->slice(se49, h20));
          EXT_PRICECUSTOMER1STORE_SALES3_entry* e20;
         
          if (n20 && (e20 = n20->obj)) {
            do {                
              long ext_pricecustomercustomer_c_current_addr_sk = e20->EXT_PRICECUSTOMERCUSTOMER_C_CURRENT_ADDR_SK;
              long v20 = e20->__av;
              EXT_PRICECUSTOMER1ITEM2.addOrDelOnZero(se47.modify(store_sales_ss_item_sk,store_sales_ss_customer_sk,ext_pricecustomercustomer_c_current_addr_sk),(EXT_PRICESTORE_SALES2.getValueOrDefault(se48.modify(store_sales_ss_sold_date_sk)) * (v20 * store_sales_ss_ext_sales_price)));
              n20 = n20->nxt;
            } while (n20 && (e20 = n20->obj) && h20 == n20->hash &&  EXT_PRICECUSTOMER1STORE_SALES3_mapkey0_idxfn::equals(se49, *e20)); 
          }
        }EXT_PRICEITEM2.addOrDelOnZero(se50.modify(store_sales_ss_item_sk),(EXT_PRICESTORE_SALES2.getValueOrDefault(se51.modify(store_sales_ss_sold_date_sk)) * (EXT_PRICESTORE_SALES3.getValueOrDefault(se52.modify(store_sales_ss_customer_sk,store_sales_ss_store_sk)) * store_sales_ss_ext_sales_price)));
      }
    }
    void on_insert_ITEM(const long item_i_item_sk, const STRING_TYPE& item_i_item_id, const date item_i_rec_start_date, const date item_i_rec_end_date, const STRING_TYPE& item_i_item_desc, const DOUBLE_TYPE item_i_current_price, const DOUBLE_TYPE item_i_wholesale_cost, const long item_i_brand_id, const STRING_TYPE& item_i_brand, const long item_i_class_id, const STRING_TYPE& item_i_class, const long item_i_category_id, const STRING_TYPE& item_i_category, const long item_i_manufact_id, const STRING_TYPE& item_i_manufact, const STRING_TYPE& item_i_size, const STRING_TYPE& item_i_formulation, const STRING_TYPE& item_i_color, const STRING_TYPE& item_i_units, const STRING_TYPE& item_i_container, const long item_i_manager_id, const STRING_TYPE& item_i_product_name) {
      {  if (tS>0) { ++tS; return; } if ((tN&127)==0) { gettimeofday(&(t),NULL); tT=((t).tv_sec-(t0).tv_sec)*1000000L+((t).tv_usec-(t0).tv_usec); if (tT>3600000000L) { tS=1; return; } } ++tN;
        (/*if */(item_i_manager_id == 7L) ? EXT_PRICE.addOrDelOnZero(se53.modify(item_i_brand_id,item_i_brand,item_i_manufact_id,item_i_manufact),EXT_PRICEITEM2.getValueOrDefault(se54.modify(item_i_item_sk))) : (void)0);
        { //slice 
          const HashIndex_EXT_PRICESTORE1ITEM2_map_0* i21 = static_cast<HashIndex_EXT_PRICESTORE1ITEM2_map_0*>(EXT_PRICESTORE1ITEM2.index[1]);
          const HASH_RES_t h21 = EXT_PRICESTORE1ITEM2_mapkey0_idxfn::hash(se56.modify0(item_i_item_sk));
          HashIndex_EXT_PRICESTORE1ITEM2_map_0::IdxNode* n21 = static_cast<HashIndex_EXT_PRICESTORE1ITEM2_map_0::IdxNode*>(i21->slice(se56, h21));
          EXT_PRICESTORE1ITEM2_entry* e21;
         
          if (n21 && (e21 = n21->obj)) {
            do {                
              long ext_pricestorestore_s_store_sk = e21->EXT_PRICESTORESTORE_S_STORE_SK;
              STRING_TYPE customer_address_ca_zip = e21->CUSTOMER_ADDRESS_CA_ZIP;
              DOUBLE_TYPE v21 = e21->__av;
              (/*if */(item_i_manager_id == 7L) ? EXT_PRICESTORE1.addOrDelOnZero(se55.modify(ext_pricestorestore_s_store_sk,item_i_manufact_id,item_i_manufact,customer_address_ca_zip,item_i_brand,item_i_brand_id),v21) : (void)0);
              n21 = n21->nxt;
            } while (n21 && (e21 = n21->obj) && h21 == n21->hash &&  EXT_PRICESTORE1ITEM2_mapkey0_idxfn::equals(se56, *e21)); 
          }
        }{ //slice 
          const HashIndex_EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2_map_0* i22 = static_cast<HashIndex_EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2_map_0*>(EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2.index[1]);
          const HASH_RES_t h22 = EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2_mapkey0_idxfn::hash(se58.modify0(item_i_item_sk));
          HashIndex_EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2_map_0::IdxNode* n22 = static_cast<HashIndex_EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2_map_0::IdxNode*>(i22->slice(se58, h22));
          EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2_entry* e22;
         
          if (n22 && (e22 = n22->obj)) {
            do {                
              long ext_pricestorestore_s_store_sk = e22->EXT_PRICESTORESTORE_S_STORE_SK;
              long ext_pricestore1customer_addresscustomer_address_ca_address_sk = e22->EXT_PRICESTORE1CUSTOMER_ADDRESSCUSTOMER_ADDRESS_CA_ADDRESS_SK;
              DOUBLE_TYPE v22 = e22->__av;
              (/*if */(item_i_manager_id == 7L) ? EXT_PRICESTORE1CUSTOMER_ADDRESS1.addOrDelOnZero(se57.modify(ext_pricestore1customer_addresscustomer_address_ca_address_sk,ext_pricestorestore_s_store_sk,item_i_manufact_id,item_i_manufact,item_i_brand,item_i_brand_id),v22) : (void)0);
              n22 = n22->nxt;
            } while (n22 && (e22 = n22->obj) && h22 == n22->hash &&  EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2_mapkey0_idxfn::equals(se58, *e22)); 
          }
        }(/*if */(item_i_manager_id == 7L) ? EXT_PRICESTORE1CUSTOMER_ADDRESS1STORE_SALES2.addOrDelOnZero(se59.modify(item_i_item_sk,item_i_manufact_id,item_i_manufact,item_i_brand_id,item_i_brand),1L) : (void)0);
        { //slice 
          const HashIndex_EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2CUSTOMER1_map_0* i23 = static_cast<HashIndex_EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2CUSTOMER1_map_0*>(EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2CUSTOMER1.index[1]);
          const HASH_RES_t h23 = EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2CUSTOMER1_mapkey0_idxfn::hash(se61.modify0(item_i_item_sk));
          HashIndex_EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2CUSTOMER1_map_0::IdxNode* n23 = static_cast<HashIndex_EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2CUSTOMER1_map_0::IdxNode*>(i23->slice(se61, h23));
          EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2CUSTOMER1_entry* e23;
         
          if (n23 && (e23 = n23->obj)) {
            do {                
              long ext_pricestore1customer_address1customercustomer_c_customer_sk = e23->EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2CUSTOMERCUSTOMER_C_CUSTOMER_SK;
              long ext_pricestorestore_s_store_sk = e23->EXT_PRICESTORESTORE_S_STORE_SK;
              DOUBLE_TYPE v23 = e23->__av;
              (/*if */(item_i_manager_id == 7L) ? EXT_PRICESTORE1CUSTOMER_ADDRESS1CUSTOMER1.addOrDelOnZero(se60.modify(ext_pricestore1customer_address1customercustomer_c_customer_sk,ext_pricestorestore_s_store_sk,item_i_manufact_id,item_i_manufact,item_i_brand_id,item_i_brand),v23) : (void)0);
              n23 = n23->nxt;
            } while (n23 && (e23 = n23->obj) && h23 == n23->hash &&  EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2CUSTOMER1_mapkey0_idxfn::equals(se61, *e23)); 
          }
        }{ //slice 
          const HashIndex_EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2CUSTOMER1_map_0* i24 = static_cast<HashIndex_EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2CUSTOMER1_map_0*>(EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2CUSTOMER1.index[1]);
          const HASH_RES_t h24 = EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2CUSTOMER1_mapkey0_idxfn::hash(se63.modify0(item_i_item_sk));
          HashIndex_EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2CUSTOMER1_map_0::IdxNode* n24 = static_cast<HashIndex_EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2CUSTOMER1_map_0::IdxNode*>(i24->slice(se63, h24));
          EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2CUSTOMER1_entry* e24;
         
          if (n24 && (e24 = n24->obj)) {
            do {                
              long ext_pricestore1customercustomer_c_customer_sk = e24->EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2CUSTOMERCUSTOMER_C_CUSTOMER_SK;
              long ext_pricestorestore_s_store_sk = e24->EXT_PRICESTORESTORE_S_STORE_SK;
              DOUBLE_TYPE v24 = e24->__av;
              (/*if */(item_i_manager_id == 7L) ? EXT_PRICESTORE1CUSTOMER1.addOrDelOnZero(se62.modify(ext_pricestore1customercustomer_c_customer_sk,ext_pricestorestore_s_store_sk,item_i_manufact_id,item_i_manufact,item_i_brand,item_i_brand_id),v24) : (void)0);
              n24 = n24->nxt;
            } while (n24 && (e24 = n24->obj) && h24 == n24->hash &&  EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2CUSTOMER1_mapkey0_idxfn::equals(se63, *e24)); 
          }
        }{ //slice 
          const HashIndex_EXT_PRICECUSTOMER_ADDRESS1ITEM2_map_0* i25 = static_cast<HashIndex_EXT_PRICECUSTOMER_ADDRESS1ITEM2_map_0*>(EXT_PRICECUSTOMER_ADDRESS1ITEM2.index[1]);
          const HASH_RES_t h25 = EXT_PRICECUSTOMER_ADDRESS1ITEM2_mapkey0_idxfn::hash(se65.modify0(item_i_item_sk));
          HashIndex_EXT_PRICECUSTOMER_ADDRESS1ITEM2_map_0::IdxNode* n25 = static_cast<HashIndex_EXT_PRICECUSTOMER_ADDRESS1ITEM2_map_0::IdxNode*>(i25->slice(se65, h25));
          EXT_PRICECUSTOMER_ADDRESS1ITEM2_entry* e25;
         
          if (n25 && (e25 = n25->obj)) {
            do {                
              long ext_pricecustomer_addresscustomer_address_ca_address_sk = e25->EXT_PRICECUSTOMER_ADDRESSCUSTOMER_ADDRESS_CA_ADDRESS_SK;
              STRING_TYPE store_s_zip = e25->STORE_S_ZIP;
              DOUBLE_TYPE v25 = e25->__av;
              (/*if */(item_i_manager_id == 7L) ? EXT_PRICECUSTOMER_ADDRESS1.addOrDelOnZero(se64.modify(ext_pricecustomer_addresscustomer_address_ca_address_sk,item_i_manufact_id,item_i_manufact,store_s_zip,item_i_brand,item_i_brand_id),v25) : (void)0);
              n25 = n25->nxt;
            } while (n25 && (e25 = n25->obj) && h25 == n25->hash &&  EXT_PRICECUSTOMER_ADDRESS1ITEM2_mapkey0_idxfn::equals(se65, *e25)); 
          }
        }{ //slice 
          const HashIndex_EXT_PRICECUSTOMER_ADDRESS1ITEM2CUSTOMER1_map_0* i26 = static_cast<HashIndex_EXT_PRICECUSTOMER_ADDRESS1ITEM2CUSTOMER1_map_0*>(EXT_PRICECUSTOMER_ADDRESS1ITEM2CUSTOMER1.index[1]);
          const HASH_RES_t h26 = EXT_PRICECUSTOMER_ADDRESS1ITEM2CUSTOMER1_mapkey0_idxfn::hash(se67.modify0(item_i_item_sk));
          HashIndex_EXT_PRICECUSTOMER_ADDRESS1ITEM2CUSTOMER1_map_0::IdxNode* n26 = static_cast<HashIndex_EXT_PRICECUSTOMER_ADDRESS1ITEM2CUSTOMER1_map_0::IdxNode*>(i26->slice(se67, h26));
          EXT_PRICECUSTOMER_ADDRESS1ITEM2CUSTOMER1_entry* e26;
         
          if (n26 && (e26 = n26->obj)) {
            do {                
              long ext_pricecustomer_address1customercustomer_c_customer_sk = e26->EXT_PRICECUSTOMER_ADDRESS1ITEM2CUSTOMERCUSTOMER_C_CUSTOMER_SK;
              STRING_TYPE store_s_zip = e26->STORE_S_ZIP;
              DOUBLE_TYPE v26 = e26->__av;
              (/*if */(item_i_manager_id == 7L) ? EXT_PRICECUSTOMER_ADDRESS1CUSTOMER1.addOrDelOnZero(se66.modify(ext_pricecustomer_address1customercustomer_c_customer_sk,item_i_manufact_id,item_i_manufact,store_s_zip,item_i_brand,item_i_brand_id),v26) : (void)0);
              n26 = n26->nxt;
            } while (n26 && (e26 = n26->obj) && h26 == n26->hash &&  EXT_PRICECUSTOMER_ADDRESS1ITEM2CUSTOMER1_mapkey0_idxfn::equals(se67, *e26)); 
          }
        }{ //slice 
          const HashIndex_EXT_PRICECUSTOMER1ITEM2_map_0* i27 = static_cast<HashIndex_EXT_PRICECUSTOMER1ITEM2_map_0*>(EXT_PRICECUSTOMER1ITEM2.index[1]);
          const HASH_RES_t h27 = EXT_PRICECUSTOMER1ITEM2_mapkey0_idxfn::hash(se69.modify0(item_i_item_sk));
          HashIndex_EXT_PRICECUSTOMER1ITEM2_map_0::IdxNode* n27 = static_cast<HashIndex_EXT_PRICECUSTOMER1ITEM2_map_0::IdxNode*>(i27->slice(se69, h27));
          EXT_PRICECUSTOMER1ITEM2_entry* e27;
         
          if (n27 && (e27 = n27->obj)) {
            do {                
              long ext_pricecustomercustomer_c_customer_sk = e27->EXT_PRICECUSTOMERCUSTOMER_C_CUSTOMER_SK;
              long ext_pricecustomercustomer_c_current_addr_sk = e27->EXT_PRICECUSTOMERCUSTOMER_C_CURRENT_ADDR_SK;
              DOUBLE_TYPE v27 = e27->__av;
              (/*if */(item_i_manager_id == 7L) ? EXT_PRICECUSTOMER1.addOrDelOnZero(se68.modify(ext_pricecustomercustomer_c_customer_sk,ext_pricecustomercustomer_c_current_addr_sk,item_i_manufact_id,item_i_manufact,item_i_brand,item_i_brand_id),v27) : (void)0);
              n27 = n27->nxt;
            } while (n27 && (e27 = n27->obj) && h27 == n27->hash &&  EXT_PRICECUSTOMER1ITEM2_mapkey0_idxfn::equals(se69, *e27)); 
          }
        }(/*if */(item_i_manager_id == 7L) ? EXT_PRICESTORE_SALES1.addOrDelOnZero(se70.modify(item_i_item_sk,item_i_manufact_id,item_i_manufact,item_i_brand,item_i_brand_id),1L) : (void)0);
      }
    }
    void on_insert_CUSTOMER(const long customer_c_customer_sk, const STRING_TYPE& customer_c_customer_id, const long customer_c_current_cdemo_sk, const long customer_c_current_hdemo_sk, const long customer_c_current_addr_sk, const long customer_c_first_shipto_date_sk, const long customer_c_first_sales_date_sk, const STRING_TYPE& customer_c_salutation, const STRING_TYPE& customer_c_first_name, const STRING_TYPE& customer_c_last_name, const STRING_TYPE& customer_c_preferred_cust_flag, const long customer_c_birth_day, const long customer_c_birth_month, const long customer_c_birth_year, const STRING_TYPE& customer_c_birth_country, const STRING_TYPE& customer_c_login, const STRING_TYPE& customer_c_email_address, const STRING_TYPE& customer_c_last_review_date) {
      {  if (tS>0) { ++tS; return; } if ((tN&127)==0) { gettimeofday(&(t),NULL); tT=((t).tv_sec-(t0).tv_sec)*1000000L+((t).tv_usec-(t0).tv_usec); if (tT>3600000000L) { tS=1; return; } } ++tN;
        { //slice 
          const HashIndex_EXT_PRICECUSTOMER1_map_01* i28 = static_cast<HashIndex_EXT_PRICECUSTOMER1_map_01*>(EXT_PRICECUSTOMER1.index[1]);
          const HASH_RES_t h28 = EXT_PRICECUSTOMER1_mapkey01_idxfn::hash(se72.modify01(customer_c_customer_sk, customer_c_current_addr_sk));
          HashIndex_EXT_PRICECUSTOMER1_map_01::IdxNode* n28 = static_cast<HashIndex_EXT_PRICECUSTOMER1_map_01::IdxNode*>(i28->slice(se72, h28));
          EXT_PRICECUSTOMER1_entry* e28;
         
          if (n28 && (e28 = n28->obj)) {
            do {                
              long item_i_manufact_id = e28->ITEM_I_MANUFACT_ID;
              STRING_TYPE item_i_manufact = e28->ITEM_I_MANUFACT;
              STRING_TYPE brand = e28->BRAND;
              long brand_id = e28->BRAND_ID;
              DOUBLE_TYPE v28 = e28->__av;
              EXT_PRICE.addOrDelOnZero(se71.modify(brand_id,brand,item_i_manufact_id,item_i_manufact),v28);
              n28 = n28->nxt;
            } while (n28 && (e28 = n28->obj) && h28 == n28->hash &&  EXT_PRICECUSTOMER1_mapkey01_idxfn::equals(se72, *e28)); 
          }
        }{ //slice 
          const HashIndex_EXT_PRICESTORE1CUSTOMER1_map_0* i29 = static_cast<HashIndex_EXT_PRICESTORE1CUSTOMER1_map_0*>(EXT_PRICESTORE1CUSTOMER1.index[1]);
          const HASH_RES_t h30 = EXT_PRICESTORE1CUSTOMER1_mapkey0_idxfn::hash(se75.modify0(customer_c_customer_sk));
          HashIndex_EXT_PRICESTORE1CUSTOMER1_map_0::IdxNode* n29 = static_cast<HashIndex_EXT_PRICESTORE1CUSTOMER1_map_0::IdxNode*>(i29->slice(se75, h30));
          EXT_PRICESTORE1CUSTOMER1_entry* e29;
         
          if (n29 && (e29 = n29->obj)) {
            do {                
              long ext_pricestorestore_s_store_sk = e29->EXT_PRICESTORESTORE_S_STORE_SK;
              long item_i_manufact_id = e29->ITEM_I_MANUFACT_ID;
              STRING_TYPE item_i_manufact = e29->ITEM_I_MANUFACT;
              STRING_TYPE brand = e29->BRAND;
              long brand_id = e29->BRAND_ID;
              DOUBLE_TYPE v29 = e29->__av;
              { //slice 
                const HashIndex_EXT_PRICESTORE1CUSTOMER2_map_0* i30 = static_cast<HashIndex_EXT_PRICESTORE1CUSTOMER2_map_0*>(EXT_PRICESTORE1CUSTOMER2.index[1]);
                const HASH_RES_t h29 = EXT_PRICESTORE1CUSTOMER2_mapkey0_idxfn::hash(se74.modify0(customer_c_current_addr_sk));
                HashIndex_EXT_PRICESTORE1CUSTOMER2_map_0::IdxNode* n30 = static_cast<HashIndex_EXT_PRICESTORE1CUSTOMER2_map_0::IdxNode*>(i30->slice(se74, h29));
                EXT_PRICESTORE1CUSTOMER2_entry* e30;
               
                if (n30 && (e30 = n30->obj)) {
                  do {                
                    STRING_TYPE customer_address_ca_zip = e30->CUSTOMER_ADDRESS_CA_ZIP;
                    long v30 = e30->__av;
                    EXT_PRICESTORE1.addOrDelOnZero(se73.modify(ext_pricestorestore_s_store_sk,item_i_manufact_id,item_i_manufact,customer_address_ca_zip,brand,brand_id),(v29 * v30));
                    n30 = n30->nxt;
                  } while (n30 && (e30 = n30->obj) && h29 == n30->hash &&  EXT_PRICESTORE1CUSTOMER2_mapkey0_idxfn::equals(se74, *e30)); 
                }
              }
              n29 = n29->nxt;
            } while (n29 && (e29 = n29->obj) && h30 == n29->hash &&  EXT_PRICESTORE1CUSTOMER1_mapkey0_idxfn::equals(se75, *e29)); 
          }
        }{ //slice 
          const HashIndex_EXT_PRICESTORE1CUSTOMER_ADDRESS1CUSTOMER1_map_0* i31 = static_cast<HashIndex_EXT_PRICESTORE1CUSTOMER_ADDRESS1CUSTOMER1_map_0*>(EXT_PRICESTORE1CUSTOMER_ADDRESS1CUSTOMER1.index[1]);
          const HASH_RES_t h31 = EXT_PRICESTORE1CUSTOMER_ADDRESS1CUSTOMER1_mapkey0_idxfn::hash(se77.modify0(customer_c_customer_sk));
          HashIndex_EXT_PRICESTORE1CUSTOMER_ADDRESS1CUSTOMER1_map_0::IdxNode* n31 = static_cast<HashIndex_EXT_PRICESTORE1CUSTOMER_ADDRESS1CUSTOMER1_map_0::IdxNode*>(i31->slice(se77, h31));
          EXT_PRICESTORE1CUSTOMER_ADDRESS1CUSTOMER1_entry* e31;
         
          if (n31 && (e31 = n31->obj)) {
            do {                
              long ext_pricestorestore_s_store_sk = e31->EXT_PRICESTORESTORE_S_STORE_SK;
              long item_i_manufact_id = e31->ITEM_I_MANUFACT_ID;
              STRING_TYPE item_i_manufact = e31->ITEM_I_MANUFACT;
              long brand_id = e31->BRAND_ID;
              STRING_TYPE brand = e31->BRAND;
              DOUBLE_TYPE v31 = e31->__av;
              EXT_PRICESTORE1CUSTOMER_ADDRESS1.addOrDelOnZero(se76.modify(customer_c_current_addr_sk,ext_pricestorestore_s_store_sk,item_i_manufact_id,item_i_manufact,brand,brand_id),v31);
              n31 = n31->nxt;
            } while (n31 && (e31 = n31->obj) && h31 == n31->hash &&  EXT_PRICESTORE1CUSTOMER_ADDRESS1CUSTOMER1_mapkey0_idxfn::equals(se77, *e31)); 
          }
        }{ //slice 
          const HashIndex_EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2CUSTOMER1_map_1* i32 = static_cast<HashIndex_EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2CUSTOMER1_map_1*>(EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2CUSTOMER1.index[2]);
          const HASH_RES_t h32 = EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2CUSTOMER1_mapkey1_idxfn::hash(se79.modify1(customer_c_customer_sk));
          HashIndex_EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2CUSTOMER1_map_1::IdxNode* n32 = static_cast<HashIndex_EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2CUSTOMER1_map_1::IdxNode*>(i32->slice(se79, h32));
          EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2CUSTOMER1_entry* e32;
         
          if (n32 && (e32 = n32->obj)) {
            do {                
              long ext_pricestore1customer_address1itemitem_i_item_sk = e32->EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEMITEM_I_ITEM_SK;
              long ext_pricestorestore_s_store_sk = e32->EXT_PRICESTORESTORE_S_STORE_SK;
              DOUBLE_TYPE v32 = e32->__av;
              EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2.addOrDelOnZero(se78.modify(ext_pricestore1customer_address1itemitem_i_item_sk,ext_pricestorestore_s_store_sk,customer_c_current_addr_sk),v32);
              n32 = n32->nxt;
            } while (n32 && (e32 = n32->obj) && h32 == n32->hash &&  EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2CUSTOMER1_mapkey1_idxfn::equals(se79, *e32)); 
          }
        }EXT_PRICESTORE1CUSTOMER_ADDRESS1STORE_SALES3.addOrDelOnZero(se80.modify(customer_c_customer_sk,customer_c_current_addr_sk),1L);
        { //slice 
          const HashIndex_EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2CUSTOMER1_map_1* i33 = static_cast<HashIndex_EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2CUSTOMER1_map_1*>(EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2CUSTOMER1.index[2]);
          const HASH_RES_t h34 = EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2CUSTOMER1_mapkey1_idxfn::hash(se83.modify1(customer_c_customer_sk));
          HashIndex_EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2CUSTOMER1_map_1::IdxNode* n33 = static_cast<HashIndex_EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2CUSTOMER1_map_1::IdxNode*>(i33->slice(se83, h34));
          EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2CUSTOMER1_entry* e33;
         
          if (n33 && (e33 = n33->obj)) {
            do {                
              long ext_pricestore1itemitem_i_item_sk = e33->EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEMITEM_I_ITEM_SK;
              long ext_pricestorestore_s_store_sk = e33->EXT_PRICESTORESTORE_S_STORE_SK;
              DOUBLE_TYPE v33 = e33->__av;
              { //slice 
                const HashIndex_EXT_PRICESTORE1CUSTOMER2_map_0* i34 = static_cast<HashIndex_EXT_PRICESTORE1CUSTOMER2_map_0*>(EXT_PRICESTORE1CUSTOMER2.index[1]);
                const HASH_RES_t h33 = EXT_PRICESTORE1CUSTOMER2_mapkey0_idxfn::hash(se82.modify0(customer_c_current_addr_sk));
                HashIndex_EXT_PRICESTORE1CUSTOMER2_map_0::IdxNode* n34 = static_cast<HashIndex_EXT_PRICESTORE1CUSTOMER2_map_0::IdxNode*>(i34->slice(se82, h33));
                EXT_PRICESTORE1CUSTOMER2_entry* e34;
               
                if (n34 && (e34 = n34->obj)) {
                  do {                
                    STRING_TYPE customer_address_ca_zip = e34->CUSTOMER_ADDRESS_CA_ZIP;
                    long v34 = e34->__av;
                    EXT_PRICESTORE1ITEM2.addOrDelOnZero(se81.modify(ext_pricestore1itemitem_i_item_sk,ext_pricestorestore_s_store_sk,customer_address_ca_zip),(v33 * v34));
                    n34 = n34->nxt;
                  } while (n34 && (e34 = n34->obj) && h33 == n34->hash &&  EXT_PRICESTORE1CUSTOMER2_mapkey0_idxfn::equals(se82, *e34)); 
                }
              }
              n33 = n33->nxt;
            } while (n33 && (e33 = n33->obj) && h34 == n33->hash &&  EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2CUSTOMER1_mapkey1_idxfn::equals(se83, *e33)); 
          }
        }{ //slice 
          const HashIndex_EXT_PRICESTORE1CUSTOMER2_map_0* i35 = static_cast<HashIndex_EXT_PRICESTORE1CUSTOMER2_map_0*>(EXT_PRICESTORE1CUSTOMER2.index[1]);
          const HASH_RES_t h35 = EXT_PRICESTORE1CUSTOMER2_mapkey0_idxfn::hash(se85.modify0(customer_c_current_addr_sk));
          HashIndex_EXT_PRICESTORE1CUSTOMER2_map_0::IdxNode* n35 = static_cast<HashIndex_EXT_PRICESTORE1CUSTOMER2_map_0::IdxNode*>(i35->slice(se85, h35));
          EXT_PRICESTORE1CUSTOMER2_entry* e35;
         
          if (n35 && (e35 = n35->obj)) {
            do {                
              STRING_TYPE customer_address_ca_zip = e35->CUSTOMER_ADDRESS_CA_ZIP;
              long v35 = e35->__av;
              EXT_PRICESTORE1STORE_SALES3.addOrDelOnZero(se84.modify(customer_c_customer_sk,customer_address_ca_zip),v35);
              n35 = n35->nxt;
            } while (n35 && (e35 = n35->obj) && h35 == n35->hash &&  EXT_PRICESTORE1CUSTOMER2_mapkey0_idxfn::equals(se85, *e35)); 
          }
        }{ //slice 
          const HashIndex_EXT_PRICECUSTOMER_ADDRESS1CUSTOMER1_map_0* i36 = static_cast<HashIndex_EXT_PRICECUSTOMER_ADDRESS1CUSTOMER1_map_0*>(EXT_PRICECUSTOMER_ADDRESS1CUSTOMER1.index[1]);
          const HASH_RES_t h36 = EXT_PRICECUSTOMER_ADDRESS1CUSTOMER1_mapkey0_idxfn::hash(se87.modify0(customer_c_customer_sk));
          HashIndex_EXT_PRICECUSTOMER_ADDRESS1CUSTOMER1_map_0::IdxNode* n36 = static_cast<HashIndex_EXT_PRICECUSTOMER_ADDRESS1CUSTOMER1_map_0::IdxNode*>(i36->slice(se87, h36));
          EXT_PRICECUSTOMER_ADDRESS1CUSTOMER1_entry* e36;
         
          if (n36 && (e36 = n36->obj)) {
            do {                
              long item_i_manufact_id = e36->ITEM_I_MANUFACT_ID;
              STRING_TYPE item_i_manufact = e36->ITEM_I_MANUFACT;
              STRING_TYPE store_s_zip = e36->STORE_S_ZIP;
              STRING_TYPE brand = e36->BRAND;
              long brand_id = e36->BRAND_ID;
              DOUBLE_TYPE v36 = e36->__av;
              EXT_PRICECUSTOMER_ADDRESS1.addOrDelOnZero(se86.modify(customer_c_current_addr_sk,item_i_manufact_id,item_i_manufact,store_s_zip,brand,brand_id),v36);
              n36 = n36->nxt;
            } while (n36 && (e36 = n36->obj) && h36 == n36->hash &&  EXT_PRICECUSTOMER_ADDRESS1CUSTOMER1_mapkey0_idxfn::equals(se87, *e36)); 
          }
        }{ //slice 
          const HashIndex_EXT_PRICECUSTOMER_ADDRESS1ITEM2CUSTOMER1_map_1* i37 = static_cast<HashIndex_EXT_PRICECUSTOMER_ADDRESS1ITEM2CUSTOMER1_map_1*>(EXT_PRICECUSTOMER_ADDRESS1ITEM2CUSTOMER1.index[2]);
          const HASH_RES_t h37 = EXT_PRICECUSTOMER_ADDRESS1ITEM2CUSTOMER1_mapkey1_idxfn::hash(se89.modify1(customer_c_customer_sk));
          HashIndex_EXT_PRICECUSTOMER_ADDRESS1ITEM2CUSTOMER1_map_1::IdxNode* n37 = static_cast<HashIndex_EXT_PRICECUSTOMER_ADDRESS1ITEM2CUSTOMER1_map_1::IdxNode*>(i37->slice(se89, h37));
          EXT_PRICECUSTOMER_ADDRESS1ITEM2CUSTOMER1_entry* e37;
         
          if (n37 && (e37 = n37->obj)) {
            do {                
              long ext_pricecustomer_address1itemitem_i_item_sk = e37->EXT_PRICECUSTOMER_ADDRESS1ITEMITEM_I_ITEM_SK;
              STRING_TYPE store_s_zip = e37->STORE_S_ZIP;
              DOUBLE_TYPE v37 = e37->__av;
              EXT_PRICECUSTOMER_ADDRESS1ITEM2.addOrDelOnZero(se88.modify(ext_pricecustomer_address1itemitem_i_item_sk,customer_c_current_addr_sk,store_s_zip),v37);
              n37 = n37->nxt;
            } while (n37 && (e37 = n37->obj) && h37 == n37->hash &&  EXT_PRICECUSTOMER_ADDRESS1ITEM2CUSTOMER1_mapkey1_idxfn::equals(se89, *e37)); 
          }
        }{ //slice 
          const HashIndex_EXT_PRICECUSTOMER1ITEM2_map_12* i38 = static_cast<HashIndex_EXT_PRICECUSTOMER1ITEM2_map_12*>(EXT_PRICECUSTOMER1ITEM2.index[2]);
          const HASH_RES_t h38 = EXT_PRICECUSTOMER1ITEM2_mapkey12_idxfn::hash(se91.modify12(customer_c_customer_sk, customer_c_current_addr_sk));
          HashIndex_EXT_PRICECUSTOMER1ITEM2_map_12::IdxNode* n38 = static_cast<HashIndex_EXT_PRICECUSTOMER1ITEM2_map_12::IdxNode*>(i38->slice(se91, h38));
          EXT_PRICECUSTOMER1ITEM2_entry* e38;
         
          if (n38 && (e38 = n38->obj)) {
            do {                
              long ext_priceitemitem_i_item_sk = e38->EXT_PRICECUSTOMER1ITEMITEM_I_ITEM_SK;
              DOUBLE_TYPE v38 = e38->__av;
              EXT_PRICEITEM2.addOrDelOnZero(se90.modify(ext_priceitemitem_i_item_sk),v38);
              n38 = n38->nxt;
            } while (n38 && (e38 = n38->obj) && h38 == n38->hash &&  EXT_PRICECUSTOMER1ITEM2_mapkey12_idxfn::equals(se91, *e38)); 
          }
        }{ //slice 
          const HashIndex_EXT_PRICECUSTOMER1STORE_SALES3_map_1* i39 = static_cast<HashIndex_EXT_PRICECUSTOMER1STORE_SALES3_map_1*>(EXT_PRICECUSTOMER1STORE_SALES3.index[2]);
          const HASH_RES_t h39 = EXT_PRICECUSTOMER1STORE_SALES3_mapkey1_idxfn::hash(se93.modify1(customer_c_current_addr_sk));
          HashIndex_EXT_PRICECUSTOMER1STORE_SALES3_map_1::IdxNode* n39 = static_cast<HashIndex_EXT_PRICECUSTOMER1STORE_SALES3_map_1::IdxNode*>(i39->slice(se93, h39));
          EXT_PRICECUSTOMER1STORE_SALES3_entry* e39;
         
          if (n39 && (e39 = n39->obj)) {
            do {                
              long ext_pricestore_salesstore_sales_ss_store_sk = e39->EXT_PRICECUSTOMER1STORE_SALESSTORE_SALES_SS_STORE_SK;
              long v39 = e39->__av;
              EXT_PRICESTORE_SALES3.addOrDelOnZero(se92.modify(customer_c_customer_sk,ext_pricestore_salesstore_sales_ss_store_sk),v39);
              n39 = n39->nxt;
            } while (n39 && (e39 = n39->obj) && h39 == n39->hash &&  EXT_PRICECUSTOMER1STORE_SALES3_mapkey1_idxfn::equals(se93, *e39)); 
          }
        }
      }
    }
    void on_insert_CUSTOMER_ADDRESS(const long customer_address_ca_address_sk, const STRING_TYPE& customer_address_ca_address_id, const STRING_TYPE& customer_address_ca_street_number, const STRING_TYPE& customer_address_ca_street_name, const STRING_TYPE& customer_address_ca_street_type, const STRING_TYPE& customer_address_ca_suite_number, const STRING_TYPE& customer_address_ca_city, const STRING_TYPE& customer_address_ca_county, const STRING_TYPE& customer_address_ca_state, const STRING_TYPE& customer_address_ca_zip, const STRING_TYPE& customer_address_ca_country, const DOUBLE_TYPE customer_address_ca_gmt_offset, const STRING_TYPE& customer_address_ca_location_type) {
      {  if (tS>0) { ++tS; return; } if ((tN&127)==0) { gettimeofday(&(t),NULL); tT=((t).tv_sec-(t0).tv_sec)*1000000L+((t).tv_usec-(t0).tv_usec); if (tT>3600000000L) { tS=1; return; } } ++tN;
        { //slice 
          const HashIndex_EXT_PRICECUSTOMER_ADDRESS1_map_0* i40 = static_cast<HashIndex_EXT_PRICECUSTOMER_ADDRESS1_map_0*>(EXT_PRICECUSTOMER_ADDRESS1.index[1]);
          const HASH_RES_t h40 = EXT_PRICECUSTOMER_ADDRESS1_mapkey0_idxfn::hash(se95.modify0(customer_address_ca_address_sk));
          HashIndex_EXT_PRICECUSTOMER_ADDRESS1_map_0::IdxNode* n40 = static_cast<HashIndex_EXT_PRICECUSTOMER_ADDRESS1_map_0::IdxNode*>(i40->slice(se95, h40));
          EXT_PRICECUSTOMER_ADDRESS1_entry* e40;
         
          if (n40 && (e40 = n40->obj)) {
            do {                
              long item_i_manufact_id = e40->ITEM_I_MANUFACT_ID;
              STRING_TYPE item_i_manufact = e40->ITEM_I_MANUFACT;
              STRING_TYPE store_s_zip = e40->STORE_S_ZIP;
              STRING_TYPE brand = e40->BRAND;
              long brand_id = e40->BRAND_ID;
              DOUBLE_TYPE v40 = e40->__av;
              (/*if */(Usubstring(customer_address_ca_zip, 1L, 5L) != Usubstring(store_s_zip, 1L, 5L)) ? EXT_PRICE.addOrDelOnZero(se94.modify(brand_id,brand,item_i_manufact_id,item_i_manufact),v40) : (void)0);
              n40 = n40->nxt;
            } while (n40 && (e40 = n40->obj) && h40 == n40->hash &&  EXT_PRICECUSTOMER_ADDRESS1_mapkey0_idxfn::equals(se95, *e40)); 
          }
        }{ //slice 
          const HashIndex_EXT_PRICESTORE1CUSTOMER_ADDRESS1_map_0* i41 = static_cast<HashIndex_EXT_PRICESTORE1CUSTOMER_ADDRESS1_map_0*>(EXT_PRICESTORE1CUSTOMER_ADDRESS1.index[1]);
          const HASH_RES_t h41 = EXT_PRICESTORE1CUSTOMER_ADDRESS1_mapkey0_idxfn::hash(se97.modify0(customer_address_ca_address_sk));
          HashIndex_EXT_PRICESTORE1CUSTOMER_ADDRESS1_map_0::IdxNode* n41 = static_cast<HashIndex_EXT_PRICESTORE1CUSTOMER_ADDRESS1_map_0::IdxNode*>(i41->slice(se97, h41));
          EXT_PRICESTORE1CUSTOMER_ADDRESS1_entry* e41;
         
          if (n41 && (e41 = n41->obj)) {
            do {                
              long ext_pricestorestore_s_store_sk = e41->EXT_PRICESTORESTORE_S_STORE_SK;
              long item_i_manufact_id = e41->ITEM_I_MANUFACT_ID;
              STRING_TYPE item_i_manufact = e41->ITEM_I_MANUFACT;
              STRING_TYPE brand = e41->BRAND;
              long brand_id = e41->BRAND_ID;
              DOUBLE_TYPE v41 = e41->__av;
              EXT_PRICESTORE1.addOrDelOnZero(se96.modify(ext_pricestorestore_s_store_sk,item_i_manufact_id,item_i_manufact,customer_address_ca_zip,brand,brand_id),v41);
              n41 = n41->nxt;
            } while (n41 && (e41 = n41->obj) && h41 == n41->hash &&  EXT_PRICESTORE1CUSTOMER_ADDRESS1_mapkey0_idxfn::equals(se97, *e41)); 
          }
        }EXT_PRICESTORE1CUSTOMER2.addOrDelOnZero(se98.modify(customer_address_ca_address_sk,customer_address_ca_zip),1L);
        { //slice 
          const HashIndex_EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2_map_2* i42 = static_cast<HashIndex_EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2_map_2*>(EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2.index[2]);
          const HASH_RES_t h42 = EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2_mapkey2_idxfn::hash(se100.modify2(customer_address_ca_address_sk));
          HashIndex_EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2_map_2::IdxNode* n42 = static_cast<HashIndex_EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2_map_2::IdxNode*>(i42->slice(se100, h42));
          EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2_entry* e42;
         
          if (n42 && (e42 = n42->obj)) {
            do {                
              long ext_pricestore1itemitem_i_item_sk = e42->EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEMITEM_I_ITEM_SK;
              long ext_pricestorestore_s_store_sk = e42->EXT_PRICESTORESTORE_S_STORE_SK;
              DOUBLE_TYPE v42 = e42->__av;
              EXT_PRICESTORE1ITEM2.addOrDelOnZero(se99.modify(ext_pricestore1itemitem_i_item_sk,ext_pricestorestore_s_store_sk,customer_address_ca_zip),v42);
              n42 = n42->nxt;
            } while (n42 && (e42 = n42->obj) && h42 == n42->hash &&  EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2_mapkey2_idxfn::equals(se100, *e42)); 
          }
        }{ //slice 
          const HashIndex_EXT_PRICESTORE1CUSTOMER_ADDRESS1STORE_SALES3_map_1* i43 = static_cast<HashIndex_EXT_PRICESTORE1CUSTOMER_ADDRESS1STORE_SALES3_map_1*>(EXT_PRICESTORE1CUSTOMER_ADDRESS1STORE_SALES3.index[2]);
          const HASH_RES_t h43 = EXT_PRICESTORE1CUSTOMER_ADDRESS1STORE_SALES3_mapkey1_idxfn::hash(se102.modify1(customer_address_ca_address_sk));
          HashIndex_EXT_PRICESTORE1CUSTOMER_ADDRESS1STORE_SALES3_map_1::IdxNode* n43 = static_cast<HashIndex_EXT_PRICESTORE1CUSTOMER_ADDRESS1STORE_SALES3_map_1::IdxNode*>(i43->slice(se102, h43));
          EXT_PRICESTORE1CUSTOMER_ADDRESS1STORE_SALES3_entry* e43;
         
          if (n43 && (e43 = n43->obj)) {
            do {                
              long ext_pricestore1store_salesstore_sales_ss_customer_sk = e43->EXT_PRICESTORE1CUSTOMER_ADDRESS1STORE_SALESSTORE_SALES_SS_CUSTOMER_SK;
              long v43 = e43->__av;
              EXT_PRICESTORE1STORE_SALES3.addOrDelOnZero(se101.modify(ext_pricestore1store_salesstore_sales_ss_customer_sk,customer_address_ca_zip),v43);
              n43 = n43->nxt;
            } while (n43 && (e43 = n43->obj) && h43 == n43->hash &&  EXT_PRICESTORE1CUSTOMER_ADDRESS1STORE_SALES3_mapkey1_idxfn::equals(se102, *e43)); 
          }
        }agg1.clear();
        
        {  // foreach
          const HashIndex_EXT_PRICECUSTOMER_ADDRESS1CUSTOMER1_map_012345* i44 = static_cast<HashIndex_EXT_PRICECUSTOMER_ADDRESS1CUSTOMER1_map_012345*>(EXT_PRICECUSTOMER_ADDRESS1CUSTOMER1.index[0]);
          HashIndex_EXT_PRICECUSTOMER_ADDRESS1CUSTOMER1_map_012345::IdxNode* n44; 
          EXT_PRICECUSTOMER_ADDRESS1CUSTOMER1_entry* e44;
        
          for (size_t i = 0; i < i44->size_; i++)
          {
            n44 = i44->buckets_ + i;
            while (n44 && (e44 = n44->obj))
            {
                long ext_pricecustomercustomer_c_customer_sk = e44->EXT_PRICECUSTOMER_ADDRESS1CUSTOMERCUSTOMER_C_CUSTOMER_SK;
                long item_i_manufact_id = e44->ITEM_I_MANUFACT_ID;
                STRING_TYPE item_i_manufact = e44->ITEM_I_MANUFACT;
                STRING_TYPE store_s_zip = e44->STORE_S_ZIP;
                STRING_TYPE brand = e44->BRAND;
                long brand_id = e44->BRAND_ID;
                DOUBLE_TYPE v44 = e44->__av;
                (/*if */(Usubstring(customer_address_ca_zip, 1L, 5L) != Usubstring(store_s_zip, 1L, 5L)) ? agg1.addOrDelOnZero(st1.modify(ext_pricecustomercustomer_c_customer_sk,item_i_manufact_id,item_i_manufact,brand,brand_id,v44), v44) : (void)0);
              n44 = n44->nxt;
            }
          }
        }{  // temp foreach
          const HashIndex<tuple6_LLSSL_D, DOUBLE_TYPE>* i45 = static_cast<HashIndex<tuple6_LLSSL_D, DOUBLE_TYPE>*>(agg1.index[0]);
          HashIndex<tuple6_LLSSL_D, DOUBLE_TYPE>::IdxNode* n45; 
          tuple6_LLSSL_D* e45;
        
          for (size_t i = 0; i < i45->size_; i++)
          {
            n45 = i45->buckets_ + i;
            while (n45 && (e45 = n45->obj))
            {
              long ext_pricecustomercustomer_c_customer_sk = e45->_1;
              long item_i_manufact_id = e45->_2;
              STRING_TYPE item_i_manufact = e45->_3;
              STRING_TYPE brand = e45->_4;
              long brand_id = e45->_5;  
              DOUBLE_TYPE v45 = e45->__av; 
            EXT_PRICECUSTOMER1.addOrDelOnZero(se103.modify(ext_pricecustomercustomer_c_customer_sk,customer_address_ca_address_sk,item_i_manufact_id,item_i_manufact,brand,brand_id),v45);      
              n45 = n45->nxt;
            }
          }
        }agg2.clear();
        
        {  // foreach
          const HashIndex_EXT_PRICECUSTOMER_ADDRESS1ITEM2CUSTOMER1_map_012* i46 = static_cast<HashIndex_EXT_PRICECUSTOMER_ADDRESS1ITEM2CUSTOMER1_map_012*>(EXT_PRICECUSTOMER_ADDRESS1ITEM2CUSTOMER1.index[0]);
          HashIndex_EXT_PRICECUSTOMER_ADDRESS1ITEM2CUSTOMER1_map_012::IdxNode* n46; 
          EXT_PRICECUSTOMER_ADDRESS1ITEM2CUSTOMER1_entry* e46;
        
          for (size_t i = 0; i < i46->size_; i++)
          {
            n46 = i46->buckets_ + i;
            while (n46 && (e46 = n46->obj))
            {
                long ext_pricecustomer1itemitem_i_item_sk = e46->EXT_PRICECUSTOMER_ADDRESS1ITEMITEM_I_ITEM_SK;
                long ext_pricecustomercustomer_c_customer_sk = e46->EXT_PRICECUSTOMER_ADDRESS1ITEM2CUSTOMERCUSTOMER_C_CUSTOMER_SK;
                STRING_TYPE store_s_zip = e46->STORE_S_ZIP;
                DOUBLE_TYPE v46 = e46->__av;
                (/*if */(Usubstring(customer_address_ca_zip, 1L, 5L) != Usubstring(store_s_zip, 1L, 5L)) ? agg2.addOrDelOnZero(st2.modify(ext_pricecustomer1itemitem_i_item_sk,ext_pricecustomercustomer_c_customer_sk,v46), v46) : (void)0);
              n46 = n46->nxt;
            }
          }
        }{  // temp foreach
          const HashIndex<tuple3_LL_D, DOUBLE_TYPE>* i47 = static_cast<HashIndex<tuple3_LL_D, DOUBLE_TYPE>*>(agg2.index[0]);
          HashIndex<tuple3_LL_D, DOUBLE_TYPE>::IdxNode* n47; 
          tuple3_LL_D* e47;
        
          for (size_t i = 0; i < i47->size_; i++)
          {
            n47 = i47->buckets_ + i;
            while (n47 && (e47 = n47->obj))
            {
              long ext_pricecustomer1itemitem_i_item_sk = e47->_1;
              long ext_pricecustomercustomer_c_customer_sk = e47->_2;  
              DOUBLE_TYPE v47 = e47->__av; 
            EXT_PRICECUSTOMER1ITEM2.addOrDelOnZero(se104.modify(ext_pricecustomer1itemitem_i_item_sk,ext_pricecustomercustomer_c_customer_sk,customer_address_ca_address_sk),v47);      
              n47 = n47->nxt;
            }
          }
        }agg3.clear();
        
        {  // foreach
          const HashIndex_EXT_PRICECUSTOMER_ADDRESS1STORE_SALES4_map_01* i48 = static_cast<HashIndex_EXT_PRICECUSTOMER_ADDRESS1STORE_SALES4_map_01*>(EXT_PRICECUSTOMER_ADDRESS1STORE_SALES4.index[0]);
          HashIndex_EXT_PRICECUSTOMER_ADDRESS1STORE_SALES4_map_01::IdxNode* n48; 
          EXT_PRICECUSTOMER_ADDRESS1STORE_SALES4_entry* e48;
        
          for (size_t i = 0; i < i48->size_; i++)
          {
            n48 = i48->buckets_ + i;
            while (n48 && (e48 = n48->obj))
            {
                long ext_pricecustomer1store_salesstore_sales_ss_store_sk = e48->EXT_PRICECUSTOMER_ADDRESS1STORE_SALESSTORE_SALES_SS_STORE_SK;
                STRING_TYPE store_s_zip = e48->STORE_S_ZIP;
                long v48 = e48->__av;
                (/*if */(Usubstring(customer_address_ca_zip, 1L, 5L) != Usubstring(store_s_zip, 1L, 5L)) ? agg3.addOrDelOnZero(st3.modify(ext_pricecustomer1store_salesstore_sales_ss_store_sk,v48), v48) : (void)0);
              n48 = n48->nxt;
            }
          }
        }{  // temp foreach
          const HashIndex<tuple2_L_L, long>* i49 = static_cast<HashIndex<tuple2_L_L, long>*>(agg3.index[0]);
          HashIndex<tuple2_L_L, long>::IdxNode* n49; 
          tuple2_L_L* e49;
        
          for (size_t i = 0; i < i49->size_; i++)
          {
            n49 = i49->buckets_ + i;
            while (n49 && (e49 = n49->obj))
            {
              long ext_pricecustomer1store_salesstore_sales_ss_store_sk = e49->_1;  
              long v49 = e49->__av; 
            EXT_PRICECUSTOMER1STORE_SALES3.addOrDelOnZero(se105.modify(ext_pricecustomer1store_salesstore_sales_ss_store_sk,customer_address_ca_address_sk),v49);      
              n49 = n49->nxt;
            }
          }
        }{ //slice 
          const HashIndex_EXT_PRICECUSTOMER_ADDRESS1ITEM2_map_1* i50 = static_cast<HashIndex_EXT_PRICECUSTOMER_ADDRESS1ITEM2_map_1*>(EXT_PRICECUSTOMER_ADDRESS1ITEM2.index[2]);
          const HASH_RES_t h44 = EXT_PRICECUSTOMER_ADDRESS1ITEM2_mapkey1_idxfn::hash(se107.modify1(customer_address_ca_address_sk));
          HashIndex_EXT_PRICECUSTOMER_ADDRESS1ITEM2_map_1::IdxNode* n50 = static_cast<HashIndex_EXT_PRICECUSTOMER_ADDRESS1ITEM2_map_1::IdxNode*>(i50->slice(se107, h44));
          EXT_PRICECUSTOMER_ADDRESS1ITEM2_entry* e50;
         
          if (n50 && (e50 = n50->obj)) {
            do {                
              long ext_priceitemitem_i_item_sk = e50->EXT_PRICECUSTOMER_ADDRESS1ITEMITEM_I_ITEM_SK;
              STRING_TYPE store_s_zip = e50->STORE_S_ZIP;
              DOUBLE_TYPE v50 = e50->__av;
              (/*if */(Usubstring(customer_address_ca_zip, 1L, 5L) != Usubstring(store_s_zip, 1L, 5L)) ? EXT_PRICEITEM2.addOrDelOnZero(se106.modify(ext_priceitemitem_i_item_sk),v50) : (void)0);
              n50 = n50->nxt;
            } while (n50 && (e50 = n50->obj) && h44 == n50->hash &&  EXT_PRICECUSTOMER_ADDRESS1ITEM2_mapkey1_idxfn::equals(se107, *e50)); 
          }
        }agg4.clear();
        
        {  // foreach
          const HashIndex_EXT_PRICECUSTOMER_ADDRESS1STORE_SALES4_map_01* i51 = static_cast<HashIndex_EXT_PRICECUSTOMER_ADDRESS1STORE_SALES4_map_01*>(EXT_PRICECUSTOMER_ADDRESS1STORE_SALES4.index[0]);
          HashIndex_EXT_PRICECUSTOMER_ADDRESS1STORE_SALES4_map_01::IdxNode* n51; 
          EXT_PRICECUSTOMER_ADDRESS1STORE_SALES4_entry* e51;
        
          for (size_t i = 0; i < i51->size_; i++)
          {
            n51 = i51->buckets_ + i;
            while (n51 && (e51 = n51->obj))
            {
                long ext_pricestore_salesstore_sales_ss_store_sk = e51->EXT_PRICECUSTOMER_ADDRESS1STORE_SALESSTORE_SALES_SS_STORE_SK;
                STRING_TYPE store_s_zip = e51->STORE_S_ZIP;
                long v51 = e51->__av;
                (/*if */(Usubstring(customer_address_ca_zip, 1L, 5L) != Usubstring(store_s_zip, 1L, 5L)) ? agg4.addOrDelOnZero(st4.modify(ext_pricestore_salesstore_sales_ss_store_sk,v51), v51) : (void)0);
              n51 = n51->nxt;
            }
          }
        }{  // temp foreach
          const HashIndex<tuple2_L_L, long>* i52 = static_cast<HashIndex<tuple2_L_L, long>*>(agg4.index[0]);
          HashIndex<tuple2_L_L, long>::IdxNode* n52; 
          tuple2_L_L* e52;
        
          for (size_t i = 0; i < i52->size_; i++)
          {
            n52 = i52->buckets_ + i;
            while (n52 && (e52 = n52->obj))
            {
              long ext_pricestore_salesstore_sales_ss_store_sk = e52->_1;  
              long v52 = e52->__av; 
            { //slice 
              const HashIndex_EXT_PRICESTORE1CUSTOMER_ADDRESS1STORE_SALES3_map_1* i53 = static_cast<HashIndex_EXT_PRICESTORE1CUSTOMER_ADDRESS1STORE_SALES3_map_1*>(EXT_PRICESTORE1CUSTOMER_ADDRESS1STORE_SALES3.index[2]);
              const HASH_RES_t h45 = EXT_PRICESTORE1CUSTOMER_ADDRESS1STORE_SALES3_mapkey1_idxfn::hash(se109.modify1(customer_address_ca_address_sk));
              HashIndex_EXT_PRICESTORE1CUSTOMER_ADDRESS1STORE_SALES3_map_1::IdxNode* n53 = static_cast<HashIndex_EXT_PRICESTORE1CUSTOMER_ADDRESS1STORE_SALES3_map_1::IdxNode*>(i53->slice(se109, h45));
              EXT_PRICESTORE1CUSTOMER_ADDRESS1STORE_SALES3_entry* e53;
             
              if (n53 && (e53 = n53->obj)) {
                do {                
                  long ext_pricestore_salesstore_sales_ss_customer_sk = e53->EXT_PRICESTORE1CUSTOMER_ADDRESS1STORE_SALESSTORE_SALES_SS_CUSTOMER_SK;
                  long v53 = e53->__av;
                  EXT_PRICESTORE_SALES3.addOrDelOnZero(se108.modify(ext_pricestore_salesstore_sales_ss_customer_sk,ext_pricestore_salesstore_sales_ss_store_sk),(v52 * v53));
                  n53 = n53->nxt;
                } while (n53 && (e53 = n53->obj) && h45 == n53->hash &&  EXT_PRICESTORE1CUSTOMER_ADDRESS1STORE_SALES3_mapkey1_idxfn::equals(se109, *e53)); 
              }
            }      
              n52 = n52->nxt;
            }
          }
        }
      }
    }
    void on_insert_STORE(const long store_s_store_sk, const STRING_TYPE& store_s_store_id, const date store_s_rec_start_date, const date store_s_rec_end_date, const long store_s_closed_date_sk, const STRING_TYPE& store_s_store_name, const long store_s_number_employees, const long store_s_floor_space, const STRING_TYPE& store_s_hours, const STRING_TYPE& store_s_manager, const long store_s_market_id, const STRING_TYPE& store_s_geography_class, const STRING_TYPE& store_s_market_desc, const STRING_TYPE& store_s_market_manager, const long store_s_division_id, const STRING_TYPE& store_s_division_name, const long store_s_company_id, const STRING_TYPE& store_s_company_name, const STRING_TYPE& store_s_street_number, const STRING_TYPE& store_s_street_name, const STRING_TYPE& store_s_street_type, const STRING_TYPE& store_s_suite_number, const STRING_TYPE& store_s_city, const STRING_TYPE& store_s_county, const STRING_TYPE& store_s_state, const STRING_TYPE& store_s_zip, const STRING_TYPE& store_s_country, const DOUBLE_TYPE store_s_gmt_offset, const DOUBLE_TYPE store_s_tax_precentage) {
      {  if (tS>0) { ++tS; return; } if ((tN&127)==0) { gettimeofday(&(t),NULL); tT=((t).tv_sec-(t0).tv_sec)*1000000L+((t).tv_usec-(t0).tv_usec); if (tT>3600000000L) { tS=1; return; } } ++tN;
        { //slice 
          const HashIndex_EXT_PRICESTORE1_map_0* i54 = static_cast<HashIndex_EXT_PRICESTORE1_map_0*>(EXT_PRICESTORE1.index[1]);
          const HASH_RES_t h46 = EXT_PRICESTORE1_mapkey0_idxfn::hash(se111.modify0(store_s_store_sk));
          HashIndex_EXT_PRICESTORE1_map_0::IdxNode* n54 = static_cast<HashIndex_EXT_PRICESTORE1_map_0::IdxNode*>(i54->slice(se111, h46));
          EXT_PRICESTORE1_entry* e54;
         
          if (n54 && (e54 = n54->obj)) {
            do {                
              long item_i_manufact_id = e54->ITEM_I_MANUFACT_ID;
              STRING_TYPE item_i_manufact = e54->ITEM_I_MANUFACT;
              STRING_TYPE customer_address_ca_zip = e54->CUSTOMER_ADDRESS_CA_ZIP;
              STRING_TYPE brand = e54->BRAND;
              long brand_id = e54->BRAND_ID;
              DOUBLE_TYPE v54 = e54->__av;
              (/*if */(Usubstring(customer_address_ca_zip, 1L, 5L) != Usubstring(store_s_zip, 1L, 5L)) ? EXT_PRICE.addOrDelOnZero(se110.modify(brand_id,brand,item_i_manufact_id,item_i_manufact),v54) : (void)0);
              n54 = n54->nxt;
            } while (n54 && (e54 = n54->obj) && h46 == n54->hash &&  EXT_PRICESTORE1_mapkey0_idxfn::equals(se111, *e54)); 
          }
        }{ //slice 
          const HashIndex_EXT_PRICESTORE1CUSTOMER_ADDRESS1_map_1* i55 = static_cast<HashIndex_EXT_PRICESTORE1CUSTOMER_ADDRESS1_map_1*>(EXT_PRICESTORE1CUSTOMER_ADDRESS1.index[2]);
          const HASH_RES_t h47 = EXT_PRICESTORE1CUSTOMER_ADDRESS1_mapkey1_idxfn::hash(se113.modify1(store_s_store_sk));
          HashIndex_EXT_PRICESTORE1CUSTOMER_ADDRESS1_map_1::IdxNode* n55 = static_cast<HashIndex_EXT_PRICESTORE1CUSTOMER_ADDRESS1_map_1::IdxNode*>(i55->slice(se113, h47));
          EXT_PRICESTORE1CUSTOMER_ADDRESS1_entry* e55;
         
          if (n55 && (e55 = n55->obj)) {
            do {                
              long ext_pricecustomer_addresscustomer_address_ca_address_sk = e55->EXT_PRICESTORE1CUSTOMER_ADDRESSCUSTOMER_ADDRESS_CA_ADDRESS_SK;
              long item_i_manufact_id = e55->ITEM_I_MANUFACT_ID;
              STRING_TYPE item_i_manufact = e55->ITEM_I_MANUFACT;
              STRING_TYPE brand = e55->BRAND;
              long brand_id = e55->BRAND_ID;
              DOUBLE_TYPE v55 = e55->__av;
              EXT_PRICECUSTOMER_ADDRESS1.addOrDelOnZero(se112.modify(ext_pricecustomer_addresscustomer_address_ca_address_sk,item_i_manufact_id,item_i_manufact,store_s_zip,brand,brand_id),v55);
              n55 = n55->nxt;
            } while (n55 && (e55 = n55->obj) && h47 == n55->hash &&  EXT_PRICESTORE1CUSTOMER_ADDRESS1_mapkey1_idxfn::equals(se113, *e55)); 
          }
        }{ //slice 
          const HashIndex_EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2_map_1* i56 = static_cast<HashIndex_EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2_map_1*>(EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2.index[3]);
          const HASH_RES_t h48 = EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2_mapkey1_idxfn::hash(se115.modify1(store_s_store_sk));
          HashIndex_EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2_map_1::IdxNode* n56 = static_cast<HashIndex_EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2_map_1::IdxNode*>(i56->slice(se115, h48));
          EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2_entry* e56;
         
          if (n56 && (e56 = n56->obj)) {
            do {                
              long ext_pricecustomer_address1itemitem_i_item_sk = e56->EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEMITEM_I_ITEM_SK;
              long ext_pricecustomer_addresscustomer_address_ca_address_sk = e56->EXT_PRICESTORE1CUSTOMER_ADDRESSCUSTOMER_ADDRESS_CA_ADDRESS_SK;
              DOUBLE_TYPE v56 = e56->__av;
              EXT_PRICECUSTOMER_ADDRESS1ITEM2.addOrDelOnZero(se114.modify(ext_pricecustomer_address1itemitem_i_item_sk,ext_pricecustomer_addresscustomer_address_ca_address_sk,store_s_zip),v56);
              n56 = n56->nxt;
            } while (n56 && (e56 = n56->obj) && h48 == n56->hash &&  EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2_mapkey1_idxfn::equals(se115, *e56)); 
          }
        }{ //slice 
          const HashIndex_EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2CUSTOMER1_map_2* i57 = static_cast<HashIndex_EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2CUSTOMER1_map_2*>(EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2CUSTOMER1.index[3]);
          const HASH_RES_t h49 = EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2CUSTOMER1_mapkey2_idxfn::hash(se117.modify2(store_s_store_sk));
          HashIndex_EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2CUSTOMER1_map_2::IdxNode* n57 = static_cast<HashIndex_EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2CUSTOMER1_map_2::IdxNode*>(i57->slice(se117, h49));
          EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2CUSTOMER1_entry* e57;
         
          if (n57 && (e57 = n57->obj)) {
            do {                
              long ext_pricecustomer_address1itemitem_i_item_sk = e57->EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEMITEM_I_ITEM_SK;
              long ext_pricecustomer_address1item2customercustomer_c_customer_sk = e57->EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2CUSTOMERCUSTOMER_C_CUSTOMER_SK;
              DOUBLE_TYPE v57 = e57->__av;
              EXT_PRICECUSTOMER_ADDRESS1ITEM2CUSTOMER1.addOrDelOnZero(se116.modify(ext_pricecustomer_address1itemitem_i_item_sk,ext_pricecustomer_address1item2customercustomer_c_customer_sk,store_s_zip),v57);
              n57 = n57->nxt;
            } while (n57 && (e57 = n57->obj) && h49 == n57->hash &&  EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2CUSTOMER1_mapkey2_idxfn::equals(se117, *e57)); 
          }
        }EXT_PRICECUSTOMER_ADDRESS1STORE_SALES4.addOrDelOnZero(se118.modify(store_s_store_sk,store_s_zip),1L);
        { //slice 
          const HashIndex_EXT_PRICESTORE1CUSTOMER1_map_1* i58 = static_cast<HashIndex_EXT_PRICESTORE1CUSTOMER1_map_1*>(EXT_PRICESTORE1CUSTOMER1.index[2]);
          const HASH_RES_t h50 = EXT_PRICESTORE1CUSTOMER1_mapkey1_idxfn::hash(se120.modify1(store_s_store_sk));
          HashIndex_EXT_PRICESTORE1CUSTOMER1_map_1::IdxNode* n58 = static_cast<HashIndex_EXT_PRICESTORE1CUSTOMER1_map_1::IdxNode*>(i58->slice(se120, h50));
          EXT_PRICESTORE1CUSTOMER1_entry* e58;
         
          if (n58 && (e58 = n58->obj)) {
            do {                
              long ext_pricecustomer_address1customercustomer_c_customer_sk = e58->EXT_PRICESTORE1CUSTOMERCUSTOMER_C_CUSTOMER_SK;
              long item_i_manufact_id = e58->ITEM_I_MANUFACT_ID;
              STRING_TYPE item_i_manufact = e58->ITEM_I_MANUFACT;
              STRING_TYPE brand = e58->BRAND;
              long brand_id = e58->BRAND_ID;
              DOUBLE_TYPE v58 = e58->__av;
              EXT_PRICECUSTOMER_ADDRESS1CUSTOMER1.addOrDelOnZero(se119.modify(ext_pricecustomer_address1customercustomer_c_customer_sk,item_i_manufact_id,item_i_manufact,store_s_zip,brand,brand_id),v58);
              n58 = n58->nxt;
            } while (n58 && (e58 = n58->obj) && h50 == n58->hash &&  EXT_PRICESTORE1CUSTOMER1_mapkey1_idxfn::equals(se120, *e58)); 
          }
        }agg5.clear();
        
        {  // foreach
          const HashIndex_EXT_PRICESTORE1CUSTOMER2_map_01* i59 = static_cast<HashIndex_EXT_PRICESTORE1CUSTOMER2_map_01*>(EXT_PRICESTORE1CUSTOMER2.index[0]);
          HashIndex_EXT_PRICESTORE1CUSTOMER2_map_01::IdxNode* n59; 
          EXT_PRICESTORE1CUSTOMER2_entry* e59;
        
          for (size_t i = 0; i < i59->size_; i++)
          {
            n59 = i59->buckets_ + i;
            while (n59 && (e59 = n59->obj))
            {
                long ext_pricecustomercustomer_c_current_addr_sk = e59->EXT_PRICESTORE1CUSTOMERCUSTOMER_C_CURRENT_ADDR_SK;
                STRING_TYPE customer_address_ca_zip = e59->CUSTOMER_ADDRESS_CA_ZIP;
                long v59 = e59->__av;
                (/*if */(Usubstring(customer_address_ca_zip, 1L, 5L) != Usubstring(store_s_zip, 1L, 5L)) ? agg5.addOrDelOnZero(st5.modify(ext_pricecustomercustomer_c_current_addr_sk,v59), v59) : (void)0);
              n59 = n59->nxt;
            }
          }
        }{  // temp foreach
          const HashIndex<tuple2_L_L, long>* i60 = static_cast<HashIndex<tuple2_L_L, long>*>(agg5.index[0]);
          HashIndex<tuple2_L_L, long>::IdxNode* n60; 
          tuple2_L_L* e60;
        
          for (size_t i = 0; i < i60->size_; i++)
          {
            n60 = i60->buckets_ + i;
            while (n60 && (e60 = n60->obj))
            {
              long ext_pricecustomercustomer_c_current_addr_sk = e60->_1;  
              long v60 = e60->__av; 
            { //slice 
              const HashIndex_EXT_PRICESTORE1CUSTOMER_ADDRESS1CUSTOMER1_map_1* i61 = static_cast<HashIndex_EXT_PRICESTORE1CUSTOMER_ADDRESS1CUSTOMER1_map_1*>(EXT_PRICESTORE1CUSTOMER_ADDRESS1CUSTOMER1.index[2]);
              const HASH_RES_t h51 = EXT_PRICESTORE1CUSTOMER_ADDRESS1CUSTOMER1_mapkey1_idxfn::hash(se122.modify1(store_s_store_sk));
              HashIndex_EXT_PRICESTORE1CUSTOMER_ADDRESS1CUSTOMER1_map_1::IdxNode* n61 = static_cast<HashIndex_EXT_PRICESTORE1CUSTOMER_ADDRESS1CUSTOMER1_map_1::IdxNode*>(i61->slice(se122, h51));
              EXT_PRICESTORE1CUSTOMER_ADDRESS1CUSTOMER1_entry* e61;
             
              if (n61 && (e61 = n61->obj)) {
                do {                
                  long ext_pricecustomercustomer_c_customer_sk = e61->EXT_PRICESTORE1CUSTOMER_ADDRESS1CUSTOMERCUSTOMER_C_CUSTOMER_SK;
                  long item_i_manufact_id = e61->ITEM_I_MANUFACT_ID;
                  STRING_TYPE item_i_manufact = e61->ITEM_I_MANUFACT;
                  long brand_id = e61->BRAND_ID;
                  STRING_TYPE brand = e61->BRAND;
                  DOUBLE_TYPE v61 = e61->__av;
                  EXT_PRICECUSTOMER1.addOrDelOnZero(se121.modify(ext_pricecustomercustomer_c_customer_sk,ext_pricecustomercustomer_c_current_addr_sk,item_i_manufact_id,item_i_manufact,brand,brand_id),(v60 * v61));
                  n61 = n61->nxt;
                } while (n61 && (e61 = n61->obj) && h51 == n61->hash &&  EXT_PRICESTORE1CUSTOMER_ADDRESS1CUSTOMER1_mapkey1_idxfn::equals(se122, *e61)); 
              }
            }      
              n60 = n60->nxt;
            }
          }
        }agg6.clear();
        
        {  // foreach
          const HashIndex_EXT_PRICESTORE1CUSTOMER2_map_01* i62 = static_cast<HashIndex_EXT_PRICESTORE1CUSTOMER2_map_01*>(EXT_PRICESTORE1CUSTOMER2.index[0]);
          HashIndex_EXT_PRICESTORE1CUSTOMER2_map_01::IdxNode* n62; 
          EXT_PRICESTORE1CUSTOMER2_entry* e62;
        
          for (size_t i = 0; i < i62->size_; i++)
          {
            n62 = i62->buckets_ + i;
            while (n62 && (e62 = n62->obj))
            {
                long ext_pricecustomercustomer_c_current_addr_sk = e62->EXT_PRICESTORE1CUSTOMERCUSTOMER_C_CURRENT_ADDR_SK;
                STRING_TYPE customer_address_ca_zip = e62->CUSTOMER_ADDRESS_CA_ZIP;
                long v62 = e62->__av;
                (/*if */(Usubstring(customer_address_ca_zip, 1L, 5L) != Usubstring(store_s_zip, 1L, 5L)) ? agg6.addOrDelOnZero(st6.modify(ext_pricecustomercustomer_c_current_addr_sk,v62), v62) : (void)0);
              n62 = n62->nxt;
            }
          }
        }{  // temp foreach
          const HashIndex<tuple2_L_L, long>* i63 = static_cast<HashIndex<tuple2_L_L, long>*>(agg6.index[0]);
          HashIndex<tuple2_L_L, long>::IdxNode* n63; 
          tuple2_L_L* e63;
        
          for (size_t i = 0; i < i63->size_; i++)
          {
            n63 = i63->buckets_ + i;
            while (n63 && (e63 = n63->obj))
            {
              long ext_pricecustomercustomer_c_current_addr_sk = e63->_1;  
              long v63 = e63->__av; 
            { //slice 
              const HashIndex_EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2CUSTOMER1_map_2* i64 = static_cast<HashIndex_EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2CUSTOMER1_map_2*>(EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2CUSTOMER1.index[3]);
              const HASH_RES_t h52 = EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2CUSTOMER1_mapkey2_idxfn::hash(se124.modify2(store_s_store_sk));
              HashIndex_EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2CUSTOMER1_map_2::IdxNode* n64 = static_cast<HashIndex_EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2CUSTOMER1_map_2::IdxNode*>(i64->slice(se124, h52));
              EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2CUSTOMER1_entry* e64;
             
              if (n64 && (e64 = n64->obj)) {
                do {                
                  long ext_pricecustomer1itemitem_i_item_sk = e64->EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEMITEM_I_ITEM_SK;
                  long ext_pricecustomercustomer_c_customer_sk = e64->EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2CUSTOMERCUSTOMER_C_CUSTOMER_SK;
                  DOUBLE_TYPE v64 = e64->__av;
                  EXT_PRICECUSTOMER1ITEM2.addOrDelOnZero(se123.modify(ext_pricecustomer1itemitem_i_item_sk,ext_pricecustomercustomer_c_customer_sk,ext_pricecustomercustomer_c_current_addr_sk),(v63 * v64));
                  n64 = n64->nxt;
                } while (n64 && (e64 = n64->obj) && h52 == n64->hash &&  EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2CUSTOMER1_mapkey2_idxfn::equals(se124, *e64)); 
              }
            }      
              n63 = n63->nxt;
            }
          }
        }agg7.clear();
        
        {  // foreach
          const HashIndex_EXT_PRICESTORE1CUSTOMER2_map_01* i65 = static_cast<HashIndex_EXT_PRICESTORE1CUSTOMER2_map_01*>(EXT_PRICESTORE1CUSTOMER2.index[0]);
          HashIndex_EXT_PRICESTORE1CUSTOMER2_map_01::IdxNode* n65; 
          EXT_PRICESTORE1CUSTOMER2_entry* e65;
        
          for (size_t i = 0; i < i65->size_; i++)
          {
            n65 = i65->buckets_ + i;
            while (n65 && (e65 = n65->obj))
            {
                long ext_pricecustomercustomer_c_current_addr_sk = e65->EXT_PRICESTORE1CUSTOMERCUSTOMER_C_CURRENT_ADDR_SK;
                STRING_TYPE customer_address_ca_zip = e65->CUSTOMER_ADDRESS_CA_ZIP;
                long v65 = e65->__av;
                (/*if */(Usubstring(customer_address_ca_zip, 1L, 5L) != Usubstring(store_s_zip, 1L, 5L)) ? agg7.addOrDelOnZero(st7.modify(ext_pricecustomercustomer_c_current_addr_sk,v65), v65) : (void)0);
              n65 = n65->nxt;
            }
          }
        }{  // temp foreach
          const HashIndex<tuple2_L_L, long>* i66 = static_cast<HashIndex<tuple2_L_L, long>*>(agg7.index[0]);
          HashIndex<tuple2_L_L, long>::IdxNode* n66; 
          tuple2_L_L* e66;
        
          for (size_t i = 0; i < i66->size_; i++)
          {
            n66 = i66->buckets_ + i;
            while (n66 && (e66 = n66->obj))
            {
              long ext_pricecustomercustomer_c_current_addr_sk = e66->_1;  
              long v66 = e66->__av; 
            EXT_PRICECUSTOMER1STORE_SALES3.addOrDelOnZero(se125.modify(store_s_store_sk,ext_pricecustomercustomer_c_current_addr_sk),v66);      
              n66 = n66->nxt;
            }
          }
        }{ //slice 
          const HashIndex_EXT_PRICESTORE1ITEM2_map_1* i67 = static_cast<HashIndex_EXT_PRICESTORE1ITEM2_map_1*>(EXT_PRICESTORE1ITEM2.index[2]);
          const HASH_RES_t h53 = EXT_PRICESTORE1ITEM2_mapkey1_idxfn::hash(se127.modify1(store_s_store_sk));
          HashIndex_EXT_PRICESTORE1ITEM2_map_1::IdxNode* n67 = static_cast<HashIndex_EXT_PRICESTORE1ITEM2_map_1::IdxNode*>(i67->slice(se127, h53));
          EXT_PRICESTORE1ITEM2_entry* e67;
         
          if (n67 && (e67 = n67->obj)) {
            do {                
              long ext_priceitemitem_i_item_sk = e67->EXT_PRICESTORE1ITEMITEM_I_ITEM_SK;
              STRING_TYPE customer_address_ca_zip = e67->CUSTOMER_ADDRESS_CA_ZIP;
              DOUBLE_TYPE v67 = e67->__av;
              (/*if */(Usubstring(customer_address_ca_zip, 1L, 5L) != Usubstring(store_s_zip, 1L, 5L)) ? EXT_PRICEITEM2.addOrDelOnZero(se126.modify(ext_priceitemitem_i_item_sk),v67) : (void)0);
              n67 = n67->nxt;
            } while (n67 && (e67 = n67->obj) && h53 == n67->hash &&  EXT_PRICESTORE1ITEM2_mapkey1_idxfn::equals(se127, *e67)); 
          }
        }agg8.clear();
        
        {  // foreach
          const HashIndex_EXT_PRICESTORE1STORE_SALES3_map_01* i68 = static_cast<HashIndex_EXT_PRICESTORE1STORE_SALES3_map_01*>(EXT_PRICESTORE1STORE_SALES3.index[0]);
          HashIndex_EXT_PRICESTORE1STORE_SALES3_map_01::IdxNode* n68; 
          EXT_PRICESTORE1STORE_SALES3_entry* e68;
        
          for (size_t i = 0; i < i68->size_; i++)
          {
            n68 = i68->buckets_ + i;
            while (n68 && (e68 = n68->obj))
            {
                long ext_pricestore_salesstore_sales_ss_customer_sk = e68->EXT_PRICESTORE1STORE_SALESSTORE_SALES_SS_CUSTOMER_SK;
                STRING_TYPE customer_address_ca_zip = e68->CUSTOMER_ADDRESS_CA_ZIP;
                long v68 = e68->__av;
                (/*if */(Usubstring(customer_address_ca_zip, 1L, 5L) != Usubstring(store_s_zip, 1L, 5L)) ? agg8.addOrDelOnZero(st8.modify(ext_pricestore_salesstore_sales_ss_customer_sk,v68), v68) : (void)0);
              n68 = n68->nxt;
            }
          }
        }{  // temp foreach
          const HashIndex<tuple2_L_L, long>* i69 = static_cast<HashIndex<tuple2_L_L, long>*>(agg8.index[0]);
          HashIndex<tuple2_L_L, long>::IdxNode* n69; 
          tuple2_L_L* e69;
        
          for (size_t i = 0; i < i69->size_; i++)
          {
            n69 = i69->buckets_ + i;
            while (n69 && (e69 = n69->obj))
            {
              long ext_pricestore_salesstore_sales_ss_customer_sk = e69->_1;  
              long v69 = e69->__av; 
            EXT_PRICESTORE_SALES3.addOrDelOnZero(se128.modify(ext_pricestore_salesstore_sales_ss_customer_sk,store_s_store_sk),v69);      
              n69 = n69->nxt;
            }
          }
        }
      }
    }
    void on_system_ready_event() {
      {  
        EXT_PRICESTORE_SALES2.clear();
        long l1 = 1999L;
        long l2 = 11L;
        { //slice 
          const HashIndex_DATE_DIM_map_68* i70 = static_cast<HashIndex_DATE_DIM_map_68*>(DATE_DIM.index[1]);
          const HASH_RES_t h54 = DATE_DIM_mapkey68_idxfn::hash(se130.modify68(l1, l2));
          HashIndex_DATE_DIM_map_68::IdxNode* n70 = static_cast<HashIndex_DATE_DIM_map_68::IdxNode*>(i70->slice(se130, h54));
          DATE_DIM_entry* e70;
         
          if (n70 && (e70 = n70->obj)) {
            do {                
              long ext_pricestore_salesstore_sales_ss_sold_date_sk = e70->DATE_DIM_D_DATE_SK;
              STRING_TYPE date_dim_d_date_id = e70->DATE_DIM_D_DATE_ID;
              date date_dim_d_date = e70->DATE_DIM_D_DATE;
              long date_dim_d_month_seq = e70->DATE_DIM_D_MONTH_SEQ;
              long date_dim_d_week_seq = e70->DATE_DIM_D_WEEK_SEQ;
              long date_dim_d_quarter_seq = e70->DATE_DIM_D_QUARTER_SEQ;
              long date_dim_d_dow = e70->DATE_DIM_D_DOW;
              long date_dim_d_dom = e70->DATE_DIM_D_DOM;
              long date_dim_d_qoy = e70->DATE_DIM_D_QOY;
              long date_dim_d_fy_year = e70->DATE_DIM_D_FY_YEAR;
              long date_dim_d_fy_quarter_seq = e70->DATE_DIM_D_FY_QUARTER_SEQ;
              long date_dim_d_fy_week_seq = e70->DATE_DIM_D_FY_WEEK_SEQ;
              STRING_TYPE date_dim_d_day_name = e70->DATE_DIM_D_DAY_NAME;
              STRING_TYPE date_dim_d_quarter_name = e70->DATE_DIM_D_QUARTER_NAME;
              STRING_TYPE date_dim_d_holiday = e70->DATE_DIM_D_HOLIDAY;
              STRING_TYPE date_dim_d_weekend = e70->DATE_DIM_D_WEEKEND;
              STRING_TYPE date_dim_d_following_holiday = e70->DATE_DIM_D_FOLLOWING_HOLIDAY;
              long date_dim_d_first_dom = e70->DATE_DIM_D_FIRST_DOM;
              long date_dim_d_last_dom = e70->DATE_DIM_D_LAST_DOM;
              long date_dim_d_same_day_ly = e70->DATE_DIM_D_SAME_DAY_LY;
              long date_dim_d_same_day_lq = e70->DATE_DIM_D_SAME_DAY_LQ;
              STRING_TYPE date_dim_d_current_day = e70->DATE_DIM_D_CURRENT_DAY;
              STRING_TYPE date_dim_d_current_week = e70->DATE_DIM_D_CURRENT_WEEK;
              STRING_TYPE date_dim_d_current_month = e70->DATE_DIM_D_CURRENT_MONTH;
              STRING_TYPE date_dim_d_current_quarter = e70->DATE_DIM_D_CURRENT_QUARTER;
              STRING_TYPE date_dim_d_current_year = e70->DATE_DIM_D_CURRENT_YEAR;
              long v70 = e70->__av;
              EXT_PRICESTORE_SALES2.addOrDelOnZero(se129.modify(ext_pricestore_salesstore_sales_ss_sold_date_sk),v70);
              n70 = n70->nxt;
            } while (n70 && (e70 = n70->obj) && h54 == n70->hash &&  DATE_DIM_mapkey68_idxfn::equals(se130, *e70)); 
          }
        }
      }
    }
  
  private:
  
    /* Sample entries for avoiding recreation of temporary objects */
    EXT_PRICE_entry se1;
    EXT_PRICESTORE_SALES2_entry se2;
    EXT_PRICESTORE_SALES3_entry se3;
    EXT_PRICESTORE_SALES1_entry se4;
    EXT_PRICESTORE1_entry se5;
    EXT_PRICESTORE_SALES2_entry se6;
    EXT_PRICESTORE_SALES1_entry se7;
    EXT_PRICESTORE1STORE_SALES3_entry se8;
    EXT_PRICESTORE1CUSTOMER_ADDRESS1_entry se9;
    EXT_PRICESTORE_SALES2_entry se10;
    EXT_PRICESTORE1CUSTOMER_ADDRESS1STORE_SALES3_entry se11;
    EXT_PRICESTORE1CUSTOMER_ADDRESS1STORE_SALES2_entry se12;
    EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2_entry se13;
    EXT_PRICESTORE_SALES2_entry se14;
    EXT_PRICESTORE1CUSTOMER_ADDRESS1STORE_SALES3_entry se15;
    EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2CUSTOMER1_entry se16;
    EXT_PRICESTORE_SALES2_entry se17;
    EXT_PRICESTORE1CUSTOMER_ADDRESS1CUSTOMER1_entry se18;
    EXT_PRICESTORE_SALES2_entry se19;
    EXT_PRICESTORE_SALES1_entry se20;
    EXT_PRICESTORE1CUSTOMER1_entry se21;
    EXT_PRICESTORE_SALES2_entry se22;
    EXT_PRICESTORE1CUSTOMER_ADDRESS1STORE_SALES2_entry se23;
    EXT_PRICESTORE1ITEM2_entry se24;
    EXT_PRICESTORE_SALES2_entry se25;
    EXT_PRICESTORE1STORE_SALES3_entry se26;
    EXT_PRICECUSTOMER_ADDRESS1_entry se27;
    EXT_PRICESTORE_SALES2_entry se28;
    EXT_PRICESTORE_SALES1_entry se29;
    EXT_PRICESTORE1CUSTOMER_ADDRESS1STORE_SALES3_entry se30;
    EXT_PRICECUSTOMER_ADDRESS1STORE_SALES4_entry se31;
    EXT_PRICECUSTOMER_ADDRESS1ITEM2_entry se32;
    EXT_PRICESTORE_SALES2_entry se33;
    EXT_PRICECUSTOMER_ADDRESS1STORE_SALES4_entry se34;
    EXT_PRICESTORE1CUSTOMER_ADDRESS1STORE_SALES3_entry se35;
    EXT_PRICECUSTOMER_ADDRESS1ITEM2CUSTOMER1_entry se36;
    EXT_PRICESTORE_SALES2_entry se37;
    EXT_PRICECUSTOMER_ADDRESS1STORE_SALES4_entry se38;
    EXT_PRICECUSTOMER_ADDRESS1CUSTOMER1_entry se39;
    EXT_PRICESTORE_SALES2_entry se40;
    EXT_PRICESTORE_SALES1_entry se41;
    EXT_PRICECUSTOMER_ADDRESS1STORE_SALES4_entry se42;
    EXT_PRICECUSTOMER1_entry se43;
    EXT_PRICESTORE_SALES2_entry se44;
    EXT_PRICECUSTOMER1STORE_SALES3_entry se45;
    EXT_PRICESTORE1CUSTOMER_ADDRESS1STORE_SALES2_entry se46;
    EXT_PRICECUSTOMER1ITEM2_entry se47;
    EXT_PRICESTORE_SALES2_entry se48;
    EXT_PRICECUSTOMER1STORE_SALES3_entry se49;
    EXT_PRICEITEM2_entry se50;
    EXT_PRICESTORE_SALES2_entry se51;
    EXT_PRICESTORE_SALES3_entry se52;
    EXT_PRICE_entry se53;
    EXT_PRICEITEM2_entry se54;
    EXT_PRICESTORE1_entry se55;
    EXT_PRICESTORE1ITEM2_entry se56;
    EXT_PRICESTORE1CUSTOMER_ADDRESS1_entry se57;
    EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2_entry se58;
    EXT_PRICESTORE1CUSTOMER_ADDRESS1STORE_SALES2_entry se59;
    EXT_PRICESTORE1CUSTOMER_ADDRESS1CUSTOMER1_entry se60;
    EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2CUSTOMER1_entry se61;
    EXT_PRICESTORE1CUSTOMER1_entry se62;
    EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2CUSTOMER1_entry se63;
    EXT_PRICECUSTOMER_ADDRESS1_entry se64;
    EXT_PRICECUSTOMER_ADDRESS1ITEM2_entry se65;
    EXT_PRICECUSTOMER_ADDRESS1CUSTOMER1_entry se66;
    EXT_PRICECUSTOMER_ADDRESS1ITEM2CUSTOMER1_entry se67;
    EXT_PRICECUSTOMER1_entry se68;
    EXT_PRICECUSTOMER1ITEM2_entry se69;
    EXT_PRICESTORE_SALES1_entry se70;
    EXT_PRICE_entry se71;
    EXT_PRICECUSTOMER1_entry se72;
    EXT_PRICESTORE1_entry se73;
    EXT_PRICESTORE1CUSTOMER2_entry se74;
    EXT_PRICESTORE1CUSTOMER1_entry se75;
    EXT_PRICESTORE1CUSTOMER_ADDRESS1_entry se76;
    EXT_PRICESTORE1CUSTOMER_ADDRESS1CUSTOMER1_entry se77;
    EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2_entry se78;
    EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2CUSTOMER1_entry se79;
    EXT_PRICESTORE1CUSTOMER_ADDRESS1STORE_SALES3_entry se80;
    EXT_PRICESTORE1ITEM2_entry se81;
    EXT_PRICESTORE1CUSTOMER2_entry se82;
    EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2CUSTOMER1_entry se83;
    EXT_PRICESTORE1STORE_SALES3_entry se84;
    EXT_PRICESTORE1CUSTOMER2_entry se85;
    EXT_PRICECUSTOMER_ADDRESS1_entry se86;
    EXT_PRICECUSTOMER_ADDRESS1CUSTOMER1_entry se87;
    EXT_PRICECUSTOMER_ADDRESS1ITEM2_entry se88;
    EXT_PRICECUSTOMER_ADDRESS1ITEM2CUSTOMER1_entry se89;
    EXT_PRICEITEM2_entry se90;
    EXT_PRICECUSTOMER1ITEM2_entry se91;
    EXT_PRICESTORE_SALES3_entry se92;
    EXT_PRICECUSTOMER1STORE_SALES3_entry se93;
    EXT_PRICE_entry se94;
    EXT_PRICECUSTOMER_ADDRESS1_entry se95;
    EXT_PRICESTORE1_entry se96;
    EXT_PRICESTORE1CUSTOMER_ADDRESS1_entry se97;
    EXT_PRICESTORE1CUSTOMER2_entry se98;
    EXT_PRICESTORE1ITEM2_entry se99;
    EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2_entry se100;
    EXT_PRICESTORE1STORE_SALES3_entry se101;
    EXT_PRICESTORE1CUSTOMER_ADDRESS1STORE_SALES3_entry se102;
    EXT_PRICECUSTOMER1_entry se103;
    tuple6_LLSSL_D st1;
    EXT_PRICECUSTOMER1ITEM2_entry se104;
    tuple3_LL_D st2;
    EXT_PRICECUSTOMER1STORE_SALES3_entry se105;
    tuple2_L_L st3;
    EXT_PRICEITEM2_entry se106;
    EXT_PRICECUSTOMER_ADDRESS1ITEM2_entry se107;
    EXT_PRICESTORE_SALES3_entry se108;
    tuple2_L_L st4;
    EXT_PRICESTORE1CUSTOMER_ADDRESS1STORE_SALES3_entry se109;
    EXT_PRICE_entry se110;
    EXT_PRICESTORE1_entry se111;
    EXT_PRICECUSTOMER_ADDRESS1_entry se112;
    EXT_PRICESTORE1CUSTOMER_ADDRESS1_entry se113;
    EXT_PRICECUSTOMER_ADDRESS1ITEM2_entry se114;
    EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2_entry se115;
    EXT_PRICECUSTOMER_ADDRESS1ITEM2CUSTOMER1_entry se116;
    EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2CUSTOMER1_entry se117;
    EXT_PRICECUSTOMER_ADDRESS1STORE_SALES4_entry se118;
    EXT_PRICECUSTOMER_ADDRESS1CUSTOMER1_entry se119;
    EXT_PRICESTORE1CUSTOMER1_entry se120;
    EXT_PRICECUSTOMER1_entry se121;
    tuple2_L_L st5;
    EXT_PRICESTORE1CUSTOMER_ADDRESS1CUSTOMER1_entry se122;
    EXT_PRICECUSTOMER1ITEM2_entry se123;
    tuple2_L_L st6;
    EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2CUSTOMER1_entry se124;
    EXT_PRICECUSTOMER1STORE_SALES3_entry se125;
    tuple2_L_L st7;
    EXT_PRICEITEM2_entry se126;
    EXT_PRICESTORE1ITEM2_entry se127;
    EXT_PRICESTORE_SALES3_entry se128;
    tuple2_L_L st8;
    EXT_PRICESTORE_SALES2_entry se129;
    DATE_DIM_entry se130;
  
    /* Data structures used for storing materialized views */
    DATE_DIM_map DATE_DIM;
    EXT_PRICESTORE1_map EXT_PRICESTORE1;
    EXT_PRICESTORE1CUSTOMER_ADDRESS1_map EXT_PRICESTORE1CUSTOMER_ADDRESS1;
    EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2_map EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2;
    EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2CUSTOMER1_map EXT_PRICESTORE1CUSTOMER_ADDRESS1ITEM2CUSTOMER1;
    EXT_PRICESTORE1CUSTOMER_ADDRESS1STORE_SALES2_map EXT_PRICESTORE1CUSTOMER_ADDRESS1STORE_SALES2;
    EXT_PRICESTORE1CUSTOMER_ADDRESS1STORE_SALES3_map EXT_PRICESTORE1CUSTOMER_ADDRESS1STORE_SALES3;
    EXT_PRICESTORE1CUSTOMER_ADDRESS1CUSTOMER1_map EXT_PRICESTORE1CUSTOMER_ADDRESS1CUSTOMER1;
    EXT_PRICESTORE1CUSTOMER1_map EXT_PRICESTORE1CUSTOMER1;
    EXT_PRICESTORE1CUSTOMER2_map EXT_PRICESTORE1CUSTOMER2;
    EXT_PRICESTORE1ITEM2_map EXT_PRICESTORE1ITEM2;
    EXT_PRICESTORE1STORE_SALES3_map EXT_PRICESTORE1STORE_SALES3;
    EXT_PRICECUSTOMER_ADDRESS1_map EXT_PRICECUSTOMER_ADDRESS1;
    EXT_PRICECUSTOMER_ADDRESS1ITEM2_map EXT_PRICECUSTOMER_ADDRESS1ITEM2;
    EXT_PRICECUSTOMER_ADDRESS1ITEM2CUSTOMER1_map EXT_PRICECUSTOMER_ADDRESS1ITEM2CUSTOMER1;
    EXT_PRICECUSTOMER_ADDRESS1STORE_SALES4_map EXT_PRICECUSTOMER_ADDRESS1STORE_SALES4;
    EXT_PRICECUSTOMER_ADDRESS1CUSTOMER1_map EXT_PRICECUSTOMER_ADDRESS1CUSTOMER1;
    EXT_PRICECUSTOMER1_map EXT_PRICECUSTOMER1;
    EXT_PRICECUSTOMER1ITEM2_map EXT_PRICECUSTOMER1ITEM2;
    EXT_PRICECUSTOMER1STORE_SALES3_map EXT_PRICECUSTOMER1STORE_SALES3;
    EXT_PRICEITEM2_map EXT_PRICEITEM2;
    EXT_PRICESTORE_SALES1_map EXT_PRICESTORE_SALES1;
    EXT_PRICESTORE_SALES2_map EXT_PRICESTORE_SALES2;
    EXT_PRICESTORE_SALES3_map EXT_PRICESTORE_SALES3;
    MultiHashMap<tuple2_L_L,long,HashIndex<tuple2_L_L,long> > agg6;
    MultiHashMap<tuple2_L_L,long,HashIndex<tuple2_L_L,long> > agg8;
    MultiHashMap<tuple3_LL_D,DOUBLE_TYPE,HashIndex<tuple3_LL_D,DOUBLE_TYPE> > agg2;
    MultiHashMap<tuple2_L_L,long,HashIndex<tuple2_L_L,long> > agg5;
    MultiHashMap<tuple2_L_L,long,HashIndex<tuple2_L_L,long> > agg4;
    MultiHashMap<tuple2_L_L,long,HashIndex<tuple2_L_L,long> > agg7;
    MultiHashMap<tuple6_LLSSL_D,DOUBLE_TYPE,HashIndex<tuple6_LLSSL_D,DOUBLE_TYPE> > agg1;
    MultiHashMap<tuple2_L_L,long,HashIndex<tuple2_L_L,long> > agg3;
    
  
  };

}
