/* Generated by Purgatory 2014-2016 */

package ddbt.lib.store.deep

import ch.epfl.data.sc.pardis
import pardis.ir._
import pardis.types.PardisTypeImplicits._
import pardis.effects._
import pardis.deep._
import pardis.deep.scalalib._
import pardis.deep.scalalib.collection._
import pardis.deep.scalalib.io._

trait IdxOps extends Base  {  
  // Type representation
  val IdxType = IdxIRs.IdxType
  type IdxType[E <: ddbt.lib.store.Entry] = IdxIRs.IdxType[E]
  implicit def typeIdx[E <: ddbt.lib.store.Entry: TypeRep]: TypeRep[Idx[E]] = IdxType(implicitly[TypeRep[E]])
  implicit class IdxRep[E <: ddbt.lib.store.Entry](self : Rep[Idx[E]])(implicit typeE : TypeRep[E]) {
     def unsafeInsert(e : Rep[E]) : Rep[Unit] = idxUnsafeInsert[E](self, e)(typeE)
     def insert(e : Rep[E]) : Rep[Unit] = idxInsert[E](self, e)(typeE)
     def delete(e : Rep[E]) : Rep[Unit] = idxDelete[E](self, e)(typeE)
     def update(e : Rep[E]) : Rep[Unit] = idxUpdate[E](self, e)(typeE)
     def get(key : Rep[E]) : Rep[E] = idxGet[E](self, key)(typeE)
     def foreach(f : Rep[(E => Unit)]) : Rep[Unit] = idxForeach[E](self, f)(typeE)
     def slice(key : Rep[E], f : Rep[(E => Unit)]) : Rep[Unit] = idxSlice[E](self, key, f)(typeE)
  }
  object Idx {

  }
  // constructors

  // IR defs
  val IdxUnsafeInsert = IdxIRs.IdxUnsafeInsert
  type IdxUnsafeInsert[E <: ddbt.lib.store.Entry] = IdxIRs.IdxUnsafeInsert[E]
  val IdxInsert = IdxIRs.IdxInsert
  type IdxInsert[E <: ddbt.lib.store.Entry] = IdxIRs.IdxInsert[E]
  val IdxDelete = IdxIRs.IdxDelete
  type IdxDelete[E <: ddbt.lib.store.Entry] = IdxIRs.IdxDelete[E]
  val IdxUpdate = IdxIRs.IdxUpdate
  type IdxUpdate[E <: ddbt.lib.store.Entry] = IdxIRs.IdxUpdate[E]
  val IdxGet = IdxIRs.IdxGet
  type IdxGet[E <: ddbt.lib.store.Entry] = IdxIRs.IdxGet[E]
  val IdxForeach = IdxIRs.IdxForeach
  type IdxForeach[E <: ddbt.lib.store.Entry] = IdxIRs.IdxForeach[E]
  val IdxSlice = IdxIRs.IdxSlice
  type IdxSlice[E <: ddbt.lib.store.Entry] = IdxIRs.IdxSlice[E]
  // method definitions
   def idxUnsafeInsert[E <: ddbt.lib.store.Entry](self : Rep[Idx[E]], e : Rep[E])(implicit typeE : TypeRep[E]) : Rep[Unit] = IdxUnsafeInsert[E](self, e)
   def idxInsert[E <: ddbt.lib.store.Entry](self : Rep[Idx[E]], e : Rep[E])(implicit typeE : TypeRep[E]) : Rep[Unit] = IdxInsert[E](self, e)
   def idxDelete[E <: ddbt.lib.store.Entry](self : Rep[Idx[E]], e : Rep[E])(implicit typeE : TypeRep[E]) : Rep[Unit] = IdxDelete[E](self, e)
   def idxUpdate[E <: ddbt.lib.store.Entry](self : Rep[Idx[E]], e : Rep[E])(implicit typeE : TypeRep[E]) : Rep[Unit] = IdxUpdate[E](self, e)
   def idxGet[E <: ddbt.lib.store.Entry](self : Rep[Idx[E]], key : Rep[E])(implicit typeE : TypeRep[E]) : Rep[E] = IdxGet[E](self, key)
   def idxForeach[E <: ddbt.lib.store.Entry](self : Rep[Idx[E]], f : Rep[((E) => Unit)])(implicit typeE : TypeRep[E]) : Rep[Unit] = IdxForeach[E](self, f)
   def idxSlice[E <: ddbt.lib.store.Entry](self : Rep[Idx[E]], key : Rep[E], f : Rep[((E) => Unit)])(implicit typeE : TypeRep[E]) : Rep[Unit] = IdxSlice[E](self, key, f)
  type Idx[E <: ddbt.lib.store.Entry] = ddbt.lib.store.Idx[E]
}
object IdxIRs extends Base {
  // Type representation
  case class IdxType[E <: ddbt.lib.store.Entry](typeE: TypeRep[E]) extends TypeRep[Idx[E]] {
    def rebuild(newArguments: TypeRep[_]*): TypeRep[_] = IdxType(newArguments(0).asInstanceOf[TypeRep[_ <: ddbt.lib.store.Entry]])
    val name = s"Idx[${typeE.name}]"
    val typeArguments = List(typeE)
  }
      implicit def typeIdx[E <: ddbt.lib.store.Entry: TypeRep]: TypeRep[Idx[E]] = IdxType(implicitly[TypeRep[E]])
  // case classes
  case class IdxUnsafeInsert[E <: ddbt.lib.store.Entry](self : Rep[Idx[E]], e : Rep[E])(implicit val typeE : TypeRep[E]) extends FunctionDef[Unit](Some(self), "unsafeInsert", List(List(e))){
    override def curriedConstructor = (copy[E] _).curried
  }

  case class IdxInsert[E <: ddbt.lib.store.Entry](self : Rep[Idx[E]], e : Rep[E])(implicit val typeE : TypeRep[E]) extends FunctionDef[Unit](Some(self), "insert", List(List(e))){
    override def curriedConstructor = (copy[E] _).curried
  }

  case class IdxDelete[E <: ddbt.lib.store.Entry](self : Rep[Idx[E]], e : Rep[E])(implicit val typeE : TypeRep[E]) extends FunctionDef[Unit](Some(self), "delete", List(List(e))){
    override def curriedConstructor = (copy[E] _).curried
  }

  case class IdxUpdate[E <: ddbt.lib.store.Entry](self : Rep[Idx[E]], e : Rep[E])(implicit val typeE : TypeRep[E]) extends FunctionDef[Unit](Some(self), "update", List(List(e))){
    override def curriedConstructor = (copy[E] _).curried
  }

  case class IdxGet[E <: ddbt.lib.store.Entry](self : Rep[Idx[E]], key : Rep[E])(implicit val typeE : TypeRep[E]) extends FunctionDef[E](Some(self), "get", List(List(key))){
    override def curriedConstructor = (copy[E] _).curried
    override def effect = Read(self)
  }

  case class IdxForeach[E <: ddbt.lib.store.Entry](self : Rep[Idx[E]], f : Rep[((E) => Unit)])(implicit val typeE : TypeRep[E]) extends FunctionDef[Unit](Some(self), "foreach", List(List(f))){
    override def curriedConstructor = (copy[E] _).curried
  }

  case class IdxSlice[E <: ddbt.lib.store.Entry](self : Rep[Idx[E]], key : Rep[E], f : Rep[((E) => Unit)])(implicit val typeE : TypeRep[E]) extends FunctionDef[Unit](Some(self), "slice", List(List(key,f))){
    override def curriedConstructor = (copy[E] _).curried
  }

  type Idx[E <: ddbt.lib.store.Entry] = ddbt.lib.store.Idx[E]
}
trait IdxImplicits extends IdxOps { 
  // Add implicit conversions here!
}
trait IdxComponent extends IdxOps with IdxImplicits {  }

trait IdxPartialEvaluation extends IdxComponent with BasePartialEvaluation {  
  // Immutable field inlining 

  // Mutable field inlining 
  // Pure function partial evaluation
}


