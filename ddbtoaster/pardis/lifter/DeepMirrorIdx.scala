/* Generated by Purgatory 2014-2017 */

package ddbt.lib.store.deep

import ch.epfl.data.sc.pardis
import pardis.ir._
import pardis.types.PardisTypeImplicits._
import pardis.effects._
import pardis.deep._
import pardis.deep.scalalib._
import pardis.deep.scalalib.collection._
import pardis.deep.scalalib.io._

trait IdxOps extends Base with MultiResOps {  
  // Type representation
  val IdxType = IdxIRs.IdxType
  type IdxType[E <: ddbt.lib.store.Entry] = IdxIRs.IdxType[E]
  implicit def typeIdx[E <: ddbt.lib.store.Entry: TypeRep]: TypeRep[Idx[E]] = IdxType(implicitly[TypeRep[E]])
  implicit class IdxRep[E <: ddbt.lib.store.Entry](self : Rep[Idx[E]])(implicit typeE : TypeRep[E]) {
     def unsafeInsert(e : Rep[E]) : Rep[Unit] = idxUnsafeInsert[E](self, e)(typeE)
     def insert(e : Rep[E]) : Rep[Unit] = idxInsert[E](self, e)(typeE)
     def delete(e : Rep[E]) : Rep[Unit] = idxDelete[E](self, e)(typeE)
     def deleteCopy(e : Rep[E], primary : Rep[Idx[E]]) : Rep[Unit] = idxDeleteCopy[E](self, e, primary)(typeE)
     def deleteCopyDependent(e : Rep[E]) : Rep[Unit] = idxDeleteCopyDependent[E](self, e)(typeE)
     def update(e : Rep[E]) : Rep[Unit] = idxUpdate[E](self, e)(typeE)
     def updateCopyDependent(e : Rep[E], ref : Rep[E]) : Rep[Unit] = idxUpdateCopyDependent[E](self, e, ref)(typeE)
     def updateCopy(e : Rep[E], primary : Rep[Idx[E]]) : Rep[Unit] = idxUpdateCopy[E](self, e, primary)(typeE)
     def get(key : Rep[E]) : Rep[E] = idxGet[E](self, key)(typeE)
     def getCopy(key : Rep[E]) : Rep[E] = idxGetCopy[E](self, key)(typeE)
     def getCopyDependent(key : Rep[E]) : Rep[E] = idxGetCopyDependent[E](self, key)(typeE)
     def foreach(f : Rep[(E => Unit)]) : Rep[Unit] = idxForeach[E](self, f)(typeE)
     def foreachRes() : Rep[MultiRes] = idxForeachRes[E](self)(typeE)
     def foreachResMap(f : Rep[(E => Unit)], res : Rep[MultiRes]) : Rep[Unit] = idxForeachResMap[E](self, f, res)(typeE)
     def sliceNoUpdate(key : Rep[E], f : Rep[(E => Unit)]) : Rep[Unit] = idxSliceNoUpdate[E](self, key, f)(typeE)
     def slice(key : Rep[E], f : Rep[(E => Unit)]) : Rep[Unit] = idxSlice[E](self, key, f)(typeE)
     def sliceRes(key : Rep[E]) : Rep[MultiRes] = idxSliceRes[E](self, key)(typeE)
     def sliceResMap(key : Rep[E], f : Rep[(E => Unit)], res : Rep[MultiRes]) : Rep[Unit] = idxSliceResMap[E](self, key, f, res)(typeE)
     def sliceResMapNoUpd(key : Rep[E], f : Rep[(E => Unit)], res : Rep[MultiRes]) : Rep[Unit] = idxSliceResMapNoUpd[E](self, key, f, res)(typeE)
     def sliceCopy(key : Rep[E], f : Rep[(E => Unit)]) : Rep[Unit] = idxSliceCopy[E](self, key, f)(typeE)
     def sliceCopyDependent(key : Rep[E], f : Rep[(E => Unit)]) : Rep[Unit] = idxSliceCopyDependent[E](self, key, f)(typeE)
     def clear() : Rep[Unit] = idxClear[E](self)(typeE)
  }
  object Idx {

  }
  // constructors

  // IR defs
  val IdxUnsafeInsert = IdxIRs.IdxUnsafeInsert
  type IdxUnsafeInsert[E <: ddbt.lib.store.Entry] = IdxIRs.IdxUnsafeInsert[E]
  val IdxInsert = IdxIRs.IdxInsert
  type IdxInsert[E <: ddbt.lib.store.Entry] = IdxIRs.IdxInsert[E]
  val IdxDelete = IdxIRs.IdxDelete
  type IdxDelete[E <: ddbt.lib.store.Entry] = IdxIRs.IdxDelete[E]
  val IdxDeleteCopy = IdxIRs.IdxDeleteCopy
  type IdxDeleteCopy[E <: ddbt.lib.store.Entry] = IdxIRs.IdxDeleteCopy[E]
  val IdxDeleteCopyDependent = IdxIRs.IdxDeleteCopyDependent
  type IdxDeleteCopyDependent[E <: ddbt.lib.store.Entry] = IdxIRs.IdxDeleteCopyDependent[E]
  val IdxUpdate = IdxIRs.IdxUpdate
  type IdxUpdate[E <: ddbt.lib.store.Entry] = IdxIRs.IdxUpdate[E]
  val IdxUpdateCopyDependent = IdxIRs.IdxUpdateCopyDependent
  type IdxUpdateCopyDependent[E <: ddbt.lib.store.Entry] = IdxIRs.IdxUpdateCopyDependent[E]
  val IdxUpdateCopy = IdxIRs.IdxUpdateCopy
  type IdxUpdateCopy[E <: ddbt.lib.store.Entry] = IdxIRs.IdxUpdateCopy[E]
  val IdxGet = IdxIRs.IdxGet
  type IdxGet[E <: ddbt.lib.store.Entry] = IdxIRs.IdxGet[E]
  val IdxGetCopy = IdxIRs.IdxGetCopy
  type IdxGetCopy[E <: ddbt.lib.store.Entry] = IdxIRs.IdxGetCopy[E]
  val IdxGetCopyDependent = IdxIRs.IdxGetCopyDependent
  type IdxGetCopyDependent[E <: ddbt.lib.store.Entry] = IdxIRs.IdxGetCopyDependent[E]
  val IdxForeach = IdxIRs.IdxForeach
  type IdxForeach[E <: ddbt.lib.store.Entry] = IdxIRs.IdxForeach[E]
  val IdxForeachRes = IdxIRs.IdxForeachRes
  type IdxForeachRes[E <: ddbt.lib.store.Entry] = IdxIRs.IdxForeachRes[E]
  val IdxForeachResMap = IdxIRs.IdxForeachResMap
  type IdxForeachResMap[E <: ddbt.lib.store.Entry] = IdxIRs.IdxForeachResMap[E]
  val IdxSliceNoUpdate = IdxIRs.IdxSliceNoUpdate
  type IdxSliceNoUpdate[E <: ddbt.lib.store.Entry] = IdxIRs.IdxSliceNoUpdate[E]
  val IdxSlice = IdxIRs.IdxSlice
  type IdxSlice[E <: ddbt.lib.store.Entry] = IdxIRs.IdxSlice[E]
  val IdxSliceRes = IdxIRs.IdxSliceRes
  type IdxSliceRes[E <: ddbt.lib.store.Entry] = IdxIRs.IdxSliceRes[E]
  val IdxSliceResMap = IdxIRs.IdxSliceResMap
  type IdxSliceResMap[E <: ddbt.lib.store.Entry] = IdxIRs.IdxSliceResMap[E]
  val IdxSliceResMapNoUpd = IdxIRs.IdxSliceResMapNoUpd
  type IdxSliceResMapNoUpd[E <: ddbt.lib.store.Entry] = IdxIRs.IdxSliceResMapNoUpd[E]
  val IdxSliceCopy = IdxIRs.IdxSliceCopy
  type IdxSliceCopy[E <: ddbt.lib.store.Entry] = IdxIRs.IdxSliceCopy[E]
  val IdxSliceCopyDependent = IdxIRs.IdxSliceCopyDependent
  type IdxSliceCopyDependent[E <: ddbt.lib.store.Entry] = IdxIRs.IdxSliceCopyDependent[E]
  val IdxClear = IdxIRs.IdxClear
  type IdxClear[E <: ddbt.lib.store.Entry] = IdxIRs.IdxClear[E]
  // method definitions
   def idxUnsafeInsert[E <: ddbt.lib.store.Entry](self : Rep[Idx[E]], e : Rep[E])(implicit typeE : TypeRep[E]) : Rep[Unit] = IdxUnsafeInsert[E](self, e)
   def idxInsert[E <: ddbt.lib.store.Entry](self : Rep[Idx[E]], e : Rep[E])(implicit typeE : TypeRep[E]) : Rep[Unit] = IdxInsert[E](self, e)
   def idxDelete[E <: ddbt.lib.store.Entry](self : Rep[Idx[E]], e : Rep[E])(implicit typeE : TypeRep[E]) : Rep[Unit] = IdxDelete[E](self, e)
   def idxDeleteCopy[E <: ddbt.lib.store.Entry](self : Rep[Idx[E]], e : Rep[E], primary : Rep[Idx[E]])(implicit typeE : TypeRep[E]) : Rep[Unit] = IdxDeleteCopy[E](self, e, primary)
   def idxDeleteCopyDependent[E <: ddbt.lib.store.Entry](self : Rep[Idx[E]], e : Rep[E])(implicit typeE : TypeRep[E]) : Rep[Unit] = IdxDeleteCopyDependent[E](self, e)
   def idxUpdate[E <: ddbt.lib.store.Entry](self : Rep[Idx[E]], e : Rep[E])(implicit typeE : TypeRep[E]) : Rep[Unit] = IdxUpdate[E](self, e)
   def idxUpdateCopyDependent[E <: ddbt.lib.store.Entry](self : Rep[Idx[E]], e : Rep[E], ref : Rep[E])(implicit typeE : TypeRep[E]) : Rep[Unit] = IdxUpdateCopyDependent[E](self, e, ref)
   def idxUpdateCopy[E <: ddbt.lib.store.Entry](self : Rep[Idx[E]], e : Rep[E], primary : Rep[Idx[E]])(implicit typeE : TypeRep[E]) : Rep[Unit] = IdxUpdateCopy[E](self, e, primary)
   def idxGet[E <: ddbt.lib.store.Entry](self : Rep[Idx[E]], key : Rep[E])(implicit typeE : TypeRep[E]) : Rep[E] = IdxGet[E](self, key)
   def idxGetCopy[E <: ddbt.lib.store.Entry](self : Rep[Idx[E]], key : Rep[E])(implicit typeE : TypeRep[E]) : Rep[E] = IdxGetCopy[E](self, key)
   def idxGetCopyDependent[E <: ddbt.lib.store.Entry](self : Rep[Idx[E]], key : Rep[E])(implicit typeE : TypeRep[E]) : Rep[E] = IdxGetCopyDependent[E](self, key)
   def idxForeach[E <: ddbt.lib.store.Entry](self : Rep[Idx[E]], f : Rep[((E) => Unit)])(implicit typeE : TypeRep[E]) : Rep[Unit] = IdxForeach[E](self, f)
   def idxForeachRes[E <: ddbt.lib.store.Entry](self : Rep[Idx[E]])(implicit typeE : TypeRep[E]) : Rep[MultiRes] = IdxForeachRes[E](self)
   def idxForeachResMap[E <: ddbt.lib.store.Entry](self : Rep[Idx[E]], f : Rep[((E) => Unit)], res : Rep[MultiRes])(implicit typeE : TypeRep[E]) : Rep[Unit] = IdxForeachResMap[E](self, f, res)
   def idxSliceNoUpdate[E <: ddbt.lib.store.Entry](self : Rep[Idx[E]], key : Rep[E], f : Rep[((E) => Unit)])(implicit typeE : TypeRep[E]) : Rep[Unit] = IdxSliceNoUpdate[E](self, key, f)
   def idxSlice[E <: ddbt.lib.store.Entry](self : Rep[Idx[E]], key : Rep[E], f : Rep[((E) => Unit)])(implicit typeE : TypeRep[E]) : Rep[Unit] = IdxSlice[E](self, key, f)
   def idxSliceRes[E <: ddbt.lib.store.Entry](self : Rep[Idx[E]], key : Rep[E])(implicit typeE : TypeRep[E]) : Rep[MultiRes] = IdxSliceRes[E](self, key)
   def idxSliceResMap[E <: ddbt.lib.store.Entry](self : Rep[Idx[E]], key : Rep[E], f : Rep[((E) => Unit)], res : Rep[MultiRes])(implicit typeE : TypeRep[E]) : Rep[Unit] = IdxSliceResMap[E](self, key, f, res)
   def idxSliceResMapNoUpd[E <: ddbt.lib.store.Entry](self : Rep[Idx[E]], key : Rep[E], f : Rep[((E) => Unit)], res : Rep[MultiRes])(implicit typeE : TypeRep[E]) : Rep[Unit] = IdxSliceResMapNoUpd[E](self, key, f, res)
   def idxSliceCopy[E <: ddbt.lib.store.Entry](self : Rep[Idx[E]], key : Rep[E], f : Rep[((E) => Unit)])(implicit typeE : TypeRep[E]) : Rep[Unit] = IdxSliceCopy[E](self, key, f)
   def idxSliceCopyDependent[E <: ddbt.lib.store.Entry](self : Rep[Idx[E]], key : Rep[E], f : Rep[((E) => Unit)])(implicit typeE : TypeRep[E]) : Rep[Unit] = IdxSliceCopyDependent[E](self, key, f)
   def idxClear[E <: ddbt.lib.store.Entry](self : Rep[Idx[E]])(implicit typeE : TypeRep[E]) : Rep[Unit] = IdxClear[E](self)
  type Idx[E <: ddbt.lib.store.Entry] = ddbt.lib.store.Idx[E]
}
object IdxIRs extends Base {
  import MultiResIRs._
  // Type representation
  case class IdxType[E <: ddbt.lib.store.Entry](typeE: TypeRep[E]) extends TypeRep[Idx[E]] {
    def rebuild(newArguments: TypeRep[_]*): TypeRep[_] = IdxType(newArguments(0).asInstanceOf[TypeRep[_ <: ddbt.lib.store.Entry]])
    val name = s"Idx[${typeE.name}]"
    val typeArguments = List(typeE)
  }
      implicit def typeIdx[E <: ddbt.lib.store.Entry: TypeRep]: TypeRep[Idx[E]] = IdxType(implicitly[TypeRep[E]])
  // case classes
  case class IdxUnsafeInsert[E <: ddbt.lib.store.Entry](self : Rep[Idx[E]], e : Rep[E])(implicit val typeE : TypeRep[E]) extends FunctionDef[Unit](Some(self), "unsafeInsert", List(List(e))){
    override def curriedConstructor = (copy[E] _).curried
  }

  case class IdxInsert[E <: ddbt.lib.store.Entry](self : Rep[Idx[E]], e : Rep[E])(implicit val typeE : TypeRep[E]) extends FunctionDef[Unit](Some(self), "insert", List(List(e))){
    override def curriedConstructor = (copy[E] _).curried
  }

  case class IdxDelete[E <: ddbt.lib.store.Entry](self : Rep[Idx[E]], e : Rep[E])(implicit val typeE : TypeRep[E]) extends FunctionDef[Unit](Some(self), "delete", List(List(e))){
    override def curriedConstructor = (copy[E] _).curried
  }

  case class IdxDeleteCopy[E <: ddbt.lib.store.Entry](self : Rep[Idx[E]], e : Rep[E], primary : Rep[Idx[E]])(implicit val typeE : TypeRep[E]) extends FunctionDef[Unit](Some(self), "deleteCopy", List(List(e,primary))){
    override def curriedConstructor = (copy[E] _).curried
  }

  case class IdxDeleteCopyDependent[E <: ddbt.lib.store.Entry](self : Rep[Idx[E]], e : Rep[E])(implicit val typeE : TypeRep[E]) extends FunctionDef[Unit](Some(self), "deleteCopyDependent", List(List(e))){
    override def curriedConstructor = (copy[E] _).curried
  }

  case class IdxUpdate[E <: ddbt.lib.store.Entry](self : Rep[Idx[E]], e : Rep[E])(implicit val typeE : TypeRep[E]) extends FunctionDef[Unit](Some(self), "update", List(List(e))){
    override def curriedConstructor = (copy[E] _).curried
  }

  case class IdxUpdateCopyDependent[E <: ddbt.lib.store.Entry](self : Rep[Idx[E]], e : Rep[E], ref : Rep[E])(implicit val typeE : TypeRep[E]) extends FunctionDef[Unit](Some(self), "updateCopyDependent", List(List(e,ref))){
    override def curriedConstructor = (copy[E] _).curried
  }

  case class IdxUpdateCopy[E <: ddbt.lib.store.Entry](self : Rep[Idx[E]], e : Rep[E], primary : Rep[Idx[E]])(implicit val typeE : TypeRep[E]) extends FunctionDef[Unit](Some(self), "updateCopy", List(List(e,primary))){
    override def curriedConstructor = (copy[E] _).curried
  }

  case class IdxGet[E <: ddbt.lib.store.Entry](self : Rep[Idx[E]], key : Rep[E])(implicit val typeE : TypeRep[E]) extends FunctionDef[E](Some(self), "get", List(List(key))){
    override def curriedConstructor = (copy[E] _).curried
    override def effect = Read(self)
  }

  case class IdxGetCopy[E <: ddbt.lib.store.Entry](self : Rep[Idx[E]], key : Rep[E])(implicit val typeE : TypeRep[E]) extends FunctionDef[E](Some(self), "getCopy", List(List(key))){
    override def curriedConstructor = (copy[E] _).curried
    override def effect = Read(self)
  }

  case class IdxGetCopyDependent[E <: ddbt.lib.store.Entry](self : Rep[Idx[E]], key : Rep[E])(implicit val typeE : TypeRep[E]) extends FunctionDef[E](Some(self), "getCopyDependent", List(List(key))){
    override def curriedConstructor = (copy[E] _).curried
    override def effect = Read(self)
  }

  case class IdxForeach[E <: ddbt.lib.store.Entry](self : Rep[Idx[E]], f : Rep[((E) => Unit)])(implicit val typeE : TypeRep[E]) extends FunctionDef[Unit](Some(self), "foreach", List(List(f))){
    override def curriedConstructor = (copy[E] _).curried
  }

  case class IdxForeachRes[E <: ddbt.lib.store.Entry](self : Rep[Idx[E]])(implicit val typeE : TypeRep[E]) extends FunctionDef[MultiRes](Some(self), "foreachRes", List(List())){
    override def curriedConstructor = (copy[E] _)
  }

  case class IdxForeachResMap[E <: ddbt.lib.store.Entry](self : Rep[Idx[E]], f : Rep[((E) => Unit)], res : Rep[MultiRes])(implicit val typeE : TypeRep[E]) extends FunctionDef[Unit](Some(self), "foreachResMap", List(List(f,res))){
    override def curriedConstructor = (copy[E] _).curried
  }

  case class IdxSliceNoUpdate[E <: ddbt.lib.store.Entry](self : Rep[Idx[E]], key : Rep[E], f : Rep[((E) => Unit)])(implicit val typeE : TypeRep[E]) extends FunctionDef[Unit](Some(self), "sliceNoUpdate", List(List(key,f))){
    override def curriedConstructor = (copy[E] _).curried
  }

  case class IdxSlice[E <: ddbt.lib.store.Entry](self : Rep[Idx[E]], key : Rep[E], f : Rep[((E) => Unit)])(implicit val typeE : TypeRep[E]) extends FunctionDef[Unit](Some(self), "slice", List(List(key,f))){
    override def curriedConstructor = (copy[E] _).curried
  }

  case class IdxSliceRes[E <: ddbt.lib.store.Entry](self : Rep[Idx[E]], key : Rep[E])(implicit val typeE : TypeRep[E]) extends FunctionDef[MultiRes](Some(self), "sliceRes", List(List(key))){
    override def curriedConstructor = (copy[E] _).curried
  }

  case class IdxSliceResMap[E <: ddbt.lib.store.Entry](self : Rep[Idx[E]], key : Rep[E], f : Rep[((E) => Unit)], res : Rep[MultiRes])(implicit val typeE : TypeRep[E]) extends FunctionDef[Unit](Some(self), "sliceResMap", List(List(key,f,res))){
    override def curriedConstructor = (copy[E] _).curried
  }

  case class IdxSliceResMapNoUpd[E <: ddbt.lib.store.Entry](self : Rep[Idx[E]], key : Rep[E], f : Rep[((E) => Unit)], res : Rep[MultiRes])(implicit val typeE : TypeRep[E]) extends FunctionDef[Unit](Some(self), "sliceResMapNoUpd", List(List(key,f,res))){
    override def curriedConstructor = (copy[E] _).curried
  }

  case class IdxSliceCopy[E <: ddbt.lib.store.Entry](self : Rep[Idx[E]], key : Rep[E], f : Rep[((E) => Unit)])(implicit val typeE : TypeRep[E]) extends FunctionDef[Unit](Some(self), "sliceCopy", List(List(key,f))){
    override def curriedConstructor = (copy[E] _).curried
  }

  case class IdxSliceCopyDependent[E <: ddbt.lib.store.Entry](self : Rep[Idx[E]], key : Rep[E], f : Rep[((E) => Unit)])(implicit val typeE : TypeRep[E]) extends FunctionDef[Unit](Some(self), "sliceCopyDependent", List(List(key,f))){
    override def curriedConstructor = (copy[E] _).curried
  }

  case class IdxClear[E <: ddbt.lib.store.Entry](self : Rep[Idx[E]])(implicit val typeE : TypeRep[E]) extends FunctionDef[Unit](Some(self), "clear", List(List())){
    override def curriedConstructor = (copy[E] _)
  }

  type Idx[E <: ddbt.lib.store.Entry] = ddbt.lib.store.Idx[E]
}
trait IdxImplicits extends IdxOps { 
  // Add implicit conversions here!
}
trait IdxComponent extends IdxOps with IdxImplicits {  }

trait IdxPartialEvaluation extends IdxComponent with BasePartialEvaluation {  
  // Immutable field inlining 

  // Mutable field inlining 
  // Pure function partial evaluation
}


