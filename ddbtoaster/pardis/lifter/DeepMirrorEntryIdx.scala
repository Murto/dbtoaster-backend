/* Generated by Purgatory 2014-2016 */

package ddbt.lib.store.deep

import ch.epfl.data.sc.pardis
import pardis.ir._
import pardis.types.PardisTypeImplicits._
import pardis.effects._
import pardis.deep._
import pardis.deep.scalalib._
import pardis.deep.scalalib.collection._
import pardis.deep.scalalib.io._

trait MirrorEntryIdxOps extends Base  {  
  // Type representation
  val MirrorEntryIdxType = MirrorEntryIdxIRs.MirrorEntryIdxType
  type MirrorEntryIdxType[E] = MirrorEntryIdxIRs.MirrorEntryIdxType[E]
  implicit def typeMirrorEntryIdx[E: TypeRep]: TypeRep[MirrorEntryIdx[E]] = MirrorEntryIdxType(implicitly[TypeRep[E]])
  implicit class MirrorEntryIdxRep[E](self : Rep[MirrorEntryIdx[E]])(implicit typeE : TypeRep[E]) {
     def cmp(e1 : Rep[E], e2 : Rep[E]) : Rep[Int] = mirrorEntryIdxCmp[E](self, e1, e2)(typeE)
     def hash(e : Rep[E]) : Rep[Int] = mirrorEntryIdxHash[E](self, e)(typeE)
  }
  object MirrorEntryIdx {
     def apply[E](h : Rep[(E => Int)], c : Rep[((E,E) => Int)])(implicit typeE : TypeRep[E]) : Rep[MirrorEntryIdx[E]] = mirrorEntryIdxApplyObject[E](h, c)(typeE)
  }
  // constructors

  // IR defs
  val MirrorEntryIdxCmp = MirrorEntryIdxIRs.MirrorEntryIdxCmp
  type MirrorEntryIdxCmp[E] = MirrorEntryIdxIRs.MirrorEntryIdxCmp[E]
  val MirrorEntryIdxHash = MirrorEntryIdxIRs.MirrorEntryIdxHash
  type MirrorEntryIdxHash[E] = MirrorEntryIdxIRs.MirrorEntryIdxHash[E]
  val MirrorEntryIdxApplyObject = MirrorEntryIdxIRs.MirrorEntryIdxApplyObject
  type MirrorEntryIdxApplyObject[E] = MirrorEntryIdxIRs.MirrorEntryIdxApplyObject[E]
  // method definitions
   def mirrorEntryIdxCmp[E](self : Rep[MirrorEntryIdx[E]], e1 : Rep[E], e2 : Rep[E])(implicit typeE : TypeRep[E]) : Rep[Int] = MirrorEntryIdxCmp[E](self, e1, e2)
   def mirrorEntryIdxHash[E](self : Rep[MirrorEntryIdx[E]], e : Rep[E])(implicit typeE : TypeRep[E]) : Rep[Int] = MirrorEntryIdxHash[E](self, e)
   def mirrorEntryIdxApplyObject[E](h : Rep[(E => Int)], c : Rep[((E,E) => Int)])(implicit typeE : TypeRep[E]) : Rep[MirrorEntryIdx[E]] = MirrorEntryIdxApplyObject[E](h, c)
  type MirrorEntryIdx[E] = ddbt.lib.store.MirrorEntryIdx[E]
}
object MirrorEntryIdxIRs extends Base {
  // Type representation
  case class MirrorEntryIdxType[E](typeE: TypeRep[E]) extends TypeRep[MirrorEntryIdx[E]] {
    def rebuild(newArguments: TypeRep[_]*): TypeRep[_] = MirrorEntryIdxType(newArguments(0).asInstanceOf[TypeRep[_]])
    val name = s"MirrorEntryIdx[${typeE.name}]"
    val typeArguments = List(typeE)
  }
      implicit def typeMirrorEntryIdx[E: TypeRep]: TypeRep[MirrorEntryIdx[E]] = MirrorEntryIdxType(implicitly[TypeRep[E]])
  // case classes
  case class MirrorEntryIdxCmp[E](self : Rep[MirrorEntryIdx[E]], e1 : Rep[E], e2 : Rep[E])(implicit val typeE : TypeRep[E]) extends FunctionDef[Int](Some(self), "cmp", List(List(e1,e2))){
    override def curriedConstructor = (copy[E] _).curried
  }

  case class MirrorEntryIdxHash[E](self : Rep[MirrorEntryIdx[E]], e : Rep[E])(implicit val typeE : TypeRep[E]) extends FunctionDef[Int](Some(self), "hash", List(List(e))){
    override def curriedConstructor = (copy[E] _).curried
  }

  case class MirrorEntryIdxApplyObject[E](h : Rep[(E => Int)], c : Rep[((E,E) => Int)])(implicit val typeE : TypeRep[E]) extends FunctionDef[MirrorEntryIdx[E]](None, "MirrorEntryIdx.apply", List(List(h,c))){
    override def curriedConstructor = (copy[E] _).curried
  }

  type MirrorEntryIdx[E] = ddbt.lib.store.MirrorEntryIdx[E]
}
trait MirrorEntryIdxImplicits extends MirrorEntryIdxOps { 
  // Add implicit conversions here!
}
trait MirrorEntryIdxComponent extends MirrorEntryIdxOps with MirrorEntryIdxImplicits {  }

trait MirrorEntryIdxPartialEvaluation extends MirrorEntryIdxComponent with BasePartialEvaluation {  
  // Immutable field inlining 

  // Mutable field inlining 
  // Pure function partial evaluation
}


