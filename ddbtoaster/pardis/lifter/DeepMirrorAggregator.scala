/* Generated by Purgatory 2014-2016 */

package ddbt.lib.store.deep

import ch.epfl.data.sc.pardis
import pardis.ir._
import pardis.types.PardisTypeImplicits._
import pardis.effects._
import pardis.deep._
import pardis.deep.scalalib._
import pardis.deep.scalalib.collection._
import pardis.deep.scalalib.io._

trait AggregatorOps extends Base  {  
  // Type representation
  val AggregatorType = AggregatorIRs.AggregatorType
  type AggregatorType[E <: ddbt.lib.store.Entry] = AggregatorIRs.AggregatorType[E]
  implicit def typeAggregator[E <: ddbt.lib.store.Entry: TypeRep]: TypeRep[Aggregator[E]] = AggregatorType(implicitly[TypeRep[E]])
  implicit class AggregatorRep[E <: ddbt.lib.store.Entry](self : Rep[Aggregator[E]])(implicit typeE : TypeRep[E]) {
     def apply(e : Rep[E]) : Rep[Unit] = aggregatorApply[E](self, e)(typeE)
     def result : Rep[E] = aggregatorResult[E](self)(typeE)
     def compose[A](g : Rep[(A => E)])(implicit typeA : TypeRep[A]) : Rep[(A => Unit)] = aggregatorCompose[E, A](self, g)(typeE, typeA)
     def andThen[A](g : Rep[(Unit => A)])(implicit typeA : TypeRep[A]) : Rep[(E => A)] = aggregatorAndThen[E, A](self, g)(typeE, typeA)
  }
  object Aggregator {
     def min[E <: ddbt.lib.store.Entry, R](f : Rep[(E => R)])(implicit typeE : TypeRep[E], typeR : TypeRep[R], order : Ordering[R]) : Rep[Aggregator[E]] = aggregatorMinObject[E, R](f)(typeE, typeR, order)
     def max[E <: ddbt.lib.store.Entry, R](f : Rep[(E => R)])(implicit typeE : TypeRep[E], typeR : TypeRep[R], order : Ordering[R]) : Rep[Aggregator[E]] = aggregatorMaxObject[E, R](f)(typeE, typeR, order)
  }
  // constructors

  // IR defs
  val AggregatorApply = AggregatorIRs.AggregatorApply
  type AggregatorApply[E <: ddbt.lib.store.Entry] = AggregatorIRs.AggregatorApply[E]
  val AggregatorResult = AggregatorIRs.AggregatorResult
  type AggregatorResult[E <: ddbt.lib.store.Entry] = AggregatorIRs.AggregatorResult[E]
  val AggregatorCompose = AggregatorIRs.AggregatorCompose
  type AggregatorCompose[E <: ddbt.lib.store.Entry, A] = AggregatorIRs.AggregatorCompose[E, A]
  val AggregatorAndThen = AggregatorIRs.AggregatorAndThen
  type AggregatorAndThen[E <: ddbt.lib.store.Entry, A] = AggregatorIRs.AggregatorAndThen[E, A]
  val AggregatorMinObject = AggregatorIRs.AggregatorMinObject
  type AggregatorMinObject[E <: ddbt.lib.store.Entry, R] = AggregatorIRs.AggregatorMinObject[E, R]
  val AggregatorMaxObject = AggregatorIRs.AggregatorMaxObject
  type AggregatorMaxObject[E <: ddbt.lib.store.Entry, R] = AggregatorIRs.AggregatorMaxObject[E, R]
  // method definitions
   def aggregatorApply[E <: ddbt.lib.store.Entry](self : Rep[Aggregator[E]], e : Rep[E])(implicit typeE : TypeRep[E]) : Rep[Unit] = AggregatorApply[E](self, e)
   def aggregatorResult[E <: ddbt.lib.store.Entry](self : Rep[Aggregator[E]])(implicit typeE : TypeRep[E]) : Rep[E] = AggregatorResult[E](self)
   def aggregatorCompose[E <: ddbt.lib.store.Entry, A](self : Rep[Aggregator[E]], g : Rep[((A) => E)])(implicit typeE : TypeRep[E], typeA : TypeRep[A]) : Rep[(A => Unit)] = AggregatorCompose[E, A](self, g)
   def aggregatorAndThen[E <: ddbt.lib.store.Entry, A](self : Rep[Aggregator[E]], g : Rep[((Unit) => A)])(implicit typeE : TypeRep[E], typeA : TypeRep[A]) : Rep[(E => A)] = AggregatorAndThen[E, A](self, g)
   def aggregatorMinObject[E <: ddbt.lib.store.Entry, R](f : Rep[(E => R)])(implicit typeE : TypeRep[E], typeR : TypeRep[R], order : Ordering[R]) : Rep[Aggregator[E]] = AggregatorMinObject[E, R](f)
   def aggregatorMaxObject[E <: ddbt.lib.store.Entry, R](f : Rep[(E => R)])(implicit typeE : TypeRep[E], typeR : TypeRep[R], order : Ordering[R]) : Rep[Aggregator[E]] = AggregatorMaxObject[E, R](f)
  type Aggregator[E <: ddbt.lib.store.Entry] = ddbt.lib.store.Aggregator[E]
}
object AggregatorIRs extends Base {
  // Type representation
  case class AggregatorType[E <: ddbt.lib.store.Entry](typeE: TypeRep[E]) extends TypeRep[Aggregator[E]] {
    def rebuild(newArguments: TypeRep[_]*): TypeRep[_] = AggregatorType(newArguments(0).asInstanceOf[TypeRep[_ <: ddbt.lib.store.Entry]])
    val name = s"Aggregator[${typeE.name}]"
    val typeArguments = List(typeE)
  }
      implicit def typeAggregator[E <: ddbt.lib.store.Entry: TypeRep]: TypeRep[Aggregator[E]] = AggregatorType(implicitly[TypeRep[E]])
  // case classes
  case class AggregatorApply[E <: ddbt.lib.store.Entry](self : Rep[Aggregator[E]], e : Rep[E])(implicit val typeE : TypeRep[E]) extends FunctionDef[Unit](Some(self), "apply", List(List(e))){
    override def curriedConstructor = (copy[E] _).curried
  }

  case class AggregatorResult[E <: ddbt.lib.store.Entry](self : Rep[Aggregator[E]])(implicit val typeE : TypeRep[E]) extends FunctionDef[E](Some(self), "result", List()){
    override def curriedConstructor = (copy[E] _)
    override def effect = Read(self)
  }

  case class AggregatorCompose[E <: ddbt.lib.store.Entry, A](self : Rep[Aggregator[E]], g : Rep[((A) => E)])(implicit val typeE : TypeRep[E], val typeA : TypeRep[A]) extends FunctionDef[(A => Unit)](Some(self), "compose", List(List(g))){
    override def curriedConstructor = (copy[E, A] _).curried
  }

  case class AggregatorAndThen[E <: ddbt.lib.store.Entry, A](self : Rep[Aggregator[E]], g : Rep[((Unit) => A)])(implicit val typeE : TypeRep[E], val typeA : TypeRep[A]) extends FunctionDef[(E => A)](Some(self), "andThen", List(List(g))){
    override def curriedConstructor = (copy[E, A] _).curried
  }

  case class AggregatorMinObject[E <: ddbt.lib.store.Entry, R](f : Rep[(E => R)])(implicit val typeE : TypeRep[E], val typeR : TypeRep[R], val order : Ordering[R]) extends FunctionDef[Aggregator[E]](None, "Aggregator.min", List(List(f))){
    override def curriedConstructor = (copy[E, R] _)
    override def isPure = true

    override def partiallyEvaluate(children: Any*): Aggregator[E] = {
      val f = children(0).asInstanceOf[(E => R)]
      ddbt.lib.store.MirrorAggregator.min[E, R](f)
    }
    override def partiallyEvaluable: Boolean = true

  }

  case class AggregatorMaxObject[E <: ddbt.lib.store.Entry, R](f : Rep[(E => R)])(implicit val typeE : TypeRep[E], val typeR : TypeRep[R], val order : Ordering[R]) extends FunctionDef[Aggregator[E]](None, "Aggregator.max", List(List(f))){
    override def curriedConstructor = (copy[E, R] _)
    override def isPure = true

    override def partiallyEvaluate(children: Any*): Aggregator[E] = {
      val f = children(0).asInstanceOf[(E => R)]
      ddbt.lib.store.MirrorAggregator.max[E, R](f)
    }
    override def partiallyEvaluable: Boolean = true

  }

  type Aggregator[E <: ddbt.lib.store.Entry] = ddbt.lib.store.Aggregator[E]
}
trait AggregatorImplicits extends AggregatorOps { 
  // Add implicit conversions here!
}
trait AggregatorComponent extends AggregatorOps with AggregatorImplicits {  }

trait AggregatorPartialEvaluation extends AggregatorComponent with BasePartialEvaluation {  
  // Immutable field inlining 

  // Mutable field inlining 
  // Pure function partial evaluation
}


